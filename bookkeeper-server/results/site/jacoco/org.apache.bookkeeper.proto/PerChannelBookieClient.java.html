<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PerChannelBookieClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.proto</a> &gt; <span class="el_source">PerChannelBookieClient.java</span></div><h1>PerChannelBookieClient.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information

 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.proto;

import static org.apache.bookkeeper.client.LedgerHandle.INVALID_ENTRY_ID;

import com.google.common.base.Joiner;
import com.google.common.collect.Sets;
import com.google.protobuf.ByteString;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.UnsafeByteOperations;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.channel.DefaultEventLoopGroup;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.WriteBufferWaterMark;
import io.netty.channel.epoll.EpollChannelOption;
import io.netty.channel.epoll.EpollEventLoopGroup;
import io.netty.channel.epoll.EpollSocketChannel;
import io.netty.channel.local.LocalAddress;
import io.netty.channel.local.LocalChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.channel.unix.Errors.NativeIoException;
import io.netty.handler.codec.CorruptedFrameException;
import io.netty.handler.codec.DecoderException;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.TooLongFrameException;
import io.netty.handler.flush.FlushConsolidationHandler;
import io.netty.handler.ssl.SslHandler;
import io.netty.incubator.channel.uring.IOUringChannelOption;
import io.netty.incubator.channel.uring.IOUringEventLoopGroup;
import io.netty.incubator.channel.uring.IOUringSocketChannel;
import io.netty.util.Recycler;
import io.netty.util.Recycler.Handle;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.ReferenceCounted;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.UnknownHostException;
import java.security.cert.Certificate;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.BiPredicate;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLPeerUnverifiedException;
import lombok.SneakyThrows;
import org.apache.bookkeeper.auth.BookKeeperPrincipal;
import org.apache.bookkeeper.auth.ClientAuthProvider;
import org.apache.bookkeeper.client.BKException;
import org.apache.bookkeeper.client.BookKeeperClientStats;
import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;
import org.apache.bookkeeper.client.api.WriteFlag;
import org.apache.bookkeeper.common.util.MathUtils;
import org.apache.bookkeeper.common.util.MdcUtils;
import org.apache.bookkeeper.common.util.OrderedExecutor;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.net.BookieSocketAddress;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.BatchedReadEntryCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ForceLedgerCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetBookieInfoCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GetListOfEntriesOfLedgerCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallbackCtx;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadLacCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.StartTLSCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteLacCallback;
import org.apache.bookkeeper.proto.BookkeeperProtocol.AddRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.AddResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.BKPacketHeader;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ForceLedgerRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ForceLedgerResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.GetBookieInfoRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.GetBookieInfoResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.GetListOfEntriesOfLedgerRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.GetListOfEntriesOfLedgerResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.OperationType;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ProtocolVersion;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadLacResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.ReadResponse;
import org.apache.bookkeeper.proto.BookkeeperProtocol.Request;
import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;
import org.apache.bookkeeper.proto.BookkeeperProtocol.StatusCode;
import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacRequest;
import org.apache.bookkeeper.proto.BookkeeperProtocol.WriteLacResponse;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.NullStatsLogger;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.stats.annotations.StatsDoc;
import org.apache.bookkeeper.tls.SecurityException;
import org.apache.bookkeeper.tls.SecurityHandlerFactory;
import org.apache.bookkeeper.tls.SecurityHandlerFactory.NodeType;
import org.apache.bookkeeper.util.AvailabilityOfEntriesOfLedger;
import org.apache.bookkeeper.util.ByteBufList;
import org.apache.bookkeeper.util.StringUtils;
import org.apache.bookkeeper.util.collections.ConcurrentOpenHashMap;
import org.apache.bookkeeper.util.collections.SynchronizedHashMultiMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

/**
 * This class manages all details of connection to a particular bookie. It also
 * has reconnect logic if a connection to a bookie fails.
 */
@StatsDoc(
    name = BookKeeperClientStats.CHANNEL_SCOPE,
    help = &quot;Per channel bookie client stats&quot;
)
@Sharable
public class PerChannelBookieClient extends ChannelInboundHandlerAdapter {

<span class="nc" id="L165">    static final Logger LOG = LoggerFactory.getLogger(PerChannelBookieClient.class);</span>

    // this set contains the bookie error return codes that we do not consider for a bookie to be &quot;faulty&quot;
<span class="nc" id="L168">    private static final Set&lt;Integer&gt; expectedBkOperationErrors = Collections.unmodifiableSet(Sets</span>
<span class="nc" id="L169">            .newHashSet(BKException.Code.BookieHandleNotAvailableException,</span>
<span class="nc" id="L170">                        BKException.Code.NoSuchEntryException,</span>
<span class="nc" id="L171">                        BKException.Code.NoSuchLedgerExistsException,</span>
<span class="nc" id="L172">                        BKException.Code.LedgerFencedException,</span>
<span class="nc" id="L173">                        BKException.Code.LedgerExistException,</span>
<span class="nc" id="L174">                        BKException.Code.DuplicateEntryIdException,</span>
<span class="nc" id="L175">                        BKException.Code.WriteOnReadOnlyBookieException));</span>
    private static final int DEFAULT_HIGH_PRIORITY_VALUE = 100; // We may add finer grained priority later.
<span class="nc" id="L177">    private static final AtomicLong txnIdGenerator = new AtomicLong(0);</span>
    static final String CONSOLIDATION_HANDLER_NAME = &quot;consolidation&quot;;

    final BookieId bookieId;
    final BookieAddressResolver bookieAddressResolver;
    final EventLoopGroup eventLoopGroup;
    final ByteBufAllocator allocator;
    final OrderedExecutor executor;
    final long addEntryTimeoutNanos;
    final long readEntryTimeoutNanos;
    final int maxFrameSize;
    final long getBookieInfoTimeoutNanos;
    final int startTLSTimeout;

<span class="nc" id="L191">    private final ConcurrentOpenHashMap&lt;CompletionKey, CompletionValue&gt; completionObjects =</span>
<span class="nc" id="L192">            ConcurrentOpenHashMap.&lt;CompletionKey, CompletionValue&gt;newBuilder().autoShrink(true).build();</span>

    // Map that hold duplicated read requests. The idea is to only use this map (synchronized) when there is a duplicate
    // read request for the same ledgerId/entryId
<span class="nc" id="L196">    private final SynchronizedHashMultiMap&lt;CompletionKey, CompletionValue&gt; completionObjectsV2Conflicts =</span>
        new SynchronizedHashMultiMap&lt;&gt;();

    private final StatsLogger statsLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_READ_OP,
        help = &quot;channel stats of read entries requests&quot;
    )
    private final OpStatsLogger readEntryOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_READ,
        help = &quot;timeout stats of read entries requests&quot;
    )
    private final OpStatsLogger readTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_ADD_OP,
        help = &quot;channel stats of add entries requests&quot;
    )
    private final OpStatsLogger addEntryOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_WRITE_LAC_OP,
        help = &quot;channel stats of write_lac requests&quot;
    )
    private final OpStatsLogger writeLacOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_FORCE_OP,
        help = &quot;channel stats of force requests&quot;
    )
    private final OpStatsLogger forceLedgerOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_READ_LAC_OP,
        help = &quot;channel stats of read_lac requests&quot;
    )
    private final OpStatsLogger readLacOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_ADD,
        help = &quot;timeout stats of add entries requests&quot;
    )
    private final OpStatsLogger addTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_WRITE_LAC,
        help = &quot;timeout stats of write_lac requests&quot;
    )
    private final OpStatsLogger writeLacTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_FORCE,
        help = &quot;timeout stats of force requests&quot;
    )
    private final OpStatsLogger forceLedgerTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_READ_LAC,
        help = &quot;timeout stats of read_lac requests&quot;
    )
    private final OpStatsLogger readLacTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.GET_BOOKIE_INFO_OP,
        help = &quot;channel stats of get_bookie_info requests&quot;
    )
    private final OpStatsLogger getBookieInfoOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.TIMEOUT_GET_BOOKIE_INFO,
        help = &quot;timeout stats of get_bookie_info requests&quot;
    )
    private final OpStatsLogger getBookieInfoTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_START_TLS_OP,
        help = &quot;channel stats of start_tls requests&quot;
    )
    private final OpStatsLogger startTLSOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CHANNEL_TIMEOUT_START_TLS_OP,
        help = &quot;timeout stats of start_tls requests&quot;
    )
    private final OpStatsLogger startTLSTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.CLIENT_CONNECT_TIMER,
        help = &quot;channel stats of connect requests&quot;
    )
    private final OpStatsLogger connectTimer;
    private final OpStatsLogger getListOfEntriesOfLedgerCompletionOpLogger;
    private final OpStatsLogger getListOfEntriesOfLedgerCompletionTimeoutOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.NETTY_EXCEPTION_CNT,
        help = &quot;the number of exceptions received from this channel&quot;
    )
    private final Counter exceptionCounter;
    @StatsDoc(
        name = BookKeeperClientStats.ADD_OP_OUTSTANDING,
        help = &quot;the number of outstanding add_entry requests&quot;
    )
    private final Counter addEntryOutstanding;
    @StatsDoc(
        name = BookKeeperClientStats.READ_OP_OUTSTANDING,
        help = &quot;the number of outstanding add_entry requests&quot;
    )
    private final Counter readEntryOutstanding;
    /* collect stats on all Ops that flows through netty pipeline */
    @StatsDoc(
        name = BookKeeperClientStats.NETTY_OPS,
        help = &quot;channel stats for all operations flowing through netty pipeline&quot;
    )
    private final OpStatsLogger nettyOpLogger;
    @StatsDoc(
        name = BookKeeperClientStats.ACTIVE_NON_TLS_CHANNEL_COUNTER,
        help = &quot;the number of active non-tls channels&quot;
    )
    private final Counter activeNonTlsChannelCounter;
    @StatsDoc(
        name = BookKeeperClientStats.ACTIVE_TLS_CHANNEL_COUNTER,
        help = &quot;the number of active tls channels&quot;
    )
    private final Counter activeTlsChannelCounter;
    @StatsDoc(
        name = BookKeeperClientStats.FAILED_CONNECTION_COUNTER,
        help = &quot;the number of failed connections&quot;
    )
    private final Counter failedConnectionCounter;
    @StatsDoc(
        name = BookKeeperClientStats.FAILED_TLS_HANDSHAKE_COUNTER,
        help = &quot;the number of failed tls handshakes&quot;
    )
    private final Counter failedTlsHandshakeCounter;

    private final boolean useV2WireProtocol;
    private final boolean preserveMdcForTaskExecution;

    /**
     * The following member variables do not need to be concurrent, or volatile
     * because they are always updated under a lock.
     */
<span class="nc" id="L326">    private volatile Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; pendingOps =</span>
            new ArrayDeque&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt;();
<span class="nc" id="L328">    volatile Channel channel = null;</span>
    private final ClientConnectionPeer connectionPeer;
<span class="nc" id="L330">    private volatile BookKeeperPrincipal authorizedId = BookKeeperPrincipal.ANONYMOUS;</span>

<span class="nc" id="L332">    @SneakyThrows</span>
    private FailedChannelFutureImpl processBookieNotResolvedError(long startTime,
            BookieAddressResolver.BookieIdNotResolvedException err) {
<span class="nc" id="L335">        FailedChannelFutureImpl failedFuture = new FailedChannelFutureImpl(err);</span>
<span class="nc" id="L336">        contextPreservingListener(new ConnectionFutureListener(startTime)).operationComplete(failedFuture);</span>
<span class="nc" id="L337">        return failedFuture;</span>
    }

<span class="nc" id="L340">    enum ConnectionState {</span>
<span class="nc" id="L341">        DISCONNECTED, CONNECTING, CONNECTED, CLOSED, START_TLS</span>
    }

    volatile ConnectionState state;
<span class="nc" id="L345">    final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();</span>
    private final ClientConfiguration conf;

    private final PerChannelBookieClientPool pcbcPool;
    private final ClientAuthProvider.Factory authProviderFactory;
    private final ExtensionRegistry extRegistry;
    private final SecurityHandlerFactory shFactory;
<span class="nc" id="L352">    private volatile boolean isWritable = true;</span>
<span class="nc" id="L353">    private long lastBookieUnavailableLogTimestamp = 0;</span>

    public PerChannelBookieClient(OrderedExecutor executor, EventLoopGroup eventLoopGroup,
                                  BookieId addr, BookieAddressResolver bookieAddressResolver) throws SecurityException {
<span class="nc" id="L357">        this(new ClientConfiguration(), executor, eventLoopGroup, addr, NullStatsLogger.INSTANCE, null, null,</span>
                null, bookieAddressResolver);
<span class="nc" id="L359">    }</span>

    public PerChannelBookieClient(OrderedExecutor executor, EventLoopGroup eventLoopGroup,
                                  BookieId bookieId,
                                  ClientAuthProvider.Factory authProviderFactory,
                                  ExtensionRegistry extRegistry, BookieAddressResolver bookieAddressResolver)
            throws SecurityException {
<span class="nc" id="L366">        this(new ClientConfiguration(), executor, eventLoopGroup, bookieId,</span>
                NullStatsLogger.INSTANCE,
                authProviderFactory, extRegistry, null, bookieAddressResolver);
<span class="nc" id="L369">    }</span>

    public PerChannelBookieClient(ClientConfiguration conf, OrderedExecutor executor,
                                  EventLoopGroup eventLoopGroup, BookieId bookieId,
                                  StatsLogger parentStatsLogger, ClientAuthProvider.Factory authProviderFactory,
                                  ExtensionRegistry extRegistry,
                                  PerChannelBookieClientPool pcbcPool, BookieAddressResolver bookieAddressResolver)
            throws SecurityException {
<span class="nc" id="L377">        this(conf, executor, eventLoopGroup, UnpooledByteBufAllocator.DEFAULT, bookieId, NullStatsLogger.INSTANCE,</span>
                authProviderFactory, extRegistry, pcbcPool, null, bookieAddressResolver);
<span class="nc" id="L379">    }</span>

    public PerChannelBookieClient(ClientConfiguration conf, OrderedExecutor executor,
                                  EventLoopGroup eventLoopGroup,
                                  ByteBufAllocator allocator,
                                  BookieId bookieId,
                                  StatsLogger parentStatsLogger, ClientAuthProvider.Factory authProviderFactory,
                                  ExtensionRegistry extRegistry,
                                  PerChannelBookieClientPool pcbcPool,
                                  SecurityHandlerFactory shFactory,
<span class="nc" id="L389">                                  BookieAddressResolver bookieAddressResolver) throws SecurityException {</span>
<span class="nc" id="L390">        this.maxFrameSize = conf.getNettyMaxFrameSizeBytes();</span>
<span class="nc" id="L391">        this.conf = conf;</span>
<span class="nc" id="L392">        this.bookieId = bookieId;</span>
<span class="nc" id="L393">        this.bookieAddressResolver = bookieAddressResolver;</span>
<span class="nc" id="L394">        this.executor = executor;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (LocalBookiesRegistry.isLocalBookie(bookieId)) {</span>
<span class="nc" id="L396">            this.eventLoopGroup = new DefaultEventLoopGroup();</span>
        } else {
<span class="nc" id="L398">            this.eventLoopGroup = eventLoopGroup;</span>
        }
<span class="nc" id="L400">        this.allocator = allocator;</span>
<span class="nc" id="L401">        this.state = ConnectionState.DISCONNECTED;</span>
<span class="nc" id="L402">        this.addEntryTimeoutNanos = TimeUnit.SECONDS.toNanos(conf.getAddEntryTimeout());</span>
<span class="nc" id="L403">        this.readEntryTimeoutNanos = TimeUnit.SECONDS.toNanos(conf.getReadEntryTimeout());</span>
<span class="nc" id="L404">        this.getBookieInfoTimeoutNanos = TimeUnit.SECONDS.toNanos(conf.getBookieInfoTimeout());</span>
<span class="nc" id="L405">        this.startTLSTimeout = conf.getStartTLSTimeout();</span>
<span class="nc" id="L406">        this.useV2WireProtocol = conf.getUseV2WireProtocol();</span>
<span class="nc" id="L407">        this.preserveMdcForTaskExecution = conf.getPreserveMdcForTaskExecution();</span>

<span class="nc" id="L409">        this.authProviderFactory = authProviderFactory;</span>
<span class="nc" id="L410">        this.extRegistry = extRegistry;</span>
<span class="nc" id="L411">        this.shFactory = shFactory;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (shFactory != null) {</span>
<span class="nc" id="L413">            shFactory.init(NodeType.Client, conf, allocator);</span>
        }

<span class="nc" id="L416">        this.statsLogger = parentStatsLogger.scope(BookKeeperClientStats.CHANNEL_SCOPE)</span>
<span class="nc" id="L417">            .scopeLabel(BookKeeperClientStats.BOOKIE_LABEL, bookieId.toString());</span>

<span class="nc" id="L419">        readEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_OP);</span>
<span class="nc" id="L420">        addEntryOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_ADD_OP);</span>
<span class="nc" id="L421">        writeLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_WRITE_LAC_OP);</span>
<span class="nc" id="L422">        forceLedgerOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_FORCE_OP);</span>
<span class="nc" id="L423">        readLacOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_READ_LAC_OP);</span>
<span class="nc" id="L424">        getBookieInfoOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.GET_BOOKIE_INFO_OP);</span>
<span class="nc" id="L425">        getListOfEntriesOfLedgerCompletionOpLogger = statsLogger</span>
<span class="nc" id="L426">                .getOpStatsLogger(BookKeeperClientStats.GET_LIST_OF_ENTRIES_OF_LEDGER_OP);</span>
<span class="nc" id="L427">        readTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ);</span>
<span class="nc" id="L428">        addTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_ADD);</span>
<span class="nc" id="L429">        writeLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_WRITE_LAC);</span>
<span class="nc" id="L430">        forceLedgerTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_FORCE);</span>
<span class="nc" id="L431">        readLacTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_READ_LAC);</span>
<span class="nc" id="L432">        getBookieInfoTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.TIMEOUT_GET_BOOKIE_INFO);</span>
<span class="nc" id="L433">        startTLSOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_START_TLS_OP);</span>
<span class="nc" id="L434">        startTLSTimeoutOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.CHANNEL_TIMEOUT_START_TLS_OP);</span>
<span class="nc" id="L435">        getListOfEntriesOfLedgerCompletionTimeoutOpLogger = statsLogger</span>
<span class="nc" id="L436">                .getOpStatsLogger(BookKeeperClientStats.TIMEOUT_GET_LIST_OF_ENTRIES_OF_LEDGER);</span>
<span class="nc" id="L437">        exceptionCounter = statsLogger.getCounter(BookKeeperClientStats.NETTY_EXCEPTION_CNT);</span>
<span class="nc" id="L438">        connectTimer = statsLogger.getOpStatsLogger(BookKeeperClientStats.CLIENT_CONNECT_TIMER);</span>
<span class="nc" id="L439">        addEntryOutstanding = statsLogger.getCounter(BookKeeperClientStats.ADD_OP_OUTSTANDING);</span>
<span class="nc" id="L440">        readEntryOutstanding = statsLogger.getCounter(BookKeeperClientStats.READ_OP_OUTSTANDING);</span>
<span class="nc" id="L441">        nettyOpLogger = statsLogger.getOpStatsLogger(BookKeeperClientStats.NETTY_OPS);</span>
<span class="nc" id="L442">        activeNonTlsChannelCounter = statsLogger.getCounter(BookKeeperClientStats.ACTIVE_NON_TLS_CHANNEL_COUNTER);</span>
<span class="nc" id="L443">        activeTlsChannelCounter = statsLogger.getCounter(BookKeeperClientStats.ACTIVE_TLS_CHANNEL_COUNTER);</span>
<span class="nc" id="L444">        failedConnectionCounter = statsLogger.getCounter(BookKeeperClientStats.FAILED_CONNECTION_COUNTER);</span>
<span class="nc" id="L445">        failedTlsHandshakeCounter = statsLogger.getCounter(BookKeeperClientStats.FAILED_TLS_HANDSHAKE_COUNTER);</span>

<span class="nc" id="L447">        this.pcbcPool = pcbcPool;</span>

<span class="nc" id="L449">        this.connectionPeer = new ClientConnectionPeer() {</span>

            @Override
            public SocketAddress getRemoteAddr() {
<span class="nc" id="L453">                Channel c = channel;</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">                if (c != null) {</span>
<span class="nc" id="L455">                    return c.remoteAddress();</span>
                } else {
<span class="nc" id="L457">                    return null;</span>
                }
            }

            @Override
            public Collection&lt;Object&gt; getProtocolPrincipals() {
<span class="nc" id="L463">                Channel c = channel;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                if (c == null) {</span>
<span class="nc" id="L465">                    return Collections.emptyList();</span>
                }
<span class="nc" id="L467">                SslHandler ssl = c.pipeline().get(SslHandler.class);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">                if (ssl == null) {</span>
<span class="nc" id="L469">                    return Collections.emptyList();</span>
                }
                try {
<span class="nc" id="L472">                    Certificate[] certificates = ssl.engine().getSession().getPeerCertificates();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                    if (certificates == null) {</span>
<span class="nc" id="L474">                        return Collections.emptyList();</span>
                    }
<span class="nc" id="L476">                    List&lt;Object&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L477">                    result.addAll(Arrays.asList(certificates));</span>
<span class="nc" id="L478">                    return result;</span>
<span class="nc" id="L479">                } catch (SSLPeerUnverifiedException err) {</span>
<span class="nc" id="L480">                     return Collections.emptyList();</span>
                }
            }

            @Override
            public void disconnect() {
<span class="nc" id="L486">                Channel c = channel;</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                if (c != null) {</span>
<span class="nc" id="L488">                    c.close().addListener(x -&gt; makeWritable());</span>
                }
<span class="nc" id="L490">                LOG.info(&quot;authplugin disconnected channel {}&quot;, channel);</span>
<span class="nc" id="L491">            }</span>

            @Override
            public void setAuthorizedId(BookKeeperPrincipal principal) {
<span class="nc" id="L495">                authorizedId = principal;</span>
<span class="nc" id="L496">                LOG.info(&quot;connection {} authenticated as {}&quot;, channel, principal);</span>
<span class="nc" id="L497">            }</span>

            @Override
            public BookKeeperPrincipal getAuthorizedId() {
<span class="nc" id="L501">                return authorizedId;</span>
            }

            @Override
            public boolean isSecure() {
<span class="nc" id="L506">               Channel c = channel;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">               if (c == null) {</span>
<span class="nc" id="L508">                    return false;</span>
               } else {
<span class="nc bnc" id="L510" title="All 2 branches missed.">                    return c.pipeline().get(SslHandler.class) != null;</span>
               }
            }

        };
<span class="nc" id="L515">    }</span>

    private void completeOperation(GenericCallback&lt;PerChannelBookieClient&gt; op, int rc) {
<span class="nc" id="L518">        closeLock.readLock().lock();</span>
        try {
<span class="nc bnc" id="L520" title="All 2 branches missed.">            if (ConnectionState.CLOSED == state) {</span>
<span class="nc" id="L521">                op.operationComplete(BKException.Code.ClientClosedException, this);</span>
            } else {
<span class="nc" id="L523">                op.operationComplete(rc, this);</span>
            }
        } finally {
<span class="nc" id="L526">            closeLock.readLock().unlock();</span>
        }
<span class="nc" id="L528">    }</span>

    protected long getNumPendingCompletionRequests() {
<span class="nc" id="L531">        return completionObjects.size();</span>
    }

    protected ChannelFuture connect() {
<span class="nc" id="L535">        final long startTime = MathUtils.nowInNano();</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L537">            LOG.debug(&quot;Connecting to bookie: {}&quot;, bookieId);</span>
        }
        BookieSocketAddress addr;
        try {
<span class="nc" id="L541">            addr = bookieAddressResolver.resolve(bookieId);</span>
<span class="nc" id="L542">        } catch (BookieAddressResolver.BookieIdNotResolvedException err) {</span>
<span class="nc" id="L543">            LOG.error(&quot;Cannot connect to {} as endpoint resolution failed (probably bookie is down) err {}&quot;,</span>
<span class="nc" id="L544">                    bookieId, err.toString());</span>
<span class="nc" id="L545">            return processBookieNotResolvedError(startTime, err);</span>
<span class="nc" id="L546">        }</span>

        // Set up the ClientBootStrap so we can create a new Channel connection to the bookie.
<span class="nc" id="L549">        Bootstrap bootstrap = new Bootstrap();</span>
<span class="nc" id="L550">        bootstrap.group(eventLoopGroup);</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (eventLoopGroup instanceof IOUringEventLoopGroup) {</span>
<span class="nc" id="L552">            bootstrap.channel(IOUringSocketChannel.class);</span>
            try {
<span class="nc" id="L554">                bootstrap.option(IOUringChannelOption.TCP_USER_TIMEOUT, conf.getTcpUserTimeoutMillis());</span>
<span class="nc" id="L555">            } catch (NoSuchElementException e) {</span>
                // Property not set, so keeping default value.
<span class="nc" id="L557">            }</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">        } else if (eventLoopGroup instanceof EpollEventLoopGroup) {</span>
<span class="nc" id="L559">            bootstrap.channel(EpollSocketChannel.class);</span>
            try {
                // For Epoll channels, configure the TCP user timeout.
<span class="nc" id="L562">                bootstrap.option(EpollChannelOption.TCP_USER_TIMEOUT, conf.getTcpUserTimeoutMillis());</span>
<span class="nc" id="L563">            } catch (NoSuchElementException e) {</span>
                // Property not set, so keeping default value.
<span class="nc" id="L565">            }</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">        } else if (eventLoopGroup instanceof DefaultEventLoopGroup) {</span>
<span class="nc" id="L567">            bootstrap.channel(LocalChannel.class);</span>
        } else {
<span class="nc" id="L569">            bootstrap.channel(NioSocketChannel.class);</span>
        }

<span class="nc" id="L572">        bootstrap.option(ChannelOption.ALLOCATOR, this.allocator);</span>
<span class="nc" id="L573">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, conf.getClientConnectTimeoutMillis());</span>
<span class="nc" id="L574">        bootstrap.option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(</span>
<span class="nc" id="L575">                conf.getClientWriteBufferLowWaterMark(), conf.getClientWriteBufferHighWaterMark()));</span>

<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (!(eventLoopGroup instanceof DefaultEventLoopGroup)) {</span>
<span class="nc" id="L578">            bootstrap.option(ChannelOption.TCP_NODELAY, conf.getClientTcpNoDelay());</span>
<span class="nc" id="L579">            bootstrap.option(ChannelOption.SO_KEEPALIVE, conf.getClientSockKeepalive());</span>

            // if buffer sizes are 0, let OS auto-tune it
<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (conf.getClientSendBufferSize() &gt; 0) {</span>
<span class="nc" id="L583">                bootstrap.option(ChannelOption.SO_SNDBUF, conf.getClientSendBufferSize());</span>
            }

<span class="nc bnc" id="L586" title="All 2 branches missed.">            if (conf.getClientReceiveBufferSize() &gt; 0) {</span>
<span class="nc" id="L587">                bootstrap.option(ChannelOption.SO_RCVBUF, conf.getClientReceiveBufferSize());</span>
            }
        }

        // In the netty pipeline, we need to split packets based on length, so we
        // use the {@link LengthFieldBasedFrameDecoder}. Other than that all actions
        // are carried out in this class, e.g., making sense of received messages,
        // prepending the length to outgoing packets etc.
<span class="nc" id="L595">        bootstrap.handler(new ChannelInitializer&lt;Channel&gt;() {</span>
            @Override
            protected void initChannel(Channel ch) throws Exception {
<span class="nc" id="L598">                ChannelPipeline pipeline = ch.pipeline();</span>
<span class="nc" id="L599">                pipeline.addLast(CONSOLIDATION_HANDLER_NAME, new FlushConsolidationHandler(1024, true));</span>
<span class="nc" id="L600">                pipeline.addLast(&quot;bytebufList&quot;, ByteBufList.ENCODER);</span>
<span class="nc" id="L601">                pipeline.addLast(&quot;lengthbasedframedecoder&quot;,</span>
                        new LengthFieldBasedFrameDecoder(maxFrameSize, 0, 4, 0, 4));
<span class="nc" id="L603">                pipeline.addLast(&quot;bookieProtoEncoder&quot;, new BookieProtoEncoding.RequestEncoder(extRegistry));</span>
<span class="nc" id="L604">                pipeline.addLast(</span>
                    &quot;bookieProtoDecoder&quot;,
<span class="nc bnc" id="L606" title="All 2 branches missed.">                    new BookieProtoEncoding.ResponseDecoder(extRegistry, useV2WireProtocol, shFactory != null));</span>
<span class="nc" id="L607">                pipeline.addLast(&quot;authHandler&quot;, new AuthHandler.ClientSideHandler(authProviderFactory, txnIdGenerator,</span>
<span class="nc" id="L608">                            connectionPeer, useV2WireProtocol));</span>
<span class="nc" id="L609">                pipeline.addLast(&quot;mainhandler&quot;, PerChannelBookieClient.this);</span>
<span class="nc" id="L610">            }</span>
        });

<span class="nc" id="L613">        SocketAddress bookieAddr = addr.getSocketAddress();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (eventLoopGroup instanceof DefaultEventLoopGroup) {</span>
<span class="nc" id="L615">            bookieAddr = new LocalAddress(bookieId.toString());</span>
        }

<span class="nc" id="L618">        ChannelFuture future = bootstrap.connect(bookieAddr);</span>
<span class="nc" id="L619">        addChannelListeners(future, startTime);</span>
<span class="nc" id="L620">        return future;</span>
    }

    protected void addChannelListeners(ChannelFuture future, long connectStartTime) {
<span class="nc" id="L624">        future.addListener(contextPreservingListener(new ConnectionFutureListener(connectStartTime)));</span>
<span class="nc" id="L625">        future.addListener(x -&gt; makeWritable());</span>
<span class="nc" id="L626">    }</span>

    void cleanDisconnectAndClose() {
<span class="nc" id="L629">        disconnect();</span>
<span class="nc" id="L630">        close();</span>
<span class="nc" id="L631">    }</span>

    /**
     *
     * @return boolean, true is PCBC is writable
     */
    public boolean isWritable() {
<span class="nc" id="L638">        return isWritable;</span>
    }

    public void setWritable(boolean val) {
<span class="nc" id="L642">        isWritable = val;</span>
<span class="nc" id="L643">    }</span>

    private void makeWritable() {
<span class="nc" id="L646">        setWritable(true);</span>
<span class="nc" id="L647">    }</span>

    void connectIfNeededAndDoOp(GenericCallback&lt;PerChannelBookieClient&gt; op) {
<span class="nc" id="L650">        boolean completeOpNow = false;</span>
<span class="nc" id="L651">        int opRc = BKException.Code.OK;</span>
        // common case without lock first
<span class="nc bnc" id="L653" title="All 4 branches missed.">        if (channel != null &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc" id="L654">            completeOpNow = true;</span>
        } else {

<span class="nc" id="L657">            synchronized (this) {</span>
                // check the channel status again under lock
<span class="nc bnc" id="L659" title="All 4 branches missed.">                if (channel != null &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc" id="L660">                    completeOpNow = true;</span>
<span class="nc" id="L661">                    opRc = BKException.Code.OK;</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">                } else if (state == ConnectionState.CLOSED) {</span>
<span class="nc" id="L663">                    completeOpNow = true;</span>
<span class="nc" id="L664">                    opRc = BKException.Code.BookieHandleNotAvailableException;</span>
                } else {
                    // channel is either null (first connection attempt), or the
                    // channel is disconnected. Connection attempt is still in
                    // progress, queue up this op. Op will be executed when
                    // connection attempt either fails or succeeds
<span class="nc" id="L670">                    pendingOps.add(op);</span>

<span class="nc bnc" id="L672" title="All 4 branches missed.">                    if (state == ConnectionState.CONNECTING</span>
                        || state == ConnectionState.START_TLS) {
                        // the connection request has already been sent and it is waiting for the response.
<span class="nc" id="L675">                        return;</span>
                    }
                    // switch state to connecting and do connection attempt
<span class="nc" id="L678">                    state = ConnectionState.CONNECTING;</span>
                }
<span class="nc" id="L680">            }</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">            if (!completeOpNow) {</span>
                // Start connection attempt to the input server host.
<span class="nc" id="L683">                connect();</span>
            }
        }

<span class="nc bnc" id="L687" title="All 2 branches missed.">        if (completeOpNow) {</span>
<span class="nc" id="L688">            completeOperation(op, opRc);</span>
        }

<span class="nc" id="L691">    }</span>

    void writeLac(final long ledgerId, final byte[] masterKey, final long lac, ByteBufList toSend, WriteLacCallback cb,
            Object ctx) {
<span class="nc" id="L695">        final long txnId = getTxnId();</span>
<span class="nc" id="L696">        final CompletionKey completionKey = new TxnCompletionKey(txnId,</span>
                                                                OperationType.WRITE_LAC);
        // writeLac is mostly like addEntry hence uses addEntryTimeout
<span class="nc" id="L699">        completionObjects.put(completionKey,</span>
                              new WriteLacCompletion(completionKey, cb,
                                                     ctx, ledgerId));

        // Build the request
<span class="nc" id="L704">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L705">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L706">                .setOperation(OperationType.WRITE_LAC)</span>
<span class="nc" id="L707">                .setTxnId(txnId);</span>
<span class="nc" id="L708">        ByteString body = ByteStringUtil.byteBufListToByteString(toSend);</span>
<span class="nc" id="L709">        toSend.retain();</span>
<span class="nc" id="L710">        Runnable cleanupActionFailedBeforeWrite = toSend::release;</span>
<span class="nc" id="L711">        Runnable cleanupActionAfterWrite = cleanupActionFailedBeforeWrite;</span>
<span class="nc" id="L712">        WriteLacRequest.Builder writeLacBuilder = WriteLacRequest.newBuilder()</span>
<span class="nc" id="L713">                .setLedgerId(ledgerId)</span>
<span class="nc" id="L714">                .setLac(lac)</span>
<span class="nc" id="L715">                .setMasterKey(UnsafeByteOperations.unsafeWrap(masterKey))</span>
<span class="nc" id="L716">                .setBody(body);</span>

<span class="nc" id="L718">        final Request writeLacRequest = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L719">                .setHeader(headerBuilder)</span>
<span class="nc" id="L720">                .setWriteLacRequest(writeLacBuilder)</span>
<span class="nc" id="L721">                .build();</span>
<span class="nc" id="L722">        writeAndFlush(channel, completionKey, writeLacRequest, false, cleanupActionFailedBeforeWrite,</span>
                cleanupActionAfterWrite);
<span class="nc" id="L724">    }</span>

    void forceLedger(final long ledgerId, ForceLedgerCallback cb, Object ctx) {
<span class="nc bnc" id="L727" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L728">                LOG.error(&quot;force is not allowed with v2 protocol&quot;);</span>
<span class="nc" id="L729">                executor.executeOrdered(ledgerId, () -&gt; {</span>
<span class="nc" id="L730">                    cb.forceLedgerComplete(BKException.Code.IllegalOpException, ledgerId, bookieId, ctx);</span>
<span class="nc" id="L731">                });</span>
<span class="nc" id="L732">                return;</span>
        }
<span class="nc" id="L734">        final long txnId = getTxnId();</span>
<span class="nc" id="L735">        final CompletionKey completionKey = new TxnCompletionKey(txnId,</span>
                                                                OperationType.FORCE_LEDGER);
        // force is mostly like addEntry hence uses addEntryTimeout
<span class="nc" id="L738">        completionObjects.put(completionKey,</span>
                              new ForceLedgerCompletion(completionKey, cb,
                                                     ctx, ledgerId));

        // Build the request
<span class="nc" id="L743">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L744">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L745">                .setOperation(OperationType.FORCE_LEDGER)</span>
<span class="nc" id="L746">                .setTxnId(txnId);</span>
<span class="nc" id="L747">        ForceLedgerRequest.Builder writeLacBuilder = ForceLedgerRequest.newBuilder()</span>
<span class="nc" id="L748">                .setLedgerId(ledgerId);</span>

<span class="nc" id="L750">        final Request forceLedgerRequest = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L751">                .setHeader(headerBuilder)</span>
<span class="nc" id="L752">                .setForceLedgerRequest(writeLacBuilder)</span>
<span class="nc" id="L753">                .build();</span>
<span class="nc" id="L754">        writeAndFlush(channel, completionKey, forceLedgerRequest);</span>
<span class="nc" id="L755">    }</span>

    /**
     * This method should be called only after connection has been checked for
     * {@link #connectIfNeededAndDoOp(GenericCallback)}.
     *
     * @param ledgerId
     *          Ledger Id
     * @param masterKey
     *          Master Key
     * @param entryId
     *          Entry Id
     * @param toSend
     *          Buffer to send
     * @param cb
     *          Write callback
     * @param ctx
     *          Write callback context
     * @param allowFastFail
     *          allowFastFail flag
     * @param writeFlags
     *          WriteFlags
     */
    void addEntry(final long ledgerId, byte[] masterKey, final long entryId, ReferenceCounted toSend, WriteCallback cb,
                  Object ctx, final int options, boolean allowFastFail, final EnumSet&lt;WriteFlag&gt; writeFlags) {
<span class="nc" id="L780">        Object request = null;</span>
<span class="nc" id="L781">        CompletionKey completionKey = null;</span>
<span class="nc" id="L782">        Runnable cleanupActionFailedBeforeWrite = null;</span>
<span class="nc" id="L783">        Runnable cleanupActionAfterWrite = null;</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">            if (writeFlags.contains(WriteFlag.DEFERRED_SYNC)) {</span>
<span class="nc" id="L786">                LOG.error(&quot;invalid writeflags {} for v2 protocol&quot;, writeFlags);</span>
<span class="nc" id="L787">                cb.writeComplete(BKException.Code.IllegalOpException, ledgerId, entryId, bookieId, ctx);</span>
<span class="nc" id="L788">                return;</span>
            }
<span class="nc" id="L790">            completionKey = acquireV2Key(ledgerId, entryId, OperationType.ADD_ENTRY);</span>

<span class="nc bnc" id="L792" title="All 2 branches missed.">            if (toSend instanceof ByteBuf) {</span>
<span class="nc" id="L793">                ByteBuf byteBuf = ((ByteBuf) toSend).retainedDuplicate();</span>
<span class="nc" id="L794">                request = byteBuf;</span>
<span class="nc" id="L795">                cleanupActionFailedBeforeWrite = byteBuf::release;</span>
<span class="nc" id="L796">            } else {</span>
<span class="nc" id="L797">                ByteBufList byteBufList = (ByteBufList) toSend;</span>
<span class="nc" id="L798">                byteBufList.retain();</span>
<span class="nc" id="L799">                request = byteBufList;</span>
<span class="nc" id="L800">                cleanupActionFailedBeforeWrite = byteBufList::release;</span>
<span class="nc" id="L801">            }</span>
        } else {
<span class="nc" id="L803">            final long txnId = getTxnId();</span>
<span class="nc" id="L804">            completionKey = new TxnCompletionKey(txnId, OperationType.ADD_ENTRY);</span>

            // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L807">            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L808">                    .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L809">                    .setOperation(OperationType.ADD_ENTRY)</span>
<span class="nc" id="L810">                    .setTxnId(txnId);</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">            if (((short) options &amp; BookieProtocol.FLAG_HIGH_PRIORITY) == BookieProtocol.FLAG_HIGH_PRIORITY) {</span>
<span class="nc" id="L812">                headerBuilder.setPriority(DEFAULT_HIGH_PRIORITY_VALUE);</span>
            }

<span class="nc" id="L815">            ByteBufList bufToSend = (ByteBufList) toSend;</span>
<span class="nc" id="L816">            ByteString body = ByteStringUtil.byteBufListToByteString(bufToSend);</span>
<span class="nc" id="L817">            bufToSend.retain();</span>
<span class="nc" id="L818">            cleanupActionFailedBeforeWrite = bufToSend::release;</span>
<span class="nc" id="L819">            cleanupActionAfterWrite = cleanupActionFailedBeforeWrite;</span>
<span class="nc" id="L820">            AddRequest.Builder addBuilder = AddRequest.newBuilder()</span>
<span class="nc" id="L821">                    .setLedgerId(ledgerId)</span>
<span class="nc" id="L822">                    .setEntryId(entryId)</span>
<span class="nc" id="L823">                    .setMasterKey(UnsafeByteOperations.unsafeWrap(masterKey))</span>
<span class="nc" id="L824">                    .setBody(body);</span>

<span class="nc bnc" id="L826" title="All 2 branches missed.">            if (((short) options &amp; BookieProtocol.FLAG_RECOVERY_ADD) == BookieProtocol.FLAG_RECOVERY_ADD) {</span>
<span class="nc" id="L827">                addBuilder.setFlag(AddRequest.Flag.RECOVERY_ADD);</span>
            }

<span class="nc bnc" id="L830" title="All 2 branches missed.">            if (!writeFlags.isEmpty()) {</span>
                // add flags only if needed, in order to be able to talk with old bookies
<span class="nc" id="L832">                addBuilder.setWriteFlags(WriteFlag.getWriteFlagsValue(writeFlags));</span>
            }

<span class="nc" id="L835">            request = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L836">                    .setHeader(headerBuilder)</span>
<span class="nc" id="L837">                    .setAddRequest(addBuilder)</span>
<span class="nc" id="L838">                    .build();</span>
        }

<span class="nc" id="L841">        putCompletionKeyValue(completionKey,</span>
<span class="nc" id="L842">                              acquireAddCompletion(completionKey,</span>
                                                   cb, ctx, ledgerId, entryId));
        // addEntry times out on backpressure
<span class="nc" id="L845">        writeAndFlush(channel, completionKey, request, allowFastFail, cleanupActionFailedBeforeWrite,</span>
                cleanupActionAfterWrite);
<span class="nc" id="L847">    }</span>

    public void readLac(final long ledgerId, ReadLacCallback cb, Object ctx) {
<span class="nc" id="L850">        Object request = null;</span>
<span class="nc" id="L851">        CompletionKey completionKey = null;</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L853">            request = BookieProtocol.ReadRequest.create(BookieProtocol.CURRENT_PROTOCOL_VERSION,</span>
                                                     ledgerId, 0, (short) 0, null);
<span class="nc" id="L855">            completionKey = acquireV2Key(ledgerId, 0, OperationType.READ_LAC);</span>
        } else {
<span class="nc" id="L857">            final long txnId = getTxnId();</span>
<span class="nc" id="L858">            completionKey = new TxnCompletionKey(txnId, OperationType.READ_LAC);</span>

            // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L861">            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L862">                    .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L863">                    .setOperation(OperationType.READ_LAC)</span>
<span class="nc" id="L864">                    .setTxnId(txnId);</span>
<span class="nc" id="L865">            ReadLacRequest.Builder readLacBuilder = ReadLacRequest.newBuilder()</span>
<span class="nc" id="L866">                    .setLedgerId(ledgerId);</span>
<span class="nc" id="L867">            request = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L868">                    .setHeader(headerBuilder)</span>
<span class="nc" id="L869">                    .setReadLacRequest(readLacBuilder)</span>
<span class="nc" id="L870">                    .build();</span>
        }
<span class="nc" id="L872">        putCompletionKeyValue(completionKey,</span>
                              new ReadLacCompletion(completionKey, cb,
                                                    ctx, ledgerId));
<span class="nc" id="L875">        writeAndFlush(channel, completionKey, request);</span>
<span class="nc" id="L876">    }</span>

    public void getListOfEntriesOfLedger(final long ledgerId, GetListOfEntriesOfLedgerCallback cb) {
<span class="nc" id="L879">        final long txnId = getTxnId();</span>
<span class="nc" id="L880">        final CompletionKey completionKey = new TxnCompletionKey(txnId, OperationType.GET_LIST_OF_ENTRIES_OF_LEDGER);</span>
<span class="nc" id="L881">        completionObjects.put(completionKey, new GetListOfEntriesOfLedgerCompletion(completionKey, cb, ledgerId));</span>

        // Build the request.
<span class="nc" id="L884">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder().setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L885">                .setOperation(OperationType.GET_LIST_OF_ENTRIES_OF_LEDGER).setTxnId(txnId);</span>

        GetListOfEntriesOfLedgerRequest.Builder getListOfEntriesOfLedgerRequestBuilder =
<span class="nc" id="L888">                GetListOfEntriesOfLedgerRequest.newBuilder().setLedgerId(ledgerId);</span>

<span class="nc" id="L890">        final Request getListOfEntriesOfLedgerRequest = Request.newBuilder().setHeader(headerBuilder)</span>
<span class="nc" id="L891">                .setGetListOfEntriesOfLedgerRequest(getListOfEntriesOfLedgerRequestBuilder).build();</span>

<span class="nc" id="L893">        writeAndFlush(channel, completionKey, getListOfEntriesOfLedgerRequest);</span>
<span class="nc" id="L894">    }</span>

    /**
     * Long Poll Reads.
     */
    public void readEntryWaitForLACUpdate(final long ledgerId,
                                          final long entryId,
                                          final long previousLAC,
                                          final long timeOutInMillis,
                                          final boolean piggyBackEntry,
                                          ReadEntryCallback cb,
                                          Object ctx) {
<span class="nc" id="L906">        readEntryInternal(ledgerId, entryId, previousLAC, timeOutInMillis,</span>
                          piggyBackEntry, cb, ctx, (short) 0, null, false);
<span class="nc" id="L908">    }</span>

    /**
     * Normal Reads.
     */
    public void readEntry(final long ledgerId,
                          final long entryId,
                          ReadEntryCallback cb,
                          Object ctx,
                          int flags,
                          byte[] masterKey,
                          boolean allowFastFail) {
<span class="nc" id="L920">        readEntryInternal(ledgerId, entryId, null, null, false,</span>
                          cb, ctx, (short) flags, masterKey, allowFastFail);
<span class="nc" id="L922">    }</span>

    private void readEntryInternal(final long ledgerId,
                                   final long entryId,
                                   final Long previousLAC,
                                   final Long timeOutInMillis,
                                   final boolean piggyBackEntry,
                                   final ReadEntryCallback cb,
                                   final Object ctx,
                                   int flags,
                                   byte[] masterKey,
                                   boolean allowFastFail) {
<span class="nc" id="L934">        Object request = null;</span>
<span class="nc" id="L935">        CompletionKey completionKey = null;</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L937">            request = BookieProtocol.ReadRequest.create(BookieProtocol.CURRENT_PROTOCOL_VERSION,</span>
                    ledgerId, entryId, (short) flags, masterKey);
<span class="nc" id="L939">            completionKey = acquireV2Key(ledgerId, entryId, OperationType.READ_ENTRY);</span>
        } else {
<span class="nc" id="L941">            final long txnId = getTxnId();</span>
<span class="nc" id="L942">            completionKey = new TxnCompletionKey(txnId, OperationType.READ_ENTRY);</span>

            // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L945">            BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L946">                    .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L947">                    .setOperation(OperationType.READ_ENTRY)</span>
<span class="nc" id="L948">                    .setTxnId(txnId);</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">            if (((short) flags &amp; BookieProtocol.FLAG_HIGH_PRIORITY) == BookieProtocol.FLAG_HIGH_PRIORITY) {</span>
<span class="nc" id="L950">                headerBuilder.setPriority(DEFAULT_HIGH_PRIORITY_VALUE);</span>
            }

<span class="nc" id="L953">            ReadRequest.Builder readBuilder = ReadRequest.newBuilder()</span>
<span class="nc" id="L954">                    .setLedgerId(ledgerId)</span>
<span class="nc" id="L955">                    .setEntryId(entryId);</span>

<span class="nc bnc" id="L957" title="All 2 branches missed.">            if (null != previousLAC) {</span>
<span class="nc" id="L958">                readBuilder = readBuilder.setPreviousLAC(previousLAC);</span>
            }

<span class="nc bnc" id="L961" title="All 2 branches missed.">            if (null != timeOutInMillis) {</span>
                // Long poll requires previousLAC
<span class="nc bnc" id="L963" title="All 2 branches missed.">                if (null == previousLAC) {</span>
<span class="nc" id="L964">                    cb.readEntryComplete(BKException.Code.IncorrectParameterException,</span>
                        ledgerId, entryId, null, ctx);
<span class="nc" id="L966">                    return;</span>
                }
<span class="nc" id="L968">                readBuilder = readBuilder.setTimeOut(timeOutInMillis);</span>
            }

<span class="nc bnc" id="L971" title="All 2 branches missed.">            if (piggyBackEntry) {</span>
                // Long poll requires previousLAC
<span class="nc bnc" id="L973" title="All 2 branches missed.">                if (null == previousLAC) {</span>
<span class="nc" id="L974">                    cb.readEntryComplete(BKException.Code.IncorrectParameterException,</span>
                        ledgerId, entryId, null, ctx);
<span class="nc" id="L976">                    return;</span>
                }
<span class="nc" id="L978">                readBuilder = readBuilder.setFlag(ReadRequest.Flag.ENTRY_PIGGYBACK);</span>
            }

            // Only one flag can be set on the read requests
<span class="nc bnc" id="L982" title="All 2 branches missed.">            if (((short) flags &amp; BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING) {</span>
<span class="nc" id="L983">                readBuilder.setFlag(ReadRequest.Flag.FENCE_LEDGER);</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">                if (masterKey == null) {</span>
<span class="nc" id="L985">                    cb.readEntryComplete(BKException.Code.IncorrectParameterException,</span>
                                         ledgerId, entryId, null, ctx);
<span class="nc" id="L987">                    return;</span>
                }
<span class="nc" id="L989">                readBuilder.setMasterKey(ByteString.copyFrom(masterKey));</span>
            }

<span class="nc" id="L992">            request = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L993">                    .setHeader(headerBuilder)</span>
<span class="nc" id="L994">                    .setReadRequest(readBuilder)</span>
<span class="nc" id="L995">                    .build();</span>
        }

<span class="nc" id="L998">        ReadCompletion readCompletion = new ReadCompletion(completionKey, cb, ctx, ledgerId, entryId);</span>
<span class="nc" id="L999">        putCompletionKeyValue(completionKey, readCompletion);</span>

<span class="nc" id="L1001">        writeAndFlush(channel, completionKey, request, allowFastFail, null, null);</span>
<span class="nc" id="L1002">    }</span>

    public void batchReadEntries(final long ledgerId,
                            final long startEntryId,
                            final int maxCount,
                            final long maxSize,
                            BatchedReadEntryCallback cb,
                            Object ctx,
                            int flags,
                            byte[] masterKey,
                            boolean allowFastFail) {

<span class="nc" id="L1014">        batchReadEntriesInternal(ledgerId, startEntryId, maxCount, maxSize, null, null, false,</span>
                cb, ctx, (short) flags, masterKey, allowFastFail);
<span class="nc" id="L1016">    }</span>

    private void batchReadEntriesInternal(final long ledgerId,
                                     final long startEntryId,
                                     final int maxCount,
                                     final long maxSize,
                                     final Long previousLAC,
                                     final Long timeOutInMillis,
                                     final boolean piggyBackEntry,
                                     final BatchedReadEntryCallback cb,
                                     final Object ctx,
                                     int flags,
                                     byte[] masterKey,
                                     boolean allowFastFail) {
        Object request;
        CompletionKey completionKey;
<span class="nc" id="L1032">        final long txnId = getTxnId();</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (useV2WireProtocol) {</span>
<span class="nc" id="L1034">            request = BookieProtocol.BatchedReadRequest.create(BookieProtocol.CURRENT_PROTOCOL_VERSION,</span>
                    ledgerId, startEntryId, (short) flags, masterKey, txnId, maxCount, maxSize);
<span class="nc" id="L1036">            completionKey = new TxnCompletionKey(txnId, OperationType.BATCH_READ_ENTRY);</span>
        } else {
<span class="nc" id="L1038">            throw new UnsupportedOperationException(&quot;Unsupported batch read entry operation for v3 protocol.&quot;);</span>
        }
<span class="nc" id="L1040">        BatchedReadCompletion readCompletion = new BatchedReadCompletion(</span>
                completionKey, cb, ctx, ledgerId, startEntryId);
<span class="nc" id="L1042">        putCompletionKeyValue(completionKey, readCompletion);</span>

<span class="nc" id="L1044">        writeAndFlush(channel, completionKey, request, allowFastFail, null, null);</span>
<span class="nc" id="L1045">    }</span>

    public void getBookieInfo(final long requested, GetBookieInfoCallback cb, Object ctx) {
<span class="nc" id="L1048">        final long txnId = getTxnId();</span>
<span class="nc" id="L1049">        final CompletionKey completionKey = new TxnCompletionKey(txnId, OperationType.GET_BOOKIE_INFO);</span>
<span class="nc" id="L1050">        completionObjects.put(completionKey,</span>
                              new GetBookieInfoCompletion(
                                      completionKey, cb, ctx));

        // Build the request and calculate the total size to be included in the packet.
<span class="nc" id="L1055">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L1056">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L1057">                .setOperation(OperationType.GET_BOOKIE_INFO)</span>
<span class="nc" id="L1058">                .setTxnId(txnId);</span>

<span class="nc" id="L1060">        GetBookieInfoRequest.Builder getBookieInfoBuilder = GetBookieInfoRequest.newBuilder()</span>
<span class="nc" id="L1061">                .setRequested(requested);</span>

<span class="nc" id="L1063">        final Request getBookieInfoRequest = withRequestContext(Request.newBuilder())</span>
<span class="nc" id="L1064">                .setHeader(headerBuilder)</span>
<span class="nc" id="L1065">                .setGetBookieInfoRequest(getBookieInfoBuilder)</span>
<span class="nc" id="L1066">                .build();</span>

<span class="nc" id="L1068">        writeAndFlush(channel, completionKey, getBookieInfoRequest);</span>
<span class="nc" id="L1069">    }</span>

<span class="nc" id="L1071">    private static final BiPredicate&lt;CompletionKey, CompletionValue&gt; timeoutCheck = (key, value) -&gt; {</span>
<span class="nc" id="L1072">        return value.maybeTimeout();</span>
    };

    public void checkTimeoutOnPendingOperations() {
<span class="nc" id="L1076">        int timedOutOperations = completionObjects.removeIf(timeoutCheck);</span>

<span class="nc" id="L1078">        timedOutOperations += completionObjectsV2Conflicts.removeIf(timeoutCheck);</span>

<span class="nc bnc" id="L1080" title="All 2 branches missed.">        if (timedOutOperations &gt; 0) {</span>
<span class="nc" id="L1081">            LOG.info(&quot;Timed-out {} operations to channel {} for {}&quot;,</span>
<span class="nc" id="L1082">                     timedOutOperations, channel, bookieId);</span>
        }
<span class="nc" id="L1084">    }</span>

    /**
     * Disconnects the bookie client. It can be reused.
     */
    public void disconnect() {
<span class="nc" id="L1090">        disconnect(true);</span>
<span class="nc" id="L1091">    }</span>

    public void disconnect(boolean wait) {
<span class="nc" id="L1094">        LOG.info(&quot;Disconnecting the per channel bookie client for {}&quot;, bookieId);</span>
<span class="nc" id="L1095">        closeInternal(false, wait);</span>
<span class="nc" id="L1096">    }</span>

    /**
     * Closes the bookie client permanently. It cannot be reused.
     */
    public void close() {
<span class="nc" id="L1102">        close(true);</span>
<span class="nc" id="L1103">    }</span>

    public void close(boolean wait) {
<span class="nc" id="L1106">        LOG.info(&quot;Closing the per channel bookie client for {}&quot;, bookieId);</span>
<span class="nc" id="L1107">        closeLock.writeLock().lock();</span>
        try {
<span class="nc bnc" id="L1109" title="All 2 branches missed.">            if (ConnectionState.CLOSED == state) {</span>
<span class="nc" id="L1110">                return;</span>
            }
<span class="nc" id="L1112">            state = ConnectionState.CLOSED;</span>
<span class="nc" id="L1113">            errorOutOutstandingEntries(BKException.Code.ClientClosedException);</span>
        } finally {
<span class="nc" id="L1115">            closeLock.writeLock().unlock();</span>
        }

<span class="nc bnc" id="L1118" title="All 4 branches missed.">        if (channel != null &amp;&amp; channel.pipeline().get(SslHandler.class) != null) {</span>
<span class="nc" id="L1119">            activeTlsChannelCounter.dec();</span>
        } else {
<span class="nc" id="L1121">            activeNonTlsChannelCounter.dec();</span>
        }

<span class="nc" id="L1124">        closeInternal(true, wait);</span>
<span class="nc" id="L1125">    }</span>

    private void closeInternal(boolean permanent, boolean wait) {
<span class="nc" id="L1128">        Channel toClose = null;</span>
<span class="nc" id="L1129">        synchronized (this) {</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">            if (permanent) {</span>
<span class="nc" id="L1131">                state = ConnectionState.CLOSED;</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">            } else if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L1133">                state = ConnectionState.DISCONNECTED;</span>
            }
<span class="nc" id="L1135">            toClose = channel;</span>
<span class="nc" id="L1136">            channel = null;</span>
<span class="nc" id="L1137">            makeWritable();</span>
<span class="nc" id="L1138">        }</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">        if (toClose != null) {</span>
<span class="nc" id="L1140">            ChannelFuture cf = closeChannel(toClose);</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">            if (wait) {</span>
<span class="nc" id="L1142">                cf.awaitUninterruptibly();</span>
            }
        }
<span class="nc" id="L1145">    }</span>

    private ChannelFuture closeChannel(Channel c) {
<span class="nc bnc" id="L1148" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1149">            LOG.debug(&quot;Closing channel {}&quot;, c);</span>
        }
<span class="nc" id="L1151">        return c.close().addListener(x -&gt; makeWritable());</span>
    }

    @Override
    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
<span class="nc" id="L1156">        final Channel c = channel;</span>
<span class="nc bnc" id="L1157" title="All 4 branches missed.">        if (c == null || c.isWritable()) {</span>
<span class="nc" id="L1158">            makeWritable();</span>
        }
<span class="nc" id="L1160">        super.channelWritabilityChanged(ctx);</span>
<span class="nc" id="L1161">    }</span>

    private void writeAndFlush(final Channel channel,
                               final CompletionKey key,
                               final Object request) {
<span class="nc" id="L1166">        writeAndFlush(channel, key, request, false, null, null);</span>
<span class="nc" id="L1167">    }</span>

    private void writeAndFlush(final Channel channel,
                           final CompletionKey key,
                           final Object request,
                               final boolean allowFastFail, final Runnable cleanupActionFailedBeforeWrite,
                               final Runnable cleanupActionAfterWrite) {
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        if (channel == null) {</span>
<span class="nc" id="L1175">            LOG.warn(&quot;Operation {} failed: channel == null&quot;, StringUtils.requestToString(request));</span>
<span class="nc" id="L1176">            errorOut(key);</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">            if (cleanupActionFailedBeforeWrite != null) {</span>
<span class="nc" id="L1178">                cleanupActionFailedBeforeWrite.run();</span>
            }
<span class="nc" id="L1180">            return;</span>
        }

<span class="nc" id="L1183">        final boolean isChannelWritable = channel.isWritable();</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">        if (isWritable != isChannelWritable) {</span>
            // isWritable is volatile so simple &quot;isWritable = channel.isWritable()&quot; would be slower
<span class="nc" id="L1186">            isWritable = isChannelWritable;</span>
        }

<span class="nc bnc" id="L1189" title="All 4 branches missed.">        if (allowFastFail &amp;&amp; !isWritable) {</span>
<span class="nc" id="L1190">            LOG.warn(&quot;Operation {} failed: TooManyRequestsException&quot;,</span>
<span class="nc" id="L1191">                    StringUtils.requestToString(request));</span>

<span class="nc" id="L1193">            errorOut(key, BKException.Code.TooManyRequestsException);</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">            if (cleanupActionFailedBeforeWrite != null) {</span>
<span class="nc" id="L1195">                cleanupActionFailedBeforeWrite.run();</span>
            }
<span class="nc" id="L1197">            return;</span>
        }

        try {
<span class="nc" id="L1201">            final long startTime = MathUtils.nowInNano();</span>

<span class="nc" id="L1203">            ChannelPromise promise = channel.newPromise().addListener(future -&gt; {</span>
                try {
<span class="nc bnc" id="L1205" title="All 2 branches missed.">                    if (future.isSuccess()) {</span>
<span class="nc" id="L1206">                        nettyOpLogger.registerSuccessfulEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L1207">                        CompletionValue completion = completionObjects.get(key);</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                        if (completion != null) {</span>
<span class="nc" id="L1209">                            completion.setOutstanding();</span>
                        }
<span class="nc" id="L1211">                    } else {</span>
<span class="nc" id="L1212">                        nettyOpLogger.registerFailedEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L1213">                        errorOut(key);</span>
                    }
                } finally {
<span class="nc bnc" id="L1216" title="All 2 branches missed.">                    if (cleanupActionAfterWrite != null) {</span>
<span class="nc" id="L1217">                        cleanupActionAfterWrite.run();</span>
                    }
                }
<span class="nc" id="L1220">            });</span>
<span class="nc" id="L1221">            channel.writeAndFlush(request, promise);</span>
<span class="nc" id="L1222">        } catch (Throwable e) {</span>
<span class="nc" id="L1223">            LOG.warn(&quot;Operation {} failed&quot;, StringUtils.requestToString(request), e);</span>
<span class="nc" id="L1224">            errorOut(key);</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">            if (cleanupActionFailedBeforeWrite != null) {</span>
<span class="nc" id="L1226">                cleanupActionFailedBeforeWrite.run();</span>
            }
<span class="nc" id="L1228">        }</span>
<span class="nc" id="L1229">    }</span>

    void errorOut(final CompletionKey key) {
<span class="nc bnc" id="L1232" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1233">            LOG.debug(&quot;Removing completion key: {}&quot;, key);</span>
        }
<span class="nc" id="L1235">        CompletionValue completion = completionObjects.remove(key);</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">        if (completion != null) {</span>
<span class="nc" id="L1237">            completion.errorOut();</span>
        } else {
            // If there's no completion object here, try in the multimap
<span class="nc" id="L1240">            completionObjectsV2Conflicts.removeAny(key).ifPresent(c -&gt; c.errorOut());</span>
        }
<span class="nc" id="L1242">    }</span>

    void errorOut(final CompletionKey key, final int rc) {
<span class="nc bnc" id="L1245" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1246">            LOG.debug(&quot;Removing completion key: {}&quot;, key);</span>
        }
<span class="nc" id="L1248">        CompletionValue completion = completionObjects.remove(key);</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">        if (completion != null) {</span>
<span class="nc" id="L1250">            completion.errorOut(rc);</span>
        } else {
            // If there's no completion object here, try in the multimap
<span class="nc" id="L1253">            completionObjectsV2Conflicts.removeAny(key).ifPresent(c -&gt; c.errorOut(rc));</span>
        }
<span class="nc" id="L1255">    }</span>

    /**
     * Errors out pending ops from per channel bookie client. As the channel
     * is being closed, all the operations waiting on the connection
     * will be sent to completion with error.
     */
    void errorOutPendingOps(int rc) {
        Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;
<span class="nc" id="L1264">        synchronized (this) {</span>
<span class="nc" id="L1265">            oldPendingOps = pendingOps;</span>
<span class="nc" id="L1266">            pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L1267">        }</span>

<span class="nc bnc" id="L1269" title="All 2 branches missed.">        for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="nc" id="L1270">            pendingOp.operationComplete(rc, PerChannelBookieClient.this);</span>
<span class="nc" id="L1271">        }</span>
<span class="nc" id="L1272">    }</span>

    /**
     * Errors out pending entries. We call this method from one thread to avoid
     * concurrent executions to QuorumOpMonitor (implements callbacks). It seems
     * simpler to call it from BookieHandle instead of calling directly from
     * here.
     */

    void errorOutOutstandingEntries(int rc) {
<span class="nc" id="L1282">        Optional&lt;CompletionKey&gt; multikey = completionObjectsV2Conflicts.getAnyKey();</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">        while (multikey.isPresent()) {</span>
<span class="nc" id="L1284">            multikey.ifPresent(k -&gt; errorOut(k, rc));</span>
<span class="nc" id="L1285">            multikey = completionObjectsV2Conflicts.getAnyKey();</span>
        }
<span class="nc bnc" id="L1287" title="All 2 branches missed.">        for (CompletionKey key : completionObjects.keys()) {</span>
<span class="nc" id="L1288">            errorOut(key, rc);</span>
<span class="nc" id="L1289">        }</span>
<span class="nc" id="L1290">    }</span>

    void recordError() {
<span class="nc bnc" id="L1293" title="All 2 branches missed.">        if (pcbcPool != null) {</span>
<span class="nc" id="L1294">            pcbcPool.recordError();</span>
        }
<span class="nc" id="L1296">    }</span>

    /**
     * If our channel has disconnected, we just error out the pending entries.
     */
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
<span class="nc" id="L1303">        LOG.info(&quot;Disconnected from bookie channel {}&quot;, ctx.channel());</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        if (ctx.channel() != null) {</span>
<span class="nc" id="L1305">            closeChannel(ctx.channel());</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">            if (ctx.channel().pipeline().get(SslHandler.class) != null) {</span>
<span class="nc" id="L1307">                activeTlsChannelCounter.dec();</span>
            } else {
<span class="nc" id="L1309">                activeNonTlsChannelCounter.dec();</span>
            }
        }

<span class="nc" id="L1313">        errorOutOutstandingEntries(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1314">        errorOutPendingOps(BKException.Code.BookieHandleNotAvailableException);</span>

<span class="nc" id="L1316">        synchronized (this) {</span>
<span class="nc bnc" id="L1317" title="All 4 branches missed.">            if (this.channel == ctx.channel()</span>
                &amp;&amp; state != ConnectionState.CLOSED) {
<span class="nc" id="L1319">                state = ConnectionState.DISCONNECTED;</span>
<span class="nc" id="L1320">                channel = null;</span>
            }
<span class="nc" id="L1322">        }</span>

        // we don't want to reconnect right away. If someone sends a request to
        // this address, we will reconnect.
<span class="nc" id="L1326">    }</span>

    /**
     * Called by netty when an exception happens in one of the netty threads
     * (mostly due to what we do in the netty threads).
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
<span class="nc" id="L1334">        exceptionCounter.inc();</span>
<span class="nc bnc" id="L1335" title="All 4 branches missed.">        if (cause instanceof CorruptedFrameException || cause instanceof TooLongFrameException) {</span>
<span class="nc" id="L1336">            LOG.error(&quot;Corrupted frame received from bookie: {}&quot;, ctx.channel());</span>
<span class="nc" id="L1337">            ctx.close();</span>
<span class="nc" id="L1338">            return;</span>
        }

<span class="nc bnc" id="L1341" title="All 2 branches missed.">        if (cause instanceof AuthHandler.AuthenticationException) {</span>
<span class="nc" id="L1342">            LOG.error(&quot;Error authenticating connection&quot;, cause);</span>
<span class="nc" id="L1343">            errorOutOutstandingEntries(BKException.Code.UnauthorizedAccessException);</span>
<span class="nc" id="L1344">            Channel c = ctx.channel();</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L1346">                closeChannel(c);</span>
            }
<span class="nc" id="L1348">            return;</span>
        }

        // TLSv1.3 doesn't throw SSLHandshakeException for certificate issues
        // see https://stackoverflow.com/a/62465859 for details about the reason
        // therefore catch SSLException to also cover TLSv1.3
<span class="nc bnc" id="L1354" title="All 4 branches missed.">        if (cause instanceof DecoderException &amp;&amp; cause.getCause() instanceof SSLException) {</span>
<span class="nc" id="L1355">            LOG.error(&quot;TLS handshake failed&quot;, cause);</span>
<span class="nc" id="L1356">            errorOutPendingOps(BKException.Code.SecurityException);</span>
<span class="nc" id="L1357">            Channel c = ctx.channel();</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L1359">                closeChannel(c);</span>
            }
<span class="nc" id="L1361">            return;</span>
        }

<span class="nc bnc" id="L1364" title="All 2 branches missed.">        if (cause instanceof IOException) {</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">            if (cause instanceof NativeIoException) {</span>
                // Stack trace is not very interesting for native IO exceptio, the important part is in
                // the exception message
<span class="nc" id="L1368">                LOG.warn(&quot;Exception caught on:{} cause: {}&quot;, ctx.channel(), cause.getMessage());</span>
            } else {
<span class="nc" id="L1370">                LOG.warn(&quot;Exception caught on:{} cause:&quot;, ctx.channel(), cause);</span>
            }
<span class="nc" id="L1372">            ctx.close();</span>
<span class="nc" id="L1373">            return;</span>
        }

<span class="nc" id="L1376">        synchronized (this) {</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">            if (state == ConnectionState.CLOSED) {</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1379">                    LOG.debug(&quot;Unexpected exception caught by bookie client channel handler, &quot;</span>
                            + &quot;but the client is closed, so it isn't important&quot;, cause);
                }
            } else {
<span class="nc" id="L1383">                LOG.error(&quot;Unexpected exception caught by bookie client channel handler&quot;, cause);</span>
            }
<span class="nc" id="L1385">        }</span>

        // Since we are a library, cant terminate App here, can we?
<span class="nc" id="L1388">        ctx.close();</span>
<span class="nc" id="L1389">    }</span>

    /**
     * Called by netty when a message is received on a channel.
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {

<span class="nc bnc" id="L1397" title="All 2 branches missed.">        if (msg instanceof BookieProtocol.Response) {</span>
<span class="nc" id="L1398">            BookieProtocol.Response response = (BookieProtocol.Response) msg;</span>
<span class="nc" id="L1399">            readV2Response(response);</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">        } else if (msg instanceof Response) {</span>
<span class="nc" id="L1401">            Response response = (Response) msg;</span>
<span class="nc" id="L1402">            readV3Response(response);</span>
<span class="nc" id="L1403">        } else {</span>
<span class="nc" id="L1404">            ctx.fireChannelRead(msg);</span>
        }
<span class="nc" id="L1406">    }</span>

    private void readV2Response(final BookieProtocol.Response response) {
<span class="nc" id="L1409">        OperationType operationType = getOperationType(response.getOpCode());</span>
<span class="nc" id="L1410">        StatusCode status = getStatusCodeFromErrorCode(response.errorCode);</span>

        CompletionKey key;
<span class="nc bnc" id="L1413" title="All 2 branches missed.">        if (OperationType.BATCH_READ_ENTRY == operationType) {</span>
<span class="nc" id="L1414">            key = new TxnCompletionKey(((BookieProtocol.BatchedReadResponse) response).getRequestId(), operationType);</span>
        } else {
<span class="nc" id="L1416">            key = acquireV2Key(response.ledgerId, response.entryId, operationType);</span>
        }
<span class="nc" id="L1418">        CompletionValue completionValue = getCompletionValue(key);</span>
<span class="nc" id="L1419">        key.release();</span>

<span class="nc bnc" id="L1421" title="All 2 branches missed.">        if (null == completionValue) {</span>
            // Unexpected response, so log it. The txnId should have been present.
<span class="nc bnc" id="L1423" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1424">                LOG.debug(&quot;Unexpected response received from bookie : &quot; + bookieId + &quot; for type : &quot; + operationType</span>
                        + &quot; and ledger:entry : &quot; + response.ledgerId + &quot;:&quot; + response.entryId);
            }
<span class="nc" id="L1427">            response.release();</span>
        } else {
<span class="nc" id="L1429">            long orderingKey = completionValue.ledgerId;</span>
<span class="nc" id="L1430">            executor.executeOrdered(orderingKey,</span>
<span class="nc" id="L1431">                    ReadV2ResponseCallback.create(completionValue, response.ledgerId, response.entryId,</span>
                                                  status, response));
        }
<span class="nc" id="L1434">    }</span>

    private static class ReadV2ResponseCallback implements Runnable {
        CompletionValue completionValue;
        long ledgerId;
        long entryId;
        StatusCode status;
        BookieProtocol.Response response;

        static ReadV2ResponseCallback create(CompletionValue completionValue, long ledgerId, long entryId,
                                             StatusCode status, BookieProtocol.Response response) {
<span class="nc" id="L1445">            ReadV2ResponseCallback callback = RECYCLER.get();</span>
<span class="nc" id="L1446">            callback.completionValue = completionValue;</span>
<span class="nc" id="L1447">            callback.ledgerId = ledgerId;</span>
<span class="nc" id="L1448">            callback.entryId = entryId;</span>
<span class="nc" id="L1449">            callback.status = status;</span>
<span class="nc" id="L1450">            callback.response = response;</span>
<span class="nc" id="L1451">            return callback;</span>
        }

        @Override
        public void run() {
<span class="nc" id="L1456">            completionValue.handleV2Response(ledgerId, entryId, status, response);</span>
<span class="nc" id="L1457">            response.release();</span>
<span class="nc" id="L1458">            response.recycle();</span>
<span class="nc" id="L1459">            recycle();</span>
<span class="nc" id="L1460">        }</span>

        void recycle() {
<span class="nc" id="L1463">            completionValue = null;</span>
<span class="nc" id="L1464">            ledgerId = -1;</span>
<span class="nc" id="L1465">            entryId = -1;</span>
<span class="nc" id="L1466">            status = null;</span>
<span class="nc" id="L1467">            response = null;</span>
<span class="nc" id="L1468">            recyclerHandle.recycle(this);</span>
<span class="nc" id="L1469">        }</span>

        private final Handle&lt;ReadV2ResponseCallback&gt; recyclerHandle;

<span class="nc" id="L1473">        private ReadV2ResponseCallback(Handle&lt;ReadV2ResponseCallback&gt; recyclerHandle) {</span>
<span class="nc" id="L1474">            this.recyclerHandle = recyclerHandle;</span>
<span class="nc" id="L1475">        }</span>

<span class="nc" id="L1477">        private static final Recycler&lt;ReadV2ResponseCallback&gt; RECYCLER = new Recycler&lt;ReadV2ResponseCallback&gt;() {</span>
            @Override
            protected ReadV2ResponseCallback newObject(Handle&lt;ReadV2ResponseCallback&gt; handle) {
<span class="nc" id="L1480">                return new ReadV2ResponseCallback(handle);</span>
            }
        };
    }

    private static OperationType getOperationType(byte opCode) {
<span class="nc bnc" id="L1486" title="All 8 branches missed.">        switch (opCode) {</span>
            case BookieProtocol.ADDENTRY:
<span class="nc" id="L1488">                return  OperationType.ADD_ENTRY;</span>
            case BookieProtocol.READENTRY:
<span class="nc" id="L1490">                return OperationType.READ_ENTRY;</span>
            case BookieProtocol.AUTH:
<span class="nc" id="L1492">                return OperationType.AUTH;</span>
            case BookieProtocol.READ_LAC:
<span class="nc" id="L1494">                return OperationType.READ_LAC;</span>
            case BookieProtocol.WRITE_LAC:
<span class="nc" id="L1496">                return OperationType.WRITE_LAC;</span>
            case BookieProtocol.GET_BOOKIE_INFO:
<span class="nc" id="L1498">                return OperationType.GET_BOOKIE_INFO;</span>
            case BookieProtocol.BATCH_READ_ENTRY:
<span class="nc" id="L1500">                return OperationType.BATCH_READ_ENTRY;</span>
            default:
<span class="nc" id="L1502">                throw new IllegalArgumentException(&quot;Invalid operation type &quot; + opCode);</span>
        }
    }

    private static StatusCode getStatusCodeFromErrorCode(int errorCode) {
<span class="nc bnc" id="L1507" title="All 11 branches missed.">        switch (errorCode) {</span>
            case BookieProtocol.EOK:
<span class="nc" id="L1509">                return StatusCode.EOK;</span>
            case BookieProtocol.ENOLEDGER:
<span class="nc" id="L1511">                return StatusCode.ENOLEDGER;</span>
            case BookieProtocol.ENOENTRY:
<span class="nc" id="L1513">                return StatusCode.ENOENTRY;</span>
            case BookieProtocol.EBADREQ:
<span class="nc" id="L1515">                return StatusCode.EBADREQ;</span>
            case BookieProtocol.EIO:
<span class="nc" id="L1517">                return StatusCode.EIO;</span>
            case BookieProtocol.EUA:
<span class="nc" id="L1519">                return StatusCode.EUA;</span>
            case BookieProtocol.EBADVERSION:
<span class="nc" id="L1521">                return StatusCode.EBADVERSION;</span>
            case BookieProtocol.EFENCED:
<span class="nc" id="L1523">                return StatusCode.EFENCED;</span>
            case BookieProtocol.EREADONLY:
<span class="nc" id="L1525">                return StatusCode.EREADONLY;</span>
            case BookieProtocol.ETOOMANYREQUESTS:
<span class="nc" id="L1527">                return StatusCode.ETOOMANYREQUESTS;</span>
            default:
<span class="nc" id="L1529">                throw new IllegalArgumentException(&quot;Invalid error code: &quot; + errorCode);</span>
        }
    }

    private void readV3Response(final Response response) {
<span class="nc" id="L1534">        final BKPacketHeader header = response.getHeader();</span>

<span class="nc" id="L1536">        final CompletionKey key = newCompletionKey(header.getTxnId(), header.getOperation());</span>
<span class="nc" id="L1537">        final CompletionValue completionValue = completionObjects.get(key);</span>

<span class="nc bnc" id="L1539" title="All 2 branches missed.">        if (null == completionValue) {</span>
            // Unexpected response, so log it. The txnId should have been present.
<span class="nc bnc" id="L1541" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1542">                LOG.debug(&quot;Unexpected response received from bookie : &quot; + bookieId + &quot; for type : &quot;</span>
<span class="nc" id="L1543">                        + header.getOperation() + &quot; and txnId : &quot; + header.getTxnId());</span>
            }
        } else {
<span class="nc" id="L1546">            long orderingKey = completionValue.ledgerId;</span>
<span class="nc" id="L1547">            executor.executeOrdered(orderingKey, new Runnable() {</span>
                @Override
                public void run() {
<span class="nc" id="L1550">                    completionValue.restoreMdcContext();</span>
<span class="nc" id="L1551">                    completionValue.handleV3Response(response);</span>
<span class="nc" id="L1552">                }</span>

                @Override
                public String toString() {
<span class="nc" id="L1556">                    return String.format(&quot;HandleResponse(Txn=%d, Type=%s, Entry=(%d, %d))&quot;,</span>
<span class="nc" id="L1557">                                         header.getTxnId(), header.getOperation(),</span>
<span class="nc" id="L1558">                                         completionValue.ledgerId, completionValue.entryId);</span>
                }
            });
        }

<span class="nc" id="L1563">        completionObjects.remove(key);</span>
<span class="nc" id="L1564">    }</span>

    void initTLSHandshake() {
        // create TLS handler
<span class="nc" id="L1568">        PerChannelBookieClient parentObj = PerChannelBookieClient.this;</span>
<span class="nc" id="L1569">        SocketAddress socketAddress = channel.remoteAddress();</span>
        InetSocketAddress address;
<span class="nc bnc" id="L1571" title="All 2 branches missed.">        if (socketAddress instanceof LocalAddress) {</span>
            // if it is a local address, it looks like this: local:hostname:port
<span class="nc" id="L1573">            String[] addr = socketAddress.toString().split(&quot;:&quot;);</span>
<span class="nc" id="L1574">            String hostname = addr[1];</span>
<span class="nc" id="L1575">            int port = Integer.parseInt(addr[2]);</span>
<span class="nc" id="L1576">            address = new InetSocketAddress(hostname, port);</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">        } else if (socketAddress instanceof InetSocketAddress) {</span>
<span class="nc" id="L1578">            address = (InetSocketAddress) socketAddress;</span>
        } else {
<span class="nc" id="L1580">            throw new RuntimeException(&quot;Unexpected socket address type&quot;);</span>
        }
<span class="nc" id="L1582">        LOG.info(&quot;Starting TLS handshake with {}:{}&quot;, address.getHostString(), address.getPort());</span>
<span class="nc" id="L1583">        SslHandler sslHandler = parentObj.shFactory.newTLSHandler(address.getHostName(), address.getPort());</span>
<span class="nc" id="L1584">        String sslHandlerName = parentObj.shFactory.getHandlerName();</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">        if (channel.pipeline().names().contains(CONSOLIDATION_HANDLER_NAME)) {</span>
<span class="nc" id="L1586">            channel.pipeline().addAfter(CONSOLIDATION_HANDLER_NAME, sslHandlerName, sslHandler);</span>
        } else {
            // local transport doesn't contain FlushConsolidationHandler
<span class="nc" id="L1589">            channel.pipeline().addFirst(sslHandlerName, sslHandler);</span>
        }
<span class="nc" id="L1591">        sslHandler.handshakeFuture().addListener(new GenericFutureListener&lt;Future&lt;Channel&gt;&gt;() {</span>
                @Override
                public void operationComplete(Future&lt;Channel&gt; future) throws Exception {
                    int rc;
                    Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;

<span class="nc" id="L1597">                    synchronized (PerChannelBookieClient.this) {</span>
<span class="nc bnc" id="L1598" title="All 4 branches missed.">                        if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTING) {</span>
<span class="nc" id="L1599">                            LOG.error(&quot;Connection state changed before TLS handshake completed {}/{}&quot;, bookieId, state);</span>
<span class="nc" id="L1600">                            rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L1601">                            closeChannel(channel);</span>
<span class="nc" id="L1602">                            channel = null;</span>
<span class="nc bnc" id="L1603" title="All 2 branches missed.">                            if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L1604">                                state = ConnectionState.DISCONNECTED;</span>
                            }
<span class="nc bnc" id="L1606" title="All 4 branches missed.">                        } else if (future.isSuccess() &amp;&amp; state == ConnectionState.START_TLS) {</span>
<span class="nc" id="L1607">                            rc = BKException.Code.OK;</span>
<span class="nc" id="L1608">                            LOG.info(&quot;Successfully connected to bookie using TLS: &quot; + bookieId);</span>

<span class="nc" id="L1610">                            state = ConnectionState.CONNECTED;</span>
<span class="nc" id="L1611">                            AuthHandler.ClientSideHandler authHandler = future.get().pipeline()</span>
<span class="nc" id="L1612">                                    .get(AuthHandler.ClientSideHandler.class);</span>
<span class="nc" id="L1613">                            authHandler.authProvider.onProtocolUpgrade();</span>
<span class="nc" id="L1614">                            activeTlsChannelCounter.inc();</span>
<span class="nc bnc" id="L1615" title="All 6 branches missed.">                        } else if (future.isSuccess()</span>
                                &amp;&amp; (state == ConnectionState.CLOSED || state == ConnectionState.DISCONNECTED)) {
<span class="nc" id="L1617">                            LOG.warn(&quot;Closed before TLS handshake completed, clean up: {}, current state {}&quot;,</span>
                                    channel, state);
<span class="nc" id="L1619">                            closeChannel(channel);</span>
<span class="nc" id="L1620">                            rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L1621">                            channel = null;</span>
<span class="nc bnc" id="L1622" title="All 4 branches missed.">                        } else if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1624">                                LOG.debug(&quot;Already connected with another channel({}), &quot;</span>
                                                + &quot;so close the new channel({})&quot;,
                                        channel, channel);
                            }
<span class="nc" id="L1628">                            closeChannel(channel);</span>
<span class="nc" id="L1629">                            return; // pendingOps should have been completed when other channel connected</span>
                        } else {
<span class="nc" id="L1631">                            LOG.error(&quot;TLS handshake failed with bookie: {}/{}, current state {} : &quot;,</span>
<span class="nc" id="L1632">                                    channel, bookieId, state, future.cause());</span>
<span class="nc" id="L1633">                            rc = BKException.Code.SecurityException;</span>
<span class="nc" id="L1634">                            closeChannel(channel);</span>
<span class="nc" id="L1635">                            channel = null;</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">                            if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L1637">                                state = ConnectionState.DISCONNECTED;</span>
                            }
<span class="nc" id="L1639">                            failedTlsHandshakeCounter.inc();</span>
                        }

                        // trick to not do operations under the lock, take the list
                        // of pending ops and assign it to a new variable, while
                        // emptying the pending ops by just assigning it to a new
                        // list
<span class="nc" id="L1646">                        oldPendingOps = pendingOps;</span>
<span class="nc" id="L1647">                        pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L1648">                    }</span>

<span class="nc" id="L1650">                    makeWritable();</span>

<span class="nc bnc" id="L1652" title="All 2 branches missed.">                    for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="nc" id="L1653">                        pendingOp.operationComplete(rc, PerChannelBookieClient.this);</span>
<span class="nc" id="L1654">                    }</span>
<span class="nc" id="L1655">                }</span>
            });
<span class="nc" id="L1657">    }</span>

    /**
     * Boiler-plate wrapper classes follow.
     *
     */

    // visible for testing
    abstract class CompletionValue {
        private final OpStatsLogger opLogger;
        private final OpStatsLogger timeoutOpLogger;
        private final String operationName;
        private final Map&lt;String, String&gt; mdcContextMap;
        protected Object ctx;
        protected long ledgerId;
        protected long entryId;
        protected long startTime;

        public CompletionValue(String operationName,
                               Object ctx,
                               long ledgerId, long entryId,
                               OpStatsLogger opLogger,
<span class="nc" id="L1679">                               OpStatsLogger timeoutOpLogger) {</span>
<span class="nc" id="L1680">            this.operationName = operationName;</span>
<span class="nc" id="L1681">            this.ctx = ctx;</span>
<span class="nc" id="L1682">            this.ledgerId = ledgerId;</span>
<span class="nc" id="L1683">            this.entryId = entryId;</span>
<span class="nc" id="L1684">            this.startTime = MathUtils.nowInNano();</span>
<span class="nc" id="L1685">            this.opLogger = opLogger;</span>
<span class="nc" id="L1686">            this.timeoutOpLogger = timeoutOpLogger;</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">            this.mdcContextMap = preserveMdcForTaskExecution ? MDC.getCopyOfContextMap() : null;</span>
<span class="nc" id="L1688">        }</span>

        private long latency() {
<span class="nc" id="L1691">            return MathUtils.elapsedNanos(startTime);</span>
        }

        void logOpResult(int rc) {
<span class="nc bnc" id="L1695" title="All 2 branches missed.">            if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L1696">                opLogger.registerFailedEvent(latency(), TimeUnit.NANOSECONDS);</span>
            } else {
<span class="nc" id="L1698">                opLogger.registerSuccessfulEvent(latency(), TimeUnit.NANOSECONDS);</span>
            }

<span class="nc bnc" id="L1701" title="All 2 branches missed.">            if (rc != BKException.Code.OK</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">                &amp;&amp; !expectedBkOperationErrors.contains(rc)) {</span>
<span class="nc" id="L1703">                recordError();</span>
            }
<span class="nc" id="L1705">        }</span>

        boolean maybeTimeout() {
<span class="nc bnc" id="L1708" title="All 2 branches missed.">            if (MathUtils.elapsedNanos(startTime) &gt;= readEntryTimeoutNanos) {</span>
<span class="nc" id="L1709">                timeout();</span>
<span class="nc" id="L1710">                return true;</span>
            } else {
<span class="nc" id="L1712">                return false;</span>
            }
        }

        void timeout() {
<span class="nc" id="L1717">            errorOut(BKException.Code.TimeoutException);</span>
<span class="nc" id="L1718">            timeoutOpLogger.registerSuccessfulEvent(latency(),</span>
                                                    TimeUnit.NANOSECONDS);
<span class="nc" id="L1720">        }</span>

        protected void logResponse(StatusCode status, Object... extraInfo) {
<span class="nc bnc" id="L1723" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1724">                LOG.debug(&quot;Got {} response from bookie:{} rc:{}, {}&quot;, operationName, bookieId, status,</span>
<span class="nc" id="L1725">                        Joiner.on(&quot;:&quot;).join(extraInfo));</span>
            }
<span class="nc" id="L1727">        }</span>

        protected int convertStatus(StatusCode status, int defaultStatus) {
            // convert to BKException code
<span class="nc" id="L1731">            int rcToRet = statusCodeToExceptionCode(status);</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">            if (rcToRet == BKException.Code.UNINITIALIZED) {</span>
<span class="nc" id="L1733">                LOG.error(&quot;{} for failed on bookie {} code {}&quot;,</span>
                          operationName, bookieId, status);
<span class="nc" id="L1735">                return defaultStatus;</span>
            } else {
<span class="nc" id="L1737">                return rcToRet;</span>
            }
        }

        public void restoreMdcContext() {
<span class="nc" id="L1742">            MdcUtils.restoreContext(mdcContextMap);</span>
<span class="nc" id="L1743">        }</span>

        public abstract void errorOut();
        public abstract void errorOut(int rc);
        public void setOutstanding() {
            // no-op
<span class="nc" id="L1749">        }</span>

        protected void errorOutAndRunCallback(final Runnable callback) {
<span class="nc" id="L1752">            executor.executeOrdered(ledgerId, () -&gt; {</span>
<span class="nc" id="L1753">                String bAddress = &quot;null&quot;;</span>
<span class="nc" id="L1754">                Channel c = channel;</span>
<span class="nc bnc" id="L1755" title="All 4 branches missed.">                if (c != null &amp;&amp; c.remoteAddress() != null) {</span>
<span class="nc" id="L1756">                    bAddress = c.remoteAddress().toString();</span>
                }
<span class="nc bnc" id="L1758" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1759">                    LOG.debug(&quot;Could not write {} request to bookie {} for ledger {}, entry {}&quot;,</span>
                            operationName, bAddress,
<span class="nc" id="L1761">                            ledgerId, entryId);</span>
                }
<span class="nc" id="L1763">                callback.run();</span>
<span class="nc" id="L1764">            });</span>
<span class="nc" id="L1765">        }</span>

        public void handleV2Response(
                long ledgerId, long entryId, StatusCode status,
                BookieProtocol.Response response) {
<span class="nc" id="L1770">            LOG.warn(&quot;Unhandled V2 response {}&quot;, response);</span>
<span class="nc" id="L1771">        }</span>

        public abstract void handleV3Response(
                Response response);
    }

    // visible for testing
    class WriteLacCompletion extends CompletionValue {
        final WriteLacCallback cb;

        public WriteLacCompletion(final CompletionKey key,
                                  final WriteLacCallback originalCallback,
                                  final Object originalCtx,
<span class="nc" id="L1784">                                  final long ledgerId) {</span>
<span class="nc" id="L1785">            super(&quot;WriteLAC&quot;,</span>
                  originalCtx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED,
<span class="nc" id="L1787">                  writeLacOpLogger, writeLacTimeoutOpLogger);</span>
<span class="nc" id="L1788">            this.cb = new WriteLacCallback() {</span>
                    @Override
                    public void writeLacComplete(int rc, long ledgerId,
                                                 BookieId addr,
                                                 Object ctx) {
<span class="nc" id="L1793">                        logOpResult(rc);</span>
<span class="nc" id="L1794">                        originalCallback.writeLacComplete(rc, ledgerId,</span>
                                                          addr, originalCtx);
<span class="nc" id="L1796">                        key.release();</span>
<span class="nc" id="L1797">                    }</span>
                };
<span class="nc" id="L1799">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1803">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1804">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1808">            errorOutAndRunCallback(</span>
<span class="nc" id="L1809">                    () -&gt; cb.writeLacComplete(rc, ledgerId, bookieId, ctx));</span>
<span class="nc" id="L1810">        }</span>

        @Override
        public void handleV3Response(Response response) {
<span class="nc" id="L1814">            WriteLacResponse writeLacResponse = response.getWriteLacResponse();</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L1816">                ? writeLacResponse.getStatus() : response.getStatus();</span>
<span class="nc" id="L1817">            long ledgerId = writeLacResponse.getLedgerId();</span>

<span class="nc bnc" id="L1819" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1820">                logResponse(status, &quot;ledger&quot;, ledgerId);</span>
            }
<span class="nc" id="L1822">            int rc = convertStatus(status, BKException.Code.WriteException);</span>
<span class="nc" id="L1823">            cb.writeLacComplete(rc, ledgerId, bookieId, ctx);</span>
<span class="nc" id="L1824">        }</span>
    }

    class ForceLedgerCompletion extends CompletionValue {
        final ForceLedgerCallback cb;

        public ForceLedgerCompletion(final CompletionKey key,
                                  final ForceLedgerCallback originalCallback,
                                  final Object originalCtx,
<span class="nc" id="L1833">                                  final long ledgerId) {</span>
<span class="nc" id="L1834">            super(&quot;ForceLedger&quot;,</span>
                  originalCtx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED,
<span class="nc" id="L1836">                  forceLedgerOpLogger, forceLedgerTimeoutOpLogger);</span>
<span class="nc" id="L1837">            this.cb = new ForceLedgerCallback() {</span>
                    @Override
                    public void forceLedgerComplete(int rc, long ledgerId,
                                                 BookieId addr,
                                                 Object ctx) {
<span class="nc" id="L1842">                        logOpResult(rc);</span>
<span class="nc" id="L1843">                        originalCallback.forceLedgerComplete(rc, ledgerId,</span>
                                                          addr, originalCtx);
<span class="nc" id="L1845">                        key.release();</span>
<span class="nc" id="L1846">                    }</span>
                };
<span class="nc" id="L1848">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1852">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1853">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1857">            errorOutAndRunCallback(</span>
<span class="nc" id="L1858">                    () -&gt; cb.forceLedgerComplete(rc, ledgerId, bookieId, ctx));</span>
<span class="nc" id="L1859">        }</span>

        @Override
        public void handleV3Response(Response response) {
<span class="nc" id="L1863">            ForceLedgerResponse forceLedgerResponse = response.getForceLedgerResponse();</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L1865">                ? forceLedgerResponse.getStatus() : response.getStatus();</span>
<span class="nc" id="L1866">            long ledgerId = forceLedgerResponse.getLedgerId();</span>

<span class="nc bnc" id="L1868" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1869">                logResponse(status, &quot;ledger&quot;, ledgerId);</span>
            }
<span class="nc" id="L1871">            int rc = convertStatus(status, BKException.Code.WriteException);</span>
<span class="nc" id="L1872">            cb.forceLedgerComplete(rc, ledgerId, bookieId, ctx);</span>
<span class="nc" id="L1873">        }</span>
    }

    // visible for testing
    class ReadLacCompletion extends CompletionValue {
        final ReadLacCallback cb;

        public ReadLacCompletion(final CompletionKey key,
                                 ReadLacCallback originalCallback,
<span class="nc" id="L1882">                                 final Object ctx, final long ledgerId) {</span>
<span class="nc" id="L1883">            super(&quot;ReadLAC&quot;, ctx, ledgerId, BookieProtocol.LAST_ADD_CONFIRMED,</span>
<span class="nc" id="L1884">                  readLacOpLogger, readLacTimeoutOpLogger);</span>
<span class="nc" id="L1885">            this.cb = new ReadLacCallback() {</span>
                    @Override
                    public void readLacComplete(int rc, long ledgerId,
                                                ByteBuf lacBuffer,
                                                ByteBuf lastEntryBuffer,
                                                Object ctx) {
<span class="nc" id="L1891">                        logOpResult(rc);</span>
<span class="nc" id="L1892">                        originalCallback.readLacComplete(</span>
                                rc, ledgerId, lacBuffer, lastEntryBuffer, ctx);
<span class="nc" id="L1894">                        key.release();</span>
<span class="nc" id="L1895">                    }</span>
                };
<span class="nc" id="L1897">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1901">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1902">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1906">            errorOutAndRunCallback(</span>
<span class="nc" id="L1907">                    () -&gt; cb.readLacComplete(rc, ledgerId, null, null, ctx));</span>
<span class="nc" id="L1908">        }</span>

        @Override
        public void handleV3Response(Response response) {
<span class="nc" id="L1912">            ReadLacResponse readLacResponse = response.getReadLacResponse();</span>
<span class="nc" id="L1913">            ByteBuf lacBuffer = Unpooled.EMPTY_BUFFER;</span>
<span class="nc" id="L1914">            ByteBuf lastEntryBuffer = Unpooled.EMPTY_BUFFER;</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L1916">                ? readLacResponse.getStatus() : response.getStatus();</span>

<span class="nc bnc" id="L1918" title="All 2 branches missed.">            if (readLacResponse.hasLacBody()) {</span>
<span class="nc" id="L1919">                lacBuffer = Unpooled.wrappedBuffer(readLacResponse.getLacBody().asReadOnlyByteBuffer());</span>
            }

<span class="nc bnc" id="L1922" title="All 2 branches missed.">            if (readLacResponse.hasLastEntryBody()) {</span>
<span class="nc" id="L1923">                lastEntryBuffer = Unpooled.wrappedBuffer(readLacResponse.getLastEntryBody().asReadOnlyByteBuffer());</span>
            }

<span class="nc bnc" id="L1926" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1927">                logResponse(status, &quot;ledgerId&quot;, ledgerId);</span>
            }

<span class="nc" id="L1930">            int rc = convertStatus(status, BKException.Code.ReadException);</span>
<span class="nc" id="L1931">            cb.readLacComplete(rc, ledgerId, lacBuffer.slice(),</span>
<span class="nc" id="L1932">                               lastEntryBuffer.slice(), ctx);</span>
<span class="nc" id="L1933">        }</span>
    }

    // visible for testing
    class ReadCompletion extends CompletionValue {
        final ReadEntryCallback cb;

        public ReadCompletion(final CompletionKey key,
                              final ReadEntryCallback originalCallback,
                              final Object originalCtx,
<span class="nc" id="L1943">                              long ledgerId, final long entryId) {</span>
<span class="nc" id="L1944">            super(&quot;Read&quot;, originalCtx, ledgerId, entryId,</span>
<span class="nc" id="L1945">                  readEntryOpLogger, readTimeoutOpLogger);</span>

<span class="nc" id="L1947">            this.cb = new ReadEntryCallback() {</span>
                    @Override
                    public void readEntryComplete(int rc, long ledgerId,
                                                  long entryId, ByteBuf buffer,
                                                  Object ctx) {
<span class="nc" id="L1952">                        logOpResult(rc);</span>
<span class="nc" id="L1953">                        originalCallback.readEntryComplete(rc,</span>
                                                           ledgerId, entryId,
                                                           buffer, originalCtx);
<span class="nc" id="L1956">                        key.release();</span>
<span class="nc" id="L1957">                    }</span>
                };
<span class="nc" id="L1959">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L1963">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L1964">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L1968">            errorOutAndRunCallback(</span>
<span class="nc" id="L1969">                    () -&gt; cb.readEntryComplete(rc, ledgerId,</span>
                                               entryId, null, ctx));
<span class="nc" id="L1971">        }</span>

        @Override
        public void setOutstanding() {
<span class="nc" id="L1975">            readEntryOutstanding.inc();</span>
<span class="nc" id="L1976">        }</span>

        @Override
        public void handleV2Response(long ledgerId, long entryId,
                                     StatusCode status,
                                     BookieProtocol.Response response) {
<span class="nc" id="L1982">            readEntryOutstanding.dec();</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">            if (!(response instanceof BookieProtocol.ReadResponse)) {</span>
<span class="nc" id="L1984">                return;</span>
            }
<span class="nc" id="L1986">            BookieProtocol.ReadResponse readResponse = (BookieProtocol.ReadResponse) response;</span>
<span class="nc" id="L1987">            handleReadResponse(ledgerId, entryId, status, readResponse.getData(),</span>
                               INVALID_ENTRY_ID, -1L);
<span class="nc" id="L1989">        }</span>

        @Override
        public void handleV3Response(Response response) {
<span class="nc" id="L1993">            readEntryOutstanding.dec();</span>
<span class="nc" id="L1994">            ReadResponse readResponse = response.getReadResponse();</span>
<span class="nc bnc" id="L1995" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L1996">                ? readResponse.getStatus() : response.getStatus();</span>
<span class="nc" id="L1997">            ByteBuf buffer = Unpooled.EMPTY_BUFFER;</span>
<span class="nc bnc" id="L1998" title="All 2 branches missed.">            if (readResponse.hasBody()) {</span>
<span class="nc" id="L1999">                buffer = Unpooled.wrappedBuffer(readResponse.getBody().asReadOnlyByteBuffer());</span>
            }
<span class="nc" id="L2001">            long maxLAC = INVALID_ENTRY_ID;</span>
<span class="nc bnc" id="L2002" title="All 2 branches missed.">            if (readResponse.hasMaxLAC()) {</span>
<span class="nc" id="L2003">                maxLAC = readResponse.getMaxLAC();</span>
            }
<span class="nc" id="L2005">            long lacUpdateTimestamp = -1L;</span>
<span class="nc bnc" id="L2006" title="All 2 branches missed.">            if (readResponse.hasLacUpdateTimestamp()) {</span>
<span class="nc" id="L2007">                lacUpdateTimestamp = readResponse.getLacUpdateTimestamp();</span>
            }
<span class="nc" id="L2009">            handleReadResponse(readResponse.getLedgerId(),</span>
<span class="nc" id="L2010">                               readResponse.getEntryId(),</span>
                               status, buffer, maxLAC, lacUpdateTimestamp);
<span class="nc" id="L2012">            ReferenceCountUtil.release(</span>
                    buffer); // meaningless using unpooled, but client may expect to hold the last reference
<span class="nc" id="L2014">        }</span>

        private void handleReadResponse(long ledgerId,
                                        long entryId,
                                        StatusCode status,
                                        ByteBuf buffer,
                                        long maxLAC, // max known lac piggy-back from bookies
                                        long lacUpdateTimestamp) { // the timestamp when the lac is updated.
<span class="nc" id="L2022">            int readableBytes = buffer.readableBytes();</span>
<span class="nc bnc" id="L2023" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2024">                logResponse(status, &quot;ledger&quot;, ledgerId, &quot;entry&quot;, entryId, &quot;entryLength&quot;, readableBytes);</span>
            }

<span class="nc" id="L2027">            int rc = convertStatus(status, BKException.Code.ReadException);</span>

<span class="nc bnc" id="L2029" title="All 4 branches missed.">            if (maxLAC &gt; INVALID_ENTRY_ID &amp;&amp; (ctx instanceof ReadEntryCallbackCtx)) {</span>
<span class="nc" id="L2030">                ((ReadEntryCallbackCtx) ctx).setLastAddConfirmed(maxLAC);</span>
            }
<span class="nc bnc" id="L2032" title="All 4 branches missed.">            if (lacUpdateTimestamp &gt; -1L &amp;&amp; (ctx instanceof ReadLastConfirmedAndEntryContext)) {</span>
<span class="nc" id="L2033">                ((ReadLastConfirmedAndEntryContext) ctx).setLacUpdateTimestamp(lacUpdateTimestamp);</span>
            }
<span class="nc" id="L2035">            cb.readEntryComplete(rc, ledgerId, entryId, buffer.slice(), ctx);</span>
<span class="nc" id="L2036">        }</span>
    }

    class BatchedReadCompletion extends CompletionValue {

        final BatchedReadEntryCallback cb;

        public BatchedReadCompletion(final CompletionKey key,
                                     final BatchedReadEntryCallback originalCallback,
                                     final Object originalCtx,
<span class="nc" id="L2046">                                     long ledgerId, final long entryId) {</span>
<span class="nc" id="L2047">            super(&quot;BatchedRead&quot;, originalCtx, ledgerId, entryId,</span>
<span class="nc" id="L2048">                    readEntryOpLogger, readTimeoutOpLogger);</span>
<span class="nc" id="L2049">            this.cb = new BatchedReadEntryCallback() {</span>

                @Override
                public void readEntriesComplete(int rc,
                                                long ledgerId,
                                                long startEntryId,
                                                ByteBufList bufList,
                                                Object ctx) {
<span class="nc" id="L2057">                    logOpResult(rc);</span>
<span class="nc" id="L2058">                    originalCallback.readEntriesComplete(rc,</span>
                            ledgerId, entryId,
                            bufList, originalCtx);
<span class="nc" id="L2061">                    key.release();</span>
<span class="nc" id="L2062">                }</span>
            };
<span class="nc" id="L2064">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L2068">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L2069">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L2073">            errorOutAndRunCallback(</span>
<span class="nc" id="L2074">                    () -&gt; cb.readEntriesComplete(rc, ledgerId,</span>
                            entryId, null, ctx));
<span class="nc" id="L2076">        }</span>

        @Override
        public void handleV2Response(long ledgerId,
                                     long entryId,
                                     StatusCode status,
                                     BookieProtocol.Response response) {

<span class="nc" id="L2084">            readEntryOutstanding.dec();</span>
<span class="nc bnc" id="L2085" title="All 2 branches missed.">            if (!(response instanceof BookieProtocol.BatchedReadResponse)) {</span>
<span class="nc" id="L2086">                return;</span>
            }
<span class="nc" id="L2088">            BookieProtocol.BatchedReadResponse readResponse = (BookieProtocol.BatchedReadResponse) response;</span>
<span class="nc" id="L2089">            handleBatchedReadResponse(ledgerId, entryId, status, readResponse.getData(),</span>
                    INVALID_ENTRY_ID, -1L);
<span class="nc" id="L2091">        }</span>

        @Override
        public void handleV3Response(Response response) {
            // V3 protocol haven't supported batched read yet.
<span class="nc" id="L2096">        }</span>

        private void handleBatchedReadResponse(long ledgerId,
                                        long entryId,
                                        StatusCode status,
                                        ByteBufList buffers,
                                        long maxLAC, // max known lac piggy-back from bookies
                                        long lacUpdateTimestamp) { // the timestamp when the lac is updated.
<span class="nc" id="L2104">            int rc = convertStatus(status, BKException.Code.ReadException);</span>

<span class="nc bnc" id="L2106" title="All 4 branches missed.">            if (maxLAC &gt; INVALID_ENTRY_ID &amp;&amp; (ctx instanceof ReadEntryCallbackCtx)) {</span>
<span class="nc" id="L2107">                ((ReadEntryCallbackCtx) ctx).setLastAddConfirmed(maxLAC);</span>
            }
<span class="nc bnc" id="L2109" title="All 4 branches missed.">            if (lacUpdateTimestamp &gt; -1L &amp;&amp; (ctx instanceof ReadLastConfirmedAndEntryContext)) {</span>
<span class="nc" id="L2110">                ((ReadLastConfirmedAndEntryContext) ctx).setLacUpdateTimestamp(lacUpdateTimestamp);</span>
            }
<span class="nc" id="L2112">            cb.readEntriesComplete(rc, ledgerId, entryId, buffers, ctx);</span>
<span class="nc" id="L2113">        }</span>
    }

    class StartTLSCompletion extends CompletionValue {
        final StartTLSCallback cb;

<span class="nc" id="L2119">        public StartTLSCompletion(final CompletionKey key) {</span>
<span class="nc" id="L2120">            super(&quot;StartTLS&quot;, null, -1, -1,</span>
<span class="nc" id="L2121">                  startTLSOpLogger, startTLSTimeoutOpLogger);</span>
<span class="nc" id="L2122">            this.cb = new StartTLSCallback() {</span>
                @Override
                public void startTLSComplete(int rc, Object ctx) {
<span class="nc" id="L2125">                    logOpResult(rc);</span>
<span class="nc" id="L2126">                    key.release();</span>
<span class="nc" id="L2127">                }</span>
            };
<span class="nc" id="L2129">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L2133">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L2134">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L2138">            failTLS(rc);</span>
<span class="nc" id="L2139">        }</span>

        @Override
        public void handleV3Response(Response response) {
<span class="nc" id="L2143">            StatusCode status = response.getStatus();</span>

<span class="nc bnc" id="L2145" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2146">                logResponse(status);</span>
            }

<span class="nc" id="L2149">            int rc = convertStatus(status, BKException.Code.SecurityException);</span>

            // Cancel START_TLS request timeout
<span class="nc" id="L2152">            cb.startTLSComplete(rc, null);</span>

<span class="nc bnc" id="L2154" title="All 2 branches missed.">            if (state != ConnectionState.START_TLS) {</span>
<span class="nc" id="L2155">                LOG.error(&quot;Connection state changed before TLS response received&quot;);</span>
<span class="nc" id="L2156">                failTLS(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">            } else if (status != StatusCode.EOK) {</span>
<span class="nc" id="L2158">                LOG.error(&quot;Client received error {} during TLS negotiation&quot;, status);</span>
<span class="nc" id="L2159">                failTLS(BKException.Code.SecurityException);</span>
            } else {
<span class="nc" id="L2161">                initTLSHandshake();</span>
            }
<span class="nc" id="L2163">        }</span>

    }

    // visible for testing
    class GetBookieInfoCompletion extends CompletionValue {
        final GetBookieInfoCallback cb;

        public GetBookieInfoCompletion(final CompletionKey key,
                                       final GetBookieInfoCallback origCallback,
<span class="nc" id="L2173">                                       final Object origCtx) {</span>
<span class="nc" id="L2174">            super(&quot;GetBookieInfo&quot;, origCtx, 0L, 0L,</span>
<span class="nc" id="L2175">                  getBookieInfoOpLogger, getBookieInfoTimeoutOpLogger);</span>
<span class="nc" id="L2176">            this.cb = new GetBookieInfoCallback() {</span>
                @Override
                public void getBookieInfoComplete(int rc, BookieInfo bInfo,
                                                  Object ctx) {
<span class="nc" id="L2180">                    logOpResult(rc);</span>
<span class="nc" id="L2181">                    origCallback.getBookieInfoComplete(rc, bInfo, origCtx);</span>
<span class="nc" id="L2182">                    key.release();</span>
<span class="nc" id="L2183">                }</span>
            };
<span class="nc" id="L2185">        }</span>

        @Override
        boolean maybeTimeout() {
<span class="nc bnc" id="L2189" title="All 2 branches missed.">            if (MathUtils.elapsedNanos(startTime) &gt;= getBookieInfoTimeoutNanos) {</span>
<span class="nc" id="L2190">                timeout();</span>
<span class="nc" id="L2191">                return true;</span>
            } else {
<span class="nc" id="L2193">                return false;</span>
            }
        }

        @Override
        public void errorOut() {
<span class="nc" id="L2199">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L2200">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L2204">            errorOutAndRunCallback(</span>
<span class="nc" id="L2205">                    () -&gt; cb.getBookieInfoComplete(rc, new BookieInfo(), ctx));</span>
<span class="nc" id="L2206">        }</span>

        @Override
        public void handleV3Response(Response response) {
<span class="nc" id="L2210">            GetBookieInfoResponse getBookieInfoResponse = response.getGetBookieInfoResponse();</span>
<span class="nc bnc" id="L2211" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L2212">                ? getBookieInfoResponse.getStatus() : response.getStatus();</span>

<span class="nc" id="L2214">            long freeDiskSpace = getBookieInfoResponse.getFreeDiskSpace();</span>
<span class="nc" id="L2215">            long totalDiskSpace = getBookieInfoResponse.getTotalDiskCapacity();</span>

<span class="nc bnc" id="L2217" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2218">                logResponse(status, &quot;freeDisk&quot;, freeDiskSpace, &quot;totalDisk&quot;, totalDiskSpace);</span>
            }

<span class="nc" id="L2221">            int rc = convertStatus(status, BKException.Code.ReadException);</span>
<span class="nc" id="L2222">            cb.getBookieInfoComplete(rc,</span>
                                     new BookieInfo(totalDiskSpace,
                                                    freeDiskSpace), ctx);
<span class="nc" id="L2225">        }</span>
    }

    class GetListOfEntriesOfLedgerCompletion extends CompletionValue {
        final GetListOfEntriesOfLedgerCallback cb;

        public GetListOfEntriesOfLedgerCompletion(final CompletionKey key,
<span class="nc" id="L2232">                final GetListOfEntriesOfLedgerCallback origCallback, final long ledgerId) {</span>
<span class="nc" id="L2233">            super(&quot;GetListOfEntriesOfLedger&quot;, null, ledgerId, 0L, getListOfEntriesOfLedgerCompletionOpLogger,</span>
<span class="nc" id="L2234">                    getListOfEntriesOfLedgerCompletionTimeoutOpLogger);</span>
<span class="nc" id="L2235">            this.cb = new GetListOfEntriesOfLedgerCallback() {</span>
                @Override
                public void getListOfEntriesOfLedgerComplete(int rc, long ledgerId,
                        AvailabilityOfEntriesOfLedger availabilityOfEntriesOfLedger) {
<span class="nc" id="L2239">                    logOpResult(rc);</span>
<span class="nc" id="L2240">                    origCallback.getListOfEntriesOfLedgerComplete(rc, ledgerId, availabilityOfEntriesOfLedger);</span>
<span class="nc" id="L2241">                    key.release();</span>
<span class="nc" id="L2242">                }</span>
            };
<span class="nc" id="L2244">        }</span>

        @Override
        public void errorOut() {
<span class="nc" id="L2248">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L2249">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L2253">            errorOutAndRunCallback(() -&gt; cb.getListOfEntriesOfLedgerComplete(rc, ledgerId, null));</span>
<span class="nc" id="L2254">        }</span>

        @Override
        public void handleV3Response(Response response) {
<span class="nc" id="L2258">            GetListOfEntriesOfLedgerResponse getListOfEntriesOfLedgerResponse = response</span>
<span class="nc" id="L2259">                    .getGetListOfEntriesOfLedgerResponse();</span>
<span class="nc" id="L2260">            ByteBuf availabilityOfEntriesOfLedgerBuffer = Unpooled.EMPTY_BUFFER;</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK ? getListOfEntriesOfLedgerResponse.getStatus()</span>
<span class="nc" id="L2262">                    : response.getStatus();</span>

<span class="nc bnc" id="L2264" title="All 2 branches missed.">            if (getListOfEntriesOfLedgerResponse.hasAvailabilityOfEntriesOfLedger()) {</span>
<span class="nc" id="L2265">                availabilityOfEntriesOfLedgerBuffer = Unpooled.wrappedBuffer(</span>
<span class="nc" id="L2266">                        getListOfEntriesOfLedgerResponse.getAvailabilityOfEntriesOfLedger().asReadOnlyByteBuffer());</span>
            }

<span class="nc bnc" id="L2269" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2270">                logResponse(status, &quot;ledgerId&quot;, ledgerId);</span>
            }

<span class="nc" id="L2273">            int rc = convertStatus(status, BKException.Code.ReadException);</span>
<span class="nc" id="L2274">            AvailabilityOfEntriesOfLedger availabilityOfEntriesOfLedger = null;</span>
<span class="nc bnc" id="L2275" title="All 2 branches missed.">            if (rc == BKException.Code.OK) {</span>
<span class="nc" id="L2276">                availabilityOfEntriesOfLedger = new AvailabilityOfEntriesOfLedger(</span>
<span class="nc" id="L2277">                        availabilityOfEntriesOfLedgerBuffer.slice());</span>
            }
<span class="nc" id="L2279">            cb.getListOfEntriesOfLedgerComplete(rc, ledgerId, availabilityOfEntriesOfLedger);</span>
<span class="nc" id="L2280">        }</span>
    }

<span class="nc" id="L2283">    private final Recycler&lt;AddCompletion&gt; addCompletionRecycler = new Recycler&lt;AddCompletion&gt;() {</span>
            @Override
            protected AddCompletion newObject(Handle&lt;AddCompletion&gt; handle) {
<span class="nc" id="L2286">                return new AddCompletion(handle);</span>
            }
        };

    AddCompletion acquireAddCompletion(final CompletionKey key,
                                       final WriteCallback originalCallback,
                                       final Object originalCtx,
                                       final long ledgerId, final long entryId) {
<span class="nc" id="L2294">        AddCompletion completion = addCompletionRecycler.get();</span>
<span class="nc" id="L2295">        completion.reset(key, originalCallback, originalCtx, ledgerId, entryId);</span>
<span class="nc" id="L2296">        return completion;</span>
    }

    // visible for testing
    class AddCompletion extends CompletionValue implements WriteCallback {
        final Handle&lt;AddCompletion&gt; handle;

<span class="nc" id="L2303">        CompletionKey key = null;</span>
<span class="nc" id="L2304">        WriteCallback originalCallback = null;</span>

<span class="nc" id="L2306">        AddCompletion(Handle&lt;AddCompletion&gt; handle) {</span>
<span class="nc" id="L2307">            super(&quot;Add&quot;, null, -1, -1, addEntryOpLogger, addTimeoutOpLogger);</span>
<span class="nc" id="L2308">            this.handle = handle;</span>
<span class="nc" id="L2309">        }</span>

        void reset(final CompletionKey key,
                   final WriteCallback originalCallback,
                   final Object originalCtx,
                   final long ledgerId, final long entryId) {
<span class="nc" id="L2315">            this.key = key;</span>
<span class="nc" id="L2316">            this.originalCallback = originalCallback;</span>
<span class="nc" id="L2317">            this.ctx = originalCtx;</span>
<span class="nc" id="L2318">            this.ledgerId = ledgerId;</span>
<span class="nc" id="L2319">            this.entryId = entryId;</span>
<span class="nc" id="L2320">            this.startTime = MathUtils.nowInNano();</span>
<span class="nc" id="L2321">        }</span>

        @Override
        public void writeComplete(int rc, long ledgerId, long entryId,
                                  BookieId addr,
                                  Object ctx) {
<span class="nc" id="L2327">            logOpResult(rc);</span>
<span class="nc" id="L2328">            originalCallback.writeComplete(rc, ledgerId, entryId, addr, ctx);</span>
<span class="nc" id="L2329">            key.release();</span>
<span class="nc" id="L2330">            handle.recycle(this);</span>
<span class="nc" id="L2331">        }</span>

        @Override
        boolean maybeTimeout() {
<span class="nc bnc" id="L2335" title="All 2 branches missed.">            if (MathUtils.elapsedNanos(startTime) &gt;= addEntryTimeoutNanos) {</span>
<span class="nc" id="L2336">                timeout();</span>
<span class="nc" id="L2337">                return true;</span>
            } else {
<span class="nc" id="L2339">                return false;</span>
            }
        }

        @Override
        public void errorOut() {
<span class="nc" id="L2345">            errorOut(BKException.Code.BookieHandleNotAvailableException);</span>
<span class="nc" id="L2346">        }</span>

        @Override
        public void errorOut(final int rc) {
<span class="nc" id="L2350">            errorOutAndRunCallback(</span>
<span class="nc" id="L2351">                    () -&gt; writeComplete(rc, ledgerId, entryId, bookieId, ctx));</span>
<span class="nc" id="L2352">        }</span>

        @Override
        public void setOutstanding() {
<span class="nc" id="L2356">            addEntryOutstanding.inc();</span>
<span class="nc" id="L2357">        }</span>

        @Override
        public void handleV2Response(
                long ledgerId, long entryId, StatusCode status,
                BookieProtocol.Response response) {
<span class="nc" id="L2363">            addEntryOutstanding.dec();</span>
<span class="nc" id="L2364">            handleResponse(ledgerId, entryId, status);</span>
<span class="nc" id="L2365">        }</span>

        @Override
        public void handleV3Response(
                Response response) {
<span class="nc" id="L2370">            addEntryOutstanding.dec();</span>
<span class="nc" id="L2371">            AddResponse addResponse = response.getAddResponse();</span>
<span class="nc bnc" id="L2372" title="All 2 branches missed.">            StatusCode status = response.getStatus() == StatusCode.EOK</span>
<span class="nc" id="L2373">                ? addResponse.getStatus() : response.getStatus();</span>
<span class="nc" id="L2374">            handleResponse(addResponse.getLedgerId(), addResponse.getEntryId(),</span>
                           status);
<span class="nc" id="L2376">        }</span>

        private void handleResponse(long ledgerId, long entryId,
                                    StatusCode status) {
<span class="nc bnc" id="L2380" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2381">                logResponse(status, &quot;ledger&quot;, ledgerId, &quot;entry&quot;, entryId);</span>
            }

<span class="nc" id="L2384">            int rc = convertStatus(status, BKException.Code.WriteException);</span>
<span class="nc" id="L2385">            writeComplete(rc, ledgerId, entryId, bookieId, ctx);</span>
<span class="nc" id="L2386">        }</span>
    }

    // visible for testing
    CompletionKey newCompletionKey(long txnId, OperationType operationType) {
<span class="nc" id="L2391">        return new TxnCompletionKey(txnId, operationType);</span>
    }

    class TxnCompletionKey extends CompletionKey {
        final long txnId;

<span class="nc" id="L2397">        public TxnCompletionKey(long txnId, OperationType operationType) {</span>
<span class="nc" id="L2398">            super(operationType);</span>
<span class="nc" id="L2399">            this.txnId = txnId;</span>
<span class="nc" id="L2400">        }</span>

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L2404" title="All 2 branches missed.">            if (!(obj instanceof TxnCompletionKey)) {</span>
<span class="nc" id="L2405">                return false;</span>
            }
<span class="nc" id="L2407">            TxnCompletionKey that = (TxnCompletionKey) obj;</span>
<span class="nc bnc" id="L2408" title="All 4 branches missed.">            return this.txnId == that.txnId &amp;&amp; this.operationType == that.operationType;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L2413">            return ((int) txnId);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L2418">            return String.format(&quot;TxnId(%d), OperationType(%s)&quot;, txnId, operationType);</span>
        }

    }

    abstract class CompletionKey {
        OperationType operationType;

<span class="nc" id="L2426">        CompletionKey(OperationType operationType) {</span>
<span class="nc" id="L2427">            this.operationType = operationType;</span>
<span class="nc" id="L2428">        }</span>

<span class="nc" id="L2430">        public void release() {}</span>
    }

    /**
     * Note : Helper functions follow
     */

    /**
     * @param status
     * @return {@link BKException.Code.UNINITIALIZED} if the statuscode is unknown.
     */
    private int statusCodeToExceptionCode(StatusCode status) {
<span class="nc bnc" id="L2442" title="All 10 branches missed.">        switch (status) {</span>
            case EOK:
<span class="nc" id="L2444">                return BKException.Code.OK;</span>
            case ENOENTRY:
<span class="nc" id="L2446">                return BKException.Code.NoSuchEntryException;</span>
            case ENOLEDGER:
<span class="nc" id="L2448">                return BKException.Code.NoSuchLedgerExistsException;</span>
            case EBADVERSION:
<span class="nc" id="L2450">                return BKException.Code.ProtocolVersionException;</span>
            case EUA:
<span class="nc" id="L2452">                return BKException.Code.UnauthorizedAccessException;</span>
            case EFENCED:
<span class="nc" id="L2454">                return BKException.Code.LedgerFencedException;</span>
            case EREADONLY:
<span class="nc" id="L2456">                return BKException.Code.WriteOnReadOnlyBookieException;</span>
            case ETOOMANYREQUESTS:
<span class="nc" id="L2458">                return BKException.Code.TooManyRequestsException;</span>
            case EUNKNOWNLEDGERSTATE:
<span class="nc" id="L2460">                return BKException.Code.DataUnknownException;</span>
            default:
<span class="nc" id="L2462">                return BKException.Code.UNINITIALIZED;</span>
        }
    }

    private void putCompletionKeyValue(CompletionKey key, CompletionValue value) {
<span class="nc" id="L2467">        CompletionValue existingValue = completionObjects.putIfAbsent(key, value);</span>
<span class="nc bnc" id="L2468" title="All 2 branches missed.">        if (existingValue != null) { // will only happen for V2 keys, as V3 have unique txnid</span>
            // There's a pending read request on same ledger/entry. Use the multimap to track all of them
<span class="nc" id="L2470">            completionObjectsV2Conflicts.put(key, value);</span>
        }
<span class="nc" id="L2472">    }</span>

    private CompletionValue getCompletionValue(CompletionKey key) {
<span class="nc" id="L2475">        CompletionValue completionValue = completionObjects.remove(key);</span>
<span class="nc bnc" id="L2476" title="All 2 branches missed.">        if (completionValue == null) {</span>
            // If there's no completion object here, try in the multimap
<span class="nc" id="L2478">            completionValue = completionObjectsV2Conflicts.removeAny(key).orElse(null);</span>
        }
<span class="nc" id="L2480">        return completionValue;</span>
    }

    private long getTxnId() {
<span class="nc" id="L2484">        return txnIdGenerator.incrementAndGet();</span>
    }

<span class="nc" id="L2487">    private final Recycler&lt;EntryCompletionKey&gt; v2KeyRecycler = new Recycler&lt;EntryCompletionKey&gt;() {</span>
            @Override
            protected EntryCompletionKey newObject(
                    Handle&lt;EntryCompletionKey&gt; handle) {
<span class="nc" id="L2491">                return new EntryCompletionKey(handle);</span>
            }
        };

    EntryCompletionKey acquireV2Key(long ledgerId, long entryId,
                             OperationType operationType) {
<span class="nc" id="L2497">        EntryCompletionKey key = v2KeyRecycler.get();</span>
<span class="nc" id="L2498">        key.reset(ledgerId, entryId, operationType);</span>
<span class="nc" id="L2499">        return key;</span>
    }

    private class EntryCompletionKey extends CompletionKey {
        private final Handle&lt;EntryCompletionKey&gt; recyclerHandle;
        long ledgerId;
        long entryId;

<span class="nc" id="L2507">        private EntryCompletionKey(Handle&lt;EntryCompletionKey&gt; handle) {</span>
<span class="nc" id="L2508">            super(null);</span>
<span class="nc" id="L2509">            this.recyclerHandle = handle;</span>
<span class="nc" id="L2510">        }</span>

        void reset(long ledgerId, long entryId, OperationType operationType) {
<span class="nc" id="L2513">            this.ledgerId = ledgerId;</span>
<span class="nc" id="L2514">            this.entryId = entryId;</span>
<span class="nc" id="L2515">            this.operationType = operationType;</span>
<span class="nc" id="L2516">        }</span>

        @Override
        public boolean equals(Object object) {
<span class="nc bnc" id="L2520" title="All 2 branches missed.">            if (!(object instanceof EntryCompletionKey)) {</span>
<span class="nc" id="L2521">                return  false;</span>
            }
<span class="nc" id="L2523">            EntryCompletionKey that = (EntryCompletionKey) object;</span>
<span class="nc bnc" id="L2524" title="All 6 branches missed.">            return this.entryId == that.entryId</span>
                &amp;&amp; this.ledgerId == that.ledgerId
                &amp;&amp; this.operationType == that.operationType;
        }

        @Override
        public int hashCode() {
<span class="nc" id="L2531">            return Long.hashCode(ledgerId) * 31 + Long.hashCode(entryId);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L2536">            return String.format(&quot;%d:%d %s&quot;, ledgerId, entryId, operationType);</span>
        }

        @Override
        public void release() {
<span class="nc" id="L2541">            recyclerHandle.recycle(this);</span>
<span class="nc" id="L2542">        }</span>
    }

    Request.Builder withRequestContext(Request.Builder builder) {
<span class="nc bnc" id="L2546" title="All 2 branches missed.">        if (preserveMdcForTaskExecution) {</span>
<span class="nc" id="L2547">            return appendRequestContext(builder);</span>
        }
<span class="nc" id="L2549">        return builder;</span>
    }

    static Request.Builder appendRequestContext(Request.Builder builder) {
<span class="nc" id="L2553">        final Map&lt;String, String&gt; mdcContextMap = MDC.getCopyOfContextMap();</span>
<span class="nc bnc" id="L2554" title="All 4 branches missed.">        if (mdcContextMap == null || mdcContextMap.isEmpty()) {</span>
<span class="nc" id="L2555">            return builder;</span>
        }
<span class="nc bnc" id="L2557" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; kv : mdcContextMap.entrySet()) {</span>
<span class="nc" id="L2558">            final BookkeeperProtocol.ContextPair context = BookkeeperProtocol.ContextPair.newBuilder()</span>
<span class="nc" id="L2559">                    .setKey(kv.getKey())</span>
<span class="nc" id="L2560">                    .setValue(kv.getValue())</span>
<span class="nc" id="L2561">                    .build();</span>
<span class="nc" id="L2562">            builder.addRequestContext(context);</span>
<span class="nc" id="L2563">        }</span>
<span class="nc" id="L2564">        return builder;</span>
    }

    ChannelFutureListener contextPreservingListener(ChannelFutureListener listener) {
<span class="nc bnc" id="L2568" title="All 2 branches missed.">        return preserveMdcForTaskExecution ? new ContextPreservingFutureListener(listener) : listener;</span>
    }

    /**
     * Decorator to preserve MDC for connection listener.
     */
    static class ContextPreservingFutureListener implements ChannelFutureListener {
        private final ChannelFutureListener listener;
        private final Map&lt;String, String&gt; mdcContextMap;

<span class="nc" id="L2578">        ContextPreservingFutureListener(ChannelFutureListener listener) {</span>
<span class="nc" id="L2579">            this.listener = listener;</span>
<span class="nc" id="L2580">            this.mdcContextMap = MDC.getCopyOfContextMap();</span>
<span class="nc" id="L2581">        }</span>

        @Override
        public void operationComplete(ChannelFuture future) throws Exception {
<span class="nc" id="L2585">            MdcUtils.restoreContext(mdcContextMap);</span>
            try {
<span class="nc" id="L2587">                listener.operationComplete(future);</span>
            } finally {
<span class="nc" id="L2589">                MDC.clear();</span>
            }
<span class="nc" id="L2591">        }</span>
    }

    /**
     * Connection listener.
     */
    class ConnectionFutureListener implements ChannelFutureListener {
        private final long startTime;

<span class="nc" id="L2600">        ConnectionFutureListener(long startTime) {</span>
<span class="nc" id="L2601">            this.startTime = startTime;</span>
<span class="nc" id="L2602">        }</span>

        @Override
        public void operationComplete(ChannelFuture future) {
<span class="nc bnc" id="L2606" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2607">                LOG.debug(&quot;Channel connected ({}) {}&quot;, future.isSuccess(), future.channel());</span>
            }
            int rc;
            Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;

            /* We fill in the timer based on whether the connect operation itself succeeded regardless of
             * whether there was a race */
<span class="nc bnc" id="L2614" title="All 2 branches missed.">            if (future.isSuccess()) {</span>
<span class="nc" id="L2615">                PerChannelBookieClient.this</span>
<span class="nc" id="L2616">                .connectTimer.registerSuccessfulEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);</span>
            } else {
<span class="nc" id="L2618">                PerChannelBookieClient.this</span>
<span class="nc" id="L2619">                .connectTimer.registerFailedEvent(MathUtils.elapsedNanos(startTime), TimeUnit.NANOSECONDS);</span>
            }

<span class="nc" id="L2622">            synchronized (PerChannelBookieClient.this) {</span>
<span class="nc bnc" id="L2623" title="All 6 branches missed.">                if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTING &amp;&amp; future.channel().isActive()) {</span>
<span class="nc" id="L2624">                    rc = BKException.Code.OK;</span>
<span class="nc" id="L2625">                    channel = future.channel();</span>
<span class="nc bnc" id="L2626" title="All 2 branches missed.">                    if (shFactory != null) {</span>
<span class="nc" id="L2627">                        LOG.info(&quot;Successfully connected to bookie: {} {} initiate TLS&quot;, bookieId, future.channel());</span>
<span class="nc" id="L2628">                        makeWritable();</span>
<span class="nc" id="L2629">                        initiateTLS();</span>
<span class="nc" id="L2630">                        return;</span>
                    } else {
<span class="nc" id="L2632">                        LOG.info(&quot;Successfully connected to bookie: {} {}&quot;, bookieId, future.channel());</span>
<span class="nc" id="L2633">                        state = ConnectionState.CONNECTED;</span>
<span class="nc" id="L2634">                        activeNonTlsChannelCounter.inc();</span>
                    }
<span class="nc bnc" id="L2636" title="All 4 branches missed.">                } else if (future.isSuccess() &amp;&amp; state == ConnectionState.START_TLS) {</span>
<span class="nc" id="L2637">                    rc = BKException.Code.OK;</span>
<span class="nc" id="L2638">                    LOG.info(&quot;Successfully connected to bookie using TLS: &quot; + bookieId);</span>

<span class="nc" id="L2640">                    state = ConnectionState.CONNECTED;</span>
<span class="nc" id="L2641">                    AuthHandler.ClientSideHandler authHandler = future.channel().pipeline()</span>
<span class="nc" id="L2642">                            .get(AuthHandler.ClientSideHandler.class);</span>
<span class="nc" id="L2643">                    authHandler.authProvider.onProtocolUpgrade();</span>
<span class="nc" id="L2644">                    activeTlsChannelCounter.inc();</span>
<span class="nc bnc" id="L2645" title="All 6 branches missed.">                } else if (future.isSuccess() &amp;&amp; (state == ConnectionState.CLOSED</span>
                    || state == ConnectionState.DISCONNECTED)) {
<span class="nc" id="L2647">                    LOG.warn(&quot;Closed before connection completed, clean up: {}, current state {}&quot;,</span>
<span class="nc" id="L2648">                            future.channel(), state);</span>
<span class="nc" id="L2649">                    closeChannel(future.channel());</span>
<span class="nc" id="L2650">                    rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L2651">                    channel = null;</span>
<span class="nc bnc" id="L2652" title="All 4 branches missed.">                } else if (future.isSuccess() &amp;&amp; state == ConnectionState.CONNECTED) {</span>
<span class="nc bnc" id="L2653" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L2654">                        LOG.debug(&quot;Already connected with another channel({}), so close the new channel({})&quot;, channel,</span>
<span class="nc" id="L2655">                                future.channel());</span>
                    }
<span class="nc" id="L2657">                    closeChannel(future.channel());</span>
<span class="nc" id="L2658">                    return; // pendingOps should have been completed when other channel connected</span>
                } else {
<span class="nc" id="L2660">                    Throwable cause = future.cause();</span>
<span class="nc bnc" id="L2661" title="All 4 branches missed.">                    if (cause instanceof UnknownHostException || cause instanceof NativeIoException) {</span>
                        // Don't log stack trace for common errors
<span class="nc" id="L2663">                        logBookieUnavailable(() -&gt; LOG.warn(&quot;Could not connect to bookie: {}/{}, current state {} : {}&quot;,</span>
<span class="nc" id="L2664">                                future.channel(), bookieId, state, future.cause().getMessage()));</span>
                    } else {
                        // Regular exceptions, include stack trace
<span class="nc" id="L2667">                        logBookieUnavailable(() -&gt; LOG.error(&quot;Could not connect to bookie: {}/{}, current state {} : &quot;,</span>
<span class="nc" id="L2668">                                future.channel(), bookieId, state, future.cause()));</span>
                    }

<span class="nc" id="L2671">                    rc = BKException.Code.BookieHandleNotAvailableException;</span>
<span class="nc" id="L2672">                    Channel failedChannel = future.channel();</span>
<span class="nc bnc" id="L2673" title="All 2 branches missed.">                    if (failedChannel != null) { // can be null in case of dummy failed ChannelFuture</span>
<span class="nc" id="L2674">                        closeChannel(failedChannel);</span>
                    }
<span class="nc" id="L2676">                    channel = null;</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">                    if (state != ConnectionState.CLOSED) {</span>
<span class="nc" id="L2678">                        state = ConnectionState.DISCONNECTED;</span>
                    }
<span class="nc" id="L2680">                    failedConnectionCounter.inc();</span>
                }

                // trick to not do operations under the lock, take the list
                // of pending ops and assign it to a new variable, while
                // emptying the pending ops by just assigning it to a new
                // list
<span class="nc" id="L2687">                oldPendingOps = pendingOps;</span>
<span class="nc" id="L2688">                pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L2689">            }</span>

<span class="nc bnc" id="L2691" title="All 2 branches missed.">            for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="nc" id="L2692">                pendingOp.operationComplete(rc, PerChannelBookieClient.this);</span>
<span class="nc" id="L2693">            }</span>

<span class="nc" id="L2695">            makeWritable();</span>
<span class="nc" id="L2696">        }</span>

        private void logBookieUnavailable(Runnable logger) {
<span class="nc" id="L2699">            final long now = System.currentTimeMillis();</span>
<span class="nc bnc" id="L2700" title="All 2 branches missed.">            if ((now - lastBookieUnavailableLogTimestamp) &gt; conf.getClientConnectBookieUnavailableLogThrottlingMs()) {</span>
<span class="nc" id="L2701">                logger.run();</span>
<span class="nc" id="L2702">                lastBookieUnavailableLogTimestamp = now;</span>
            }
<span class="nc" id="L2704">        }</span>
    }

    private void initiateTLS() {
<span class="nc" id="L2708">        LOG.info(&quot;Initializing TLS to {}&quot;, channel);</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">        assert state == ConnectionState.CONNECTING;</span>
<span class="nc" id="L2710">        final long txnId = getTxnId();</span>
<span class="nc" id="L2711">        final CompletionKey completionKey = new TxnCompletionKey(txnId, OperationType.START_TLS);</span>
<span class="nc" id="L2712">        completionObjects.put(completionKey,</span>
                              new StartTLSCompletion(completionKey));
<span class="nc" id="L2714">        Request.Builder h = withRequestContext(Request.newBuilder());</span>
<span class="nc" id="L2715">        BKPacketHeader.Builder headerBuilder = BKPacketHeader.newBuilder()</span>
<span class="nc" id="L2716">                .setVersion(ProtocolVersion.VERSION_THREE)</span>
<span class="nc" id="L2717">                .setOperation(OperationType.START_TLS)</span>
<span class="nc" id="L2718">                .setTxnId(txnId);</span>
<span class="nc" id="L2719">        h.setHeader(headerBuilder.build());</span>
<span class="nc" id="L2720">        h.setStartTLSRequest(BookkeeperProtocol.StartTLSRequest.newBuilder().build());</span>
<span class="nc" id="L2721">        state = ConnectionState.START_TLS;</span>
<span class="nc" id="L2722">        writeAndFlush(channel, completionKey, h.build());</span>
<span class="nc" id="L2723">    }</span>

    private void failTLS(int rc) {
<span class="nc" id="L2726">        LOG.error(&quot;TLS failure on: {}, rc: {}&quot;, channel, rc);</span>
        Queue&lt;GenericCallback&lt;PerChannelBookieClient&gt;&gt; oldPendingOps;
<span class="nc" id="L2728">        synchronized (this) {</span>
<span class="nc" id="L2729">            disconnect();</span>
<span class="nc" id="L2730">            oldPendingOps = pendingOps;</span>
<span class="nc" id="L2731">            pendingOps = new ArrayDeque&lt;&gt;();</span>
<span class="nc" id="L2732">        }</span>
<span class="nc bnc" id="L2733" title="All 2 branches missed.">        for (GenericCallback&lt;PerChannelBookieClient&gt; pendingOp : oldPendingOps) {</span>
<span class="nc" id="L2734">            pendingOp.operationComplete(rc, null);</span>
<span class="nc" id="L2735">        }</span>
<span class="nc" id="L2736">        failedTlsHandshakeCounter.inc();</span>
<span class="nc" id="L2737">    }</span>

    private static class FailedChannelFutureImpl implements ChannelFuture {

        private final Throwable failureCause;
<span class="nc" id="L2742">        public FailedChannelFutureImpl(Throwable failureCause) {</span>
<span class="nc" id="L2743">            this.failureCause = failureCause;</span>
<span class="nc" id="L2744">        }</span>

        @Override
        public Channel channel() {
            // used only for log
<span class="nc" id="L2749">            return null;</span>
        }

        @Override
        public ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener) {
<span class="nc" id="L2754">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        @SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})
        public ChannelFuture addListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners) {
<span class="nc" id="L2760">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public ChannelFuture removeListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener) {
<span class="nc" id="L2765">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        @SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})
        public ChannelFuture removeListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners) {
<span class="nc" id="L2771">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public ChannelFuture sync() throws InterruptedException {
<span class="nc" id="L2776">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public ChannelFuture syncUninterruptibly() {
<span class="nc" id="L2781">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public ChannelFuture await() throws InterruptedException {
<span class="nc" id="L2786">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public ChannelFuture awaitUninterruptibly() {
<span class="nc" id="L2791">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public boolean isVoid() {
<span class="nc" id="L2796">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public boolean isSuccess() {
<span class="nc" id="L2801">            return false;</span>
        }

        @Override
        public boolean isCancellable() {
<span class="nc" id="L2806">            return false;</span>
        }

        @Override
        public Throwable cause() {
<span class="nc" id="L2811">            return failureCause;</span>
        }

        @Override
        public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
<span class="nc" id="L2816">            return true;</span>
        }

        @Override
        public boolean await(long timeoutMillis) throws InterruptedException {
<span class="nc" id="L2821">            return true;</span>
        }

        @Override
        public boolean awaitUninterruptibly(long timeout, TimeUnit unit) {
<span class="nc" id="L2826">            return true;</span>
        }

        @Override
        public boolean awaitUninterruptibly(long timeoutMillis) {
<span class="nc" id="L2831">            return true;</span>
        }

        @Override
        public Void getNow() {
<span class="nc" id="L2836">            throw new UnsupportedOperationException(&quot;Not supported&quot;);</span>
        }

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
<span class="nc" id="L2841">            return false;</span>
        }

        @Override
        public boolean isCancelled() {
<span class="nc" id="L2846">            return false;</span>
        }

        @Override
        public boolean isDone() {
<span class="nc" id="L2851">            return true;</span>
        }

        @Override
        public Void get() throws InterruptedException, ExecutionException {
<span class="nc" id="L2856">            throw new ExecutionException(failureCause);</span>
        }

        @Override
        public Void get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
<span class="nc" id="L2861">            throw new ExecutionException(failureCause);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>