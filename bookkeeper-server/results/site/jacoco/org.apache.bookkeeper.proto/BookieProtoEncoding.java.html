<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BookieProtoEncoding.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.proto</a> &gt; <span class="el_source">BookieProtoEncoding.java</span></div><h1>BookieProtoEncoding.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.proto;

import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.MessageLite;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.ByteBufInputStream;
import io.netty.buffer.ByteBufOutputStream;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelOutboundHandlerAdapter;
import io.netty.channel.ChannelPromise;
import io.netty.util.ReferenceCountUtil;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import org.apache.bookkeeper.proto.BookieProtocol.PacketHeader;
import org.apache.bookkeeper.proto.BookkeeperProtocol.OperationType;
import org.apache.bookkeeper.proto.BookkeeperProtocol.Response;
import org.apache.bookkeeper.proto.checksum.MacDigestManager;
import org.apache.bookkeeper.util.ByteBufList;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A class for encoding and decoding the Bookkeeper protocol.
 */
<span class="nc" id="L50">public class BookieProtoEncoding {</span>
<span class="nc" id="L51">    private static final Logger LOG = LoggerFactory.getLogger(BookieProtoEncoding.class);</span>

    /**
     * Threshold under which an entry is considered to be &quot;small&quot;.
     *
     * Small entries payloads are copied instead of being passed around as references.
     */
    public static final int SMALL_ENTRY_SIZE_THRESHOLD = 16 * 1024;

    /**
     * An encoder/decoder interface for the Bookkeeper protocol.
     */
    public interface EnDecoder {
        /**
         * Encode a &lt;i&gt;object&lt;/i&gt; into channel buffer.
         *
         * @param object
         *          object.
         * @return encode buffer.
         * @throws Exception
         */
        Object encode(Object object, ByteBufAllocator allocator) throws Exception;

        /**
         * Decode a &lt;i&gt;packet&lt;/i&gt; into an object.
         *
         * @param packet
         *          received packet.
         * @return parsed object.
         * @throws Exception
         */
        Object decode(ByteBuf packet) throws Exception;

    }

    /**
     * An encoder/decoder for the Bookkeeper protocol before version 3.
     */
    public static class RequestEnDeCoderPreV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

        //This empty master key is used when an empty password is provided which is the hash of an empty string
        private static final byte[] emptyPasswordMasterKey;
        static {
            try {
<span class="nc" id="L96">                emptyPasswordMasterKey = MacDigestManager.genDigest(&quot;ledger&quot;, new byte[0]);</span>
<span class="nc" id="L97">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L98">                throw new RuntimeException(e);</span>
<span class="nc" id="L99">            }</span>
<span class="nc" id="L100">        }</span>

<span class="nc" id="L102">        public RequestEnDeCoderPreV3(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L103">            this.extensionRegistry = extensionRegistry;</span>
<span class="nc" id="L104">        }</span>

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator)
                throws Exception {
<span class="nc bnc" id="L109" title="All 2 branches missed.">            if (!(msg instanceof BookieProtocol.Request)) {</span>
<span class="nc" id="L110">                return msg;</span>
            }
<span class="nc" id="L112">            BookieProtocol.Request r = (BookieProtocol.Request) msg;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if (r instanceof BookieProtocol.BatchedReadRequest) {</span>
<span class="nc" id="L114">                int totalHeaderSize = 4 // for request type</span>
                        + 8 // for ledger id
                        + 8 // for entry id
                        + 8 // for request id
                        + 4 // for max count
                        + 8; // for max size
<span class="nc bnc" id="L120" title="All 2 branches missed.">                if (r.hasMasterKey()) {</span>
<span class="nc" id="L121">                    totalHeaderSize += BookieProtocol.MASTER_KEY_LENGTH;</span>
                }
<span class="nc" id="L123">                ByteBuf buf = allocator.buffer(totalHeaderSize + 4 /* frame size */);</span>
<span class="nc" id="L124">                buf.writeInt(totalHeaderSize);</span>
<span class="nc" id="L125">                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));</span>
<span class="nc" id="L126">                buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L127">                buf.writeLong(r.getEntryId());</span>
<span class="nc" id="L128">                buf.writeLong(((BookieProtocol.BatchedReadRequest) r).getRequestId());</span>
<span class="nc" id="L129">                buf.writeInt(((BookieProtocol.BatchedReadRequest) r).getMaxCount());</span>
<span class="nc" id="L130">                buf.writeLong(((BookieProtocol.BatchedReadRequest) r).getMaxSize());</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                if (r.hasMasterKey()) {</span>
<span class="nc" id="L132">                    buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);</span>
                }
<span class="nc" id="L134">                r.recycle();</span>
<span class="nc" id="L135">                return buf;</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            } else if (r instanceof BookieProtocol.ReadRequest) {</span>
<span class="nc" id="L137">                int totalHeaderSize = 4 // for request type</span>
                    + 8 // for ledgerId
                    + 8; // for entryId
<span class="nc bnc" id="L140" title="All 2 branches missed.">                if (r.hasMasterKey()) {</span>
<span class="nc" id="L141">                    totalHeaderSize += BookieProtocol.MASTER_KEY_LENGTH;</span>
                }

<span class="nc" id="L144">                ByteBuf buf = allocator.buffer(totalHeaderSize + 4 /* frame size */);</span>
<span class="nc" id="L145">                buf.writeInt(totalHeaderSize);</span>
<span class="nc" id="L146">                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));</span>
<span class="nc" id="L147">                buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L148">                buf.writeLong(r.getEntryId());</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">                if (r.hasMasterKey()) {</span>
<span class="nc" id="L150">                    buf.writeBytes(r.getMasterKey(), 0, BookieProtocol.MASTER_KEY_LENGTH);</span>
                }
<span class="nc" id="L152">                r.recycle();</span>
<span class="nc" id="L153">                return buf;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            } else if (r instanceof BookieProtocol.AuthRequest) {</span>
<span class="nc" id="L155">                BookkeeperProtocol.AuthMessage am = ((BookieProtocol.AuthRequest) r).getAuthMessage();</span>
<span class="nc" id="L156">                int totalHeaderSize = 4; // for request type</span>
<span class="nc" id="L157">                int totalSize = totalHeaderSize + am.getSerializedSize();</span>
<span class="nc" id="L158">                ByteBuf buf = allocator.buffer(totalSize + 4 /* frame size */);</span>
<span class="nc" id="L159">                buf.writeInt(totalSize);</span>
<span class="nc" id="L160">                buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), r.getFlags()));</span>
<span class="nc" id="L161">                ByteBufOutputStream bufStream = new ByteBufOutputStream(buf);</span>
<span class="nc" id="L162">                am.writeTo(bufStream);</span>
<span class="nc" id="L163">                return buf;</span>
            } else {
<span class="nc" id="L165">                return msg;</span>
            }
        }

        @Override
        public Object decode(ByteBuf packet)
                throws Exception {
<span class="nc" id="L172">            int packetHeader = packet.readInt();</span>
<span class="nc" id="L173">            byte version = PacketHeader.getVersion(packetHeader);</span>
<span class="nc" id="L174">            byte opCode = PacketHeader.getOpCode(packetHeader);</span>
<span class="nc" id="L175">            short flags = PacketHeader.getFlags(packetHeader);</span>

            // packet format is different between ADDENTRY and READENTRY
<span class="nc" id="L178">            long ledgerId = -1;</span>
<span class="nc" id="L179">            long entryId = BookieProtocol.INVALID_ENTRY_ID;</span>

<span class="nc bnc" id="L181" title="All 5 branches missed.">            switch (opCode) {</span>
            case BookieProtocol.ADDENTRY: {
<span class="nc" id="L183">                byte[] masterKey = readMasterKey(packet);</span>

                // Read ledger and entry id without advancing the reader index
<span class="nc" id="L186">                ledgerId = packet.getLong(packet.readerIndex());</span>
<span class="nc" id="L187">                entryId = packet.getLong(packet.readerIndex() + 8);</span>
                // mark the reader index so that any resets will return to the
                // start of the payload
<span class="nc" id="L190">                packet.markReaderIndex();</span>
<span class="nc" id="L191">                return BookieProtocol.ParsedAddRequest.create(</span>
                        version, ledgerId, entryId, flags,
                        masterKey, packet);
            }

            case BookieProtocol.READENTRY:
<span class="nc" id="L197">                ledgerId = packet.readLong();</span>
<span class="nc" id="L198">                entryId = packet.readLong();</span>

<span class="nc bnc" id="L200" title="All 4 branches missed.">                if ((flags &amp; BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING</span>
                    &amp;&amp; version &gt;= 2) {
<span class="nc" id="L202">                    byte[] masterKey = readMasterKey(packet);</span>
<span class="nc" id="L203">                    return BookieProtocol.ReadRequest.create(version, ledgerId, entryId, flags, masterKey);</span>
                } else {
<span class="nc" id="L205">                    return BookieProtocol.ReadRequest.create(version, ledgerId, entryId, flags, null);</span>
                }
            case BookieProtocol.BATCH_READ_ENTRY:
<span class="nc" id="L208">                ledgerId = packet.readLong();</span>
<span class="nc" id="L209">                entryId = packet.readLong();</span>
<span class="nc" id="L210">                long requestId = packet.readLong();</span>
<span class="nc" id="L211">                int maxCount = packet.readInt();</span>
<span class="nc" id="L212">                long maxSize = packet.readLong();</span>
<span class="nc bnc" id="L213" title="All 4 branches missed.">                if ((flags &amp; BookieProtocol.FLAG_DO_FENCING) == BookieProtocol.FLAG_DO_FENCING</span>
                        &amp;&amp; version &gt;= 2) {
<span class="nc" id="L215">                    byte[] masterKey = readMasterKey(packet);</span>
<span class="nc" id="L216">                    return BookieProtocol.BatchedReadRequest.create(version, ledgerId, entryId, flags, masterKey,</span>
                            requestId, maxCount, maxSize);
                } else {
<span class="nc" id="L219">                    return BookieProtocol.BatchedReadRequest.create(version, ledgerId, entryId, flags, null,</span>
                            requestId, maxCount, maxSize);
                }
            case BookieProtocol.AUTH:
<span class="nc" id="L223">                BookkeeperProtocol.AuthMessage.Builder builder = BookkeeperProtocol.AuthMessage.newBuilder();</span>
<span class="nc" id="L224">                builder.mergeFrom(new ByteBufInputStream(packet), extensionRegistry);</span>
<span class="nc" id="L225">                return new BookieProtocol.AuthRequest(version, builder.build());</span>

            default:
<span class="nc" id="L228">                throw new IllegalStateException(&quot;Received unknown request op code = &quot; + opCode);</span>
            }
        }

        private static byte[] readMasterKey(ByteBuf packet) {
<span class="nc" id="L233">            byte[] masterKey = null;</span>

            // check if the master key is an empty master key
<span class="nc" id="L236">            boolean isEmptyKey = true;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">            for (int i = 0; i &lt; BookieProtocol.MASTER_KEY_LENGTH; i++) {</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                if (packet.getByte(packet.readerIndex() + i) != emptyPasswordMasterKey[i]) {</span>
<span class="nc" id="L239">                    isEmptyKey = false;</span>
<span class="nc" id="L240">                    break;</span>
                }
            }

<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (isEmptyKey) {</span>
                // avoid new allocations if incoming master key is empty and use the static master key
<span class="nc" id="L246">                masterKey = emptyPasswordMasterKey;</span>
<span class="nc" id="L247">                packet.readerIndex(packet.readerIndex() + BookieProtocol.MASTER_KEY_LENGTH);</span>
            } else {
                // Master key is set, we need to copy and check it
<span class="nc" id="L250">                masterKey = new byte[BookieProtocol.MASTER_KEY_LENGTH];</span>
<span class="nc" id="L251">                packet.readBytes(masterKey, 0, BookieProtocol.MASTER_KEY_LENGTH);</span>
            }

<span class="nc" id="L254">            return masterKey;</span>
        }
    }

    /**
     * A response encoder/decoder for the Bookkeeper protocol before version 3.
     */
    public static class ResponseEnDeCoderPreV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

<span class="nc" id="L264">        public ResponseEnDeCoderPreV3(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L265">            this.extensionRegistry = extensionRegistry;</span>
<span class="nc" id="L266">        }</span>

        private static final int RESPONSE_HEADERS_SIZE = 24;

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator)
                throws Exception {
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (!(msg instanceof BookieProtocol.Response)) {</span>
<span class="nc" id="L274">                return msg;</span>
            }
<span class="nc" id="L276">            BookieProtocol.Response r = (BookieProtocol.Response) msg;</span>

            try {
<span class="nc bnc" id="L279" title="All 2 branches missed.">                if (msg instanceof BookieProtocol.ReadResponse) {</span>
<span class="nc" id="L280">                    BookieProtocol.ReadResponse rr = (BookieProtocol.ReadResponse) r;</span>
<span class="nc" id="L281">                    int payloadSize = rr.getData().readableBytes();</span>
<span class="nc" id="L282">                    int responseSize = RESPONSE_HEADERS_SIZE + payloadSize;</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                    boolean isSmallEntry = payloadSize &lt; SMALL_ENTRY_SIZE_THRESHOLD;</span>

<span class="nc" id="L285">                    int bufferSize = 4 /* frame size */ + RESPONSE_HEADERS_SIZE</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                            + (isSmallEntry ? payloadSize : 0);</span>
<span class="nc" id="L287">                    ByteBuf buf = allocator.buffer(bufferSize);</span>
<span class="nc" id="L288">                    buf.writeInt(responseSize);</span>
<span class="nc" id="L289">                    buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), (short) 0));</span>
<span class="nc" id="L290">                    buf.writeInt(r.getErrorCode());</span>
<span class="nc" id="L291">                    buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L292">                    buf.writeLong(r.getEntryId());</span>

<span class="nc bnc" id="L294" title="All 2 branches missed.">                    if (isSmallEntry) {</span>
<span class="nc" id="L295">                        buf.writeBytes(rr.getData());</span>
<span class="nc" id="L296">                        rr.release();</span>
<span class="nc" id="L297">                        return buf;</span>
                    } else {
<span class="nc" id="L299">                        return ByteBufList.get(buf, rr.getData());</span>
                    }
<span class="nc bnc" id="L301" title="All 2 branches missed.">                } else if (msg instanceof BookieProtocol.BatchedReadResponse) {</span>
<span class="nc" id="L302">                    BookieProtocol.BatchedReadResponse brr = (BookieProtocol.BatchedReadResponse) r;</span>
<span class="nc" id="L303">                    int payloadSize = brr.getData().readableBytes();</span>
<span class="nc" id="L304">                    int delimiterSize = brr.getData().size() * 4; // The size of each entry.</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                    boolean isSmallEntry = (payloadSize + delimiterSize) &lt; SMALL_ENTRY_SIZE_THRESHOLD;</span>

<span class="nc" id="L307">                    int responseSize = RESPONSE_HEADERS_SIZE + 8 /* request_id */ + payloadSize + delimiterSize;</span>
<span class="nc" id="L308">                    int bufferSize = 4 /* frame size */ + responseSize;</span>
<span class="nc" id="L309">                    ByteBuf buf = allocator.buffer(bufferSize);</span>
<span class="nc" id="L310">                    buf.writeInt(responseSize);</span>
<span class="nc" id="L311">                    buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), (short) 0));</span>
<span class="nc" id="L312">                    buf.writeInt(r.getErrorCode());</span>
<span class="nc" id="L313">                    buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L314">                    buf.writeLong(r.getEntryId());</span>
<span class="nc" id="L315">                    buf.writeLong(((BookieProtocol.BatchedReadResponse) r).getRequestId());</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                    if (isSmallEntry) {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                        for (int i = 0; i &lt; brr.getData().size(); i++) {</span>
<span class="nc" id="L318">                            ByteBuf entryData = brr.getData().getBuffer(i);</span>
<span class="nc" id="L319">                            buf.writeInt(entryData.readableBytes());</span>
<span class="nc" id="L320">                            buf.writeBytes(entryData);</span>
                        }
<span class="nc" id="L322">                        brr.release();</span>
<span class="nc" id="L323">                        return buf;</span>
                    } else {
<span class="nc" id="L325">                        ByteBufList byteBufList = ByteBufList.get(buf);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                        for (int i = 0; i &lt; brr.getData().size(); i++) {</span>
<span class="nc" id="L327">                            ByteBuf entryData = brr.getData().getBuffer(i);</span>
<span class="nc" id="L328">                            ByteBuf entryLengthBuf = allocator.buffer(4);</span>
<span class="nc" id="L329">                            entryLengthBuf.writeInt(entryData.readableBytes());</span>
<span class="nc" id="L330">                            byteBufList.add(entryLengthBuf);</span>
<span class="nc" id="L331">                            byteBufList.add(entryData);</span>
                        }
<span class="nc" id="L333">                        return byteBufList;</span>
                    }
<span class="nc bnc" id="L335" title="All 2 branches missed.">                } else if (msg instanceof BookieProtocol.AddResponse) {</span>
<span class="nc" id="L336">                    ByteBuf buf = allocator.buffer(RESPONSE_HEADERS_SIZE + 4 /* frame size */);</span>
<span class="nc" id="L337">                    buf.writeInt(RESPONSE_HEADERS_SIZE);</span>
<span class="nc" id="L338">                    buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), (short) 0));</span>
<span class="nc" id="L339">                    buf.writeInt(r.getErrorCode());</span>
<span class="nc" id="L340">                    buf.writeLong(r.getLedgerId());</span>
<span class="nc" id="L341">                    buf.writeLong(r.getEntryId());</span>
<span class="nc" id="L342">                    return buf;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                } else if (msg instanceof BookieProtocol.AuthResponse) {</span>
<span class="nc" id="L344">                    BookkeeperProtocol.AuthMessage am = ((BookieProtocol.AuthResponse) r).getAuthMessage();</span>
<span class="nc" id="L345">                    int payloadSize = 4 + am.getSerializedSize();</span>
<span class="nc" id="L346">                    int bufferSize = payloadSize + 4 /* frame size */;</span>

<span class="nc" id="L348">                    ByteBuf buf = allocator.buffer(bufferSize);</span>
<span class="nc" id="L349">                    buf.writeInt(payloadSize);</span>
<span class="nc" id="L350">                    buf.writeInt(PacketHeader.toInt(r.getProtocolVersion(), r.getOpCode(), (short) 0));</span>
<span class="nc" id="L351">                    buf.writeBytes(am.toByteArray());</span>
<span class="nc" id="L352">                    return buf;</span>
                } else {
<span class="nc" id="L354">                    LOG.error(&quot;Cannot encode unknown response type {}&quot;, msg.getClass().getName());</span>
<span class="nc" id="L355">                    return msg;</span>
                }
            } finally {
<span class="nc" id="L358">                r.recycle();</span>
            }
        }
        @Override
        public Object decode(ByteBuf buffer)
                throws Exception {
            int rc;
            long ledgerId, entryId;

<span class="nc" id="L367">            int packetHeader = buffer.readInt();</span>
<span class="nc" id="L368">            byte version = PacketHeader.getVersion(packetHeader);</span>
<span class="nc" id="L369">            byte opCode = PacketHeader.getOpCode(packetHeader);</span>

<span class="nc bnc" id="L371" title="All 5 branches missed.">            switch (opCode) {</span>
            case BookieProtocol.ADDENTRY:
<span class="nc" id="L373">                rc = buffer.readInt();</span>
<span class="nc" id="L374">                ledgerId = buffer.readLong();</span>
<span class="nc" id="L375">                entryId = buffer.readLong();</span>
<span class="nc" id="L376">                return BookieProtocol.AddResponse.create(version, rc, ledgerId, entryId);</span>
            case BookieProtocol.READENTRY:
<span class="nc" id="L378">                rc = buffer.readInt();</span>
<span class="nc" id="L379">                ledgerId = buffer.readLong();</span>
<span class="nc" id="L380">                entryId = buffer.readLong();</span>

<span class="nc" id="L382">                return new BookieProtocol.ReadResponse(</span>
<span class="nc" id="L383">                        version, rc, ledgerId, entryId, buffer.retainedSlice());</span>
            case BookieProtocol.BATCH_READ_ENTRY:
<span class="nc" id="L385">                rc = buffer.readInt();</span>
<span class="nc" id="L386">                ledgerId = buffer.readLong();</span>
<span class="nc" id="L387">                entryId = buffer.readLong();</span>
<span class="nc" id="L388">                long requestId = buffer.readLong();</span>
<span class="nc" id="L389">                ByteBufList data = null;</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                while (buffer.readableBytes() &gt; 0) {</span>
<span class="nc" id="L391">                    int entrySize = buffer.readInt();</span>
<span class="nc" id="L392">                    int entryPos = buffer.readerIndex();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">                    if (data == null) {</span>
<span class="nc" id="L394">                        data = ByteBufList.get(buffer.retainedSlice(entryPos, entrySize));</span>
<span class="nc" id="L395">                        buffer.readerIndex(entryPos + entrySize);</span>
                    } else {
<span class="nc" id="L397">                        data.add(buffer.retainedSlice(entryPos, entrySize));</span>
<span class="nc" id="L398">                        buffer.readerIndex(entryPos + entrySize);</span>
                    }
<span class="nc" id="L400">                }</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">                return new BookieProtocol.BatchedReadResponse(version, rc, ledgerId, entryId, requestId, data == null</span>
<span class="nc" id="L402">                        ? ByteBufList.get() : data.retain());</span>
            case BookieProtocol.AUTH:
<span class="nc" id="L404">                ByteBufInputStream bufStream = new ByteBufInputStream(buffer);</span>
<span class="nc" id="L405">                BookkeeperProtocol.AuthMessage.Builder builder = BookkeeperProtocol.AuthMessage.newBuilder();</span>
<span class="nc" id="L406">                builder.mergeFrom(bufStream, extensionRegistry);</span>
<span class="nc" id="L407">                BookkeeperProtocol.AuthMessage am = builder.build();</span>
<span class="nc" id="L408">                return new BookieProtocol.AuthResponse(version, am);</span>
            default:
<span class="nc" id="L410">                throw new IllegalStateException(&quot;Received unknown response : op code = &quot; + opCode);</span>
            }
        }

        public static void serializeAddResponseInto(int rc, BookieProtocol.ParsedAddRequest req, ByteBuf buf) {
<span class="nc" id="L415">            buf.writeInt(RESPONSE_HEADERS_SIZE); // Frame size</span>
<span class="nc" id="L416">            buf.writeInt(PacketHeader.toInt(req.getProtocolVersion(), req.getOpCode(), (short) 0));</span>
<span class="nc" id="L417">            buf.writeInt(rc); // rc-code</span>
<span class="nc" id="L418">            buf.writeLong(req.getLedgerId());</span>
<span class="nc" id="L419">            buf.writeLong(req.getEntryId());</span>
<span class="nc" id="L420">        }</span>
    }

    /**
     * A request encoder/decoder for the Bookkeeper protocol version 3.
     */
    public static class RequestEnDecoderV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

<span class="nc" id="L429">        public RequestEnDecoderV3(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L430">            this.extensionRegistry = extensionRegistry;</span>
<span class="nc" id="L431">        }</span>

        @Override
        public Object decode(ByteBuf packet) throws Exception {
<span class="nc" id="L435">            return BookkeeperProtocol.Request.parseFrom(new ByteBufInputStream(packet), extensionRegistry);</span>
        }

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator) throws Exception {
<span class="nc" id="L440">            BookkeeperProtocol.Request request = (BookkeeperProtocol.Request) msg;</span>
<span class="nc" id="L441">            return serializeProtobuf(request, allocator);</span>
        }

    }

    /**
     * A response encoder/decoder for the Bookkeeper protocol version 3.
     */
    public static class ResponseEnDecoderV3 implements EnDecoder {
        final ExtensionRegistry extensionRegistry;

<span class="nc" id="L452">        public ResponseEnDecoderV3(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L453">            this.extensionRegistry = extensionRegistry;</span>
<span class="nc" id="L454">        }</span>

        @Override
        public Object decode(ByteBuf packet) throws Exception {
<span class="nc" id="L458">            return Response.parseFrom(new ByteBufInputStream(packet),</span>
                                                         extensionRegistry);
        }

        @Override
        public Object encode(Object msg, ByteBufAllocator allocator) throws Exception {
<span class="nc" id="L464">            Response response = (Response) msg;</span>
<span class="nc" id="L465">            return serializeProtobuf(response, allocator);</span>
        }

    }

    private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) {
<span class="nc" id="L471">        int size = msg.getSerializedSize();</span>
<span class="nc" id="L472">        int frameSize = size + 4;</span>

        // Protobuf serialization is the last step of the netty pipeline. We used to allocate
        // a heap buffer while serializing and pass it down to netty library.
        // In AbstractChannel#filterOutboundMessage(), netty copies that data to a direct buffer if
        // it is currently in heap (otherwise skips it and uses it directly).
        // Allocating a direct buffer reducing unnecessary CPU cycles for buffer copies in BK client
        // and also helps alleviate pressure off the GC, since there is less memory churn.
        // Bookies aren't usually CPU bound. This change improves READ_ENTRY code paths by a small factor as well.
<span class="nc" id="L481">        ByteBuf buf = allocator.directBuffer(frameSize, frameSize);</span>
<span class="nc" id="L482">        buf.writeInt(size);</span>

        try {
<span class="nc" id="L485">            msg.writeTo(CodedOutputStream.newInstance(buf.nioBuffer(buf.writerIndex(), size)));</span>
<span class="nc" id="L486">        } catch (IOException e) {</span>
            // This is in-memory serialization, should not fail
<span class="nc" id="L488">            throw new RuntimeException(e);</span>
<span class="nc" id="L489">        }</span>

        // Advance writer idx
<span class="nc" id="L492">        buf.writerIndex(frameSize);</span>
<span class="nc" id="L493">        return buf;</span>
    }

    /**
     * A request message encoder.
     */
    @Sharable
    public static class RequestEncoder extends ChannelOutboundHandlerAdapter {

        final EnDecoder reqPreV3;
        final EnDecoder reqV3;

<span class="nc" id="L505">        public RequestEncoder(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L506">            reqPreV3 = new RequestEnDeCoderPreV3(extensionRegistry);</span>
<span class="nc" id="L507">            reqV3 = new RequestEnDecoderV3(extensionRegistry);</span>
<span class="nc" id="L508">        }</span>

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L513">                LOG.trace(&quot;Encode request {} to channel {}.&quot;, msg, ctx.channel());</span>
            }
<span class="nc bnc" id="L515" title="All 4 branches missed.">            if (msg instanceof ByteBuf || msg instanceof ByteBufList) {</span>
<span class="nc" id="L516">                ctx.write(msg, promise);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">            } else if (msg instanceof BookkeeperProtocol.Request) {</span>
<span class="nc" id="L518">                ctx.write(reqV3.encode(msg, ctx.alloc()), promise);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            } else if (msg instanceof BookieProtocol.Request) {</span>
<span class="nc" id="L520">                ctx.write(reqPreV3.encode(msg, ctx.alloc()), promise);</span>
            } else {
<span class="nc" id="L522">                LOG.error(&quot;Invalid request to encode to {}: {}&quot;, ctx.channel(), msg.getClass().getName());</span>
<span class="nc" id="L523">                ctx.write(msg, promise);</span>
            }
<span class="nc" id="L525">        }</span>
    }

    /**
     * A request message decoder.
     */
    @Sharable
    public static class RequestDecoder extends ChannelInboundHandlerAdapter {
        final EnDecoder reqPreV3;
        final EnDecoder reqV3;
        boolean usingV3Protocol;

<span class="nc" id="L537">        RequestDecoder(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L538">            reqPreV3 = new RequestEnDeCoderPreV3(extensionRegistry);</span>
<span class="nc" id="L539">            reqV3 = new RequestEnDecoderV3(extensionRegistry);</span>
<span class="nc" id="L540">            usingV3Protocol = true;</span>
<span class="nc" id="L541">        }</span>

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
<span class="nc bnc" id="L545" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L546">                LOG.trace(&quot;Received request {} from channel {} to decode.&quot;, msg, ctx.channel());</span>
            }
            try {
<span class="nc bnc" id="L549" title="All 2 branches missed.">                if (!(msg instanceof ByteBuf)) {</span>
<span class="nc" id="L550">                    LOG.error(&quot;Received invalid request {} from channel {} to decode.&quot;, msg, ctx.channel());</span>
<span class="nc" id="L551">                    ctx.fireChannelRead(msg);</span>
<span class="nc" id="L552">                    return;</span>
                }
<span class="nc" id="L554">                ByteBuf buffer = (ByteBuf) msg;</span>
<span class="nc" id="L555">                buffer.markReaderIndex();</span>
                Object result;
<span class="nc bnc" id="L557" title="All 2 branches missed.">                if (usingV3Protocol) {</span>
                    try {
<span class="nc" id="L559">                        result = reqV3.decode(buffer);</span>
<span class="nc" id="L560">                    } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L561">                        usingV3Protocol = false;</span>
<span class="nc" id="L562">                        buffer.resetReaderIndex();</span>
<span class="nc" id="L563">                        result = reqPreV3.decode(buffer);</span>
<span class="nc" id="L564">                    }</span>
                } else {
<span class="nc" id="L566">                    result = reqPreV3.decode(buffer);</span>
                }
<span class="nc" id="L568">                ctx.fireChannelRead(result);</span>
            } finally {
<span class="nc" id="L570">                ReferenceCountUtil.release(msg);</span>
            }
<span class="nc" id="L572">        }</span>
    }

    /**
     * A response message encoder.
     */
    @Sharable
    public static class ResponseEncoder extends ChannelOutboundHandlerAdapter {
        final EnDecoder repPreV3;
        final EnDecoder repV3;

<span class="nc" id="L583">        ResponseEncoder(ExtensionRegistry extensionRegistry) {</span>
<span class="nc" id="L584">            repPreV3 = new ResponseEnDeCoderPreV3(extensionRegistry);</span>
<span class="nc" id="L585">            repV3 = new ResponseEnDecoderV3(extensionRegistry);</span>
<span class="nc" id="L586">        }</span>

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
<span class="nc bnc" id="L590" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L591">                LOG.trace(&quot;Encode response {} to channel {}.&quot;, msg, ctx.channel());</span>
            }

<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (msg instanceof ByteBuf) {</span>
<span class="nc" id="L595">                ctx.write(msg, promise);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">            } else if (msg instanceof Response) {</span>
<span class="nc" id="L597">                ctx.write(repV3.encode(msg, ctx.alloc()), promise);</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            } else if (msg instanceof BookieProtocol.Response) {</span>
<span class="nc" id="L599">                ctx.write(repPreV3.encode(msg, ctx.alloc()), promise);</span>
            } else {
<span class="nc" id="L601">                LOG.error(&quot;Invalid response to encode to {}: {}&quot;, ctx.channel(), msg.getClass().getName());</span>
<span class="nc" id="L602">                ctx.write(msg, promise);</span>
            }
<span class="nc" id="L604">        }</span>
    }

    /**
     * A response message decoder.
     */
    @Sharable
    public static class ResponseDecoder extends ChannelInboundHandlerAdapter {
        final EnDecoder repPreV3;
        final EnDecoder repV3;
        final boolean useV2Protocol;
        final boolean tlsEnabled;
        boolean usingV3Protocol;

        ResponseDecoder(ExtensionRegistry extensionRegistry,
                        boolean useV2Protocol,
<span class="nc" id="L620">                        boolean tlsEnabled) {</span>
<span class="nc" id="L621">            this.repPreV3 = new ResponseEnDeCoderPreV3(extensionRegistry);</span>
<span class="nc" id="L622">            this.repV3 = new ResponseEnDecoderV3(extensionRegistry);</span>
<span class="nc" id="L623">            this.useV2Protocol = useV2Protocol;</span>
<span class="nc" id="L624">            this.tlsEnabled = tlsEnabled;</span>
<span class="nc" id="L625">            usingV3Protocol = true;</span>
<span class="nc" id="L626">        }</span>

        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
<span class="nc bnc" id="L630" title="All 2 branches missed.">            if (LOG.isTraceEnabled()) {</span>
<span class="nc" id="L631">                LOG.trace(&quot;Received response {} from channel {} to decode.&quot;, msg, ctx.channel());</span>
            }
            try {
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if (!(msg instanceof ByteBuf)) {</span>
<span class="nc" id="L635">                    LOG.error(&quot;Received invalid response {} from channel {} to decode.&quot;, msg, ctx.channel());</span>
<span class="nc" id="L636">                    ctx.fireChannelRead(msg);</span>
<span class="nc" id="L637">                    return;</span>
                }
<span class="nc" id="L639">                ByteBuf buffer = (ByteBuf) msg;</span>
<span class="nc" id="L640">                buffer.markReaderIndex();</span>

                Object result;
<span class="nc bnc" id="L643" title="All 2 branches missed.">                if (!useV2Protocol) { // always use v3 protocol</span>
<span class="nc" id="L644">                    result = repV3.decode(buffer);</span>
                } else { // use v2 protocol but
                    // if TLS enabled, the first message `startTLS` is a protobuf message
<span class="nc bnc" id="L647" title="All 4 branches missed.">                    if (tlsEnabled &amp;&amp; usingV3Protocol) {</span>
                        try {
<span class="nc" id="L649">                            result = repV3.decode(buffer);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">                            if (result instanceof Response</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">                                &amp;&amp; OperationType.START_TLS == ((Response) result).getHeader().getOperation()) {</span>
<span class="nc" id="L652">                                usingV3Protocol = false;</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L654">                                    LOG.debug(&quot;Degrade bookkeeper to v2 after starting TLS.&quot;);</span>
                                }
                            }
<span class="nc" id="L657">                        } catch (InvalidProtocolBufferException e) {</span>
<span class="nc" id="L658">                            usingV3Protocol = false;</span>
<span class="nc" id="L659">                            buffer.resetReaderIndex();</span>
<span class="nc" id="L660">                            result = repPreV3.decode(buffer);</span>
<span class="nc" id="L661">                        }</span>
                    } else {
<span class="nc" id="L663">                        result = repPreV3.decode(buffer);</span>
                    }
                }
<span class="nc" id="L666">                ctx.fireChannelRead(result);</span>
            } finally {
<span class="nc" id="L668">                ReferenceCountUtil.release(msg);</span>
            }
<span class="nc" id="L670">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>