<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HardLink.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.util</a> &gt; <span class="el_source">HardLink.java</span></div><h1>HardLink.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* Copied wholesale from hadoop-common 0.23.1
package org.apache.hadoop.fs;
*/
package org.apache.bookkeeper.util;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.google.common.annotations.VisibleForTesting;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicBoolean;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class for creating hardlinks.
 * Supports Unix/Linux, WinXP/2003/Vista via Cygwin, and Mac OS X.
 *
 * &lt;p&gt;The HardLink class was formerly a static inner class of FSUtil,
 * and the methods provided were blatantly non-thread-safe.
 * To enable volume-parallel Update snapshots, we now provide static
 * threadsafe methods that allocate new buffer string arrays
 * upon each call.  We also provide an API to hardlink all files in a
 * directory with a single command, which is up to 128 times more
 * efficient - and minimizes the impact of the extra buffer creations.
 */
public class HardLink {
<span class="nc" id="L51">  private static final Logger LOG = LoggerFactory.getLogger(HardLink.class);</span>
  /**
   * OS Types.
   */
<span class="nc" id="L55">  public enum OSType {</span>
<span class="nc" id="L56">    OS_TYPE_UNIX,</span>
<span class="nc" id="L57">    OS_TYPE_WINXP,</span>
<span class="nc" id="L58">    OS_TYPE_SOLARIS,</span>
<span class="nc" id="L59">    OS_TYPE_MAC</span>
  }

  public static final OSType OS_TYPE;
  private static HardLinkCommandGetter getHardLinkCommand;

  public final LinkStats linkStats; //not static

  //initialize the command &quot;getters&quot; statically, so can use their
  //methods without instantiating the HardLink object
  static {
<span class="nc" id="L70">    OS_TYPE = getOSType();</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">    if (OS_TYPE == OSType.OS_TYPE_WINXP) {</span>
      // Windows
<span class="nc" id="L73">      getHardLinkCommand = new HardLinkCGWin();</span>
    } else {
      // Unix
<span class="nc" id="L76">      getHardLinkCommand = new HardLinkCGUnix();</span>
      //override getLinkCountCommand for the particular Unix variant
      //Linux is already set as the default - {&quot;stat&quot;,&quot;-c%h&quot;, null}
<span class="nc bnc" id="L79" title="All 2 branches missed.">      if (OS_TYPE == OSType.OS_TYPE_MAC) {</span>
<span class="nc" id="L80">        String[] linkCountCmdTemplate = {&quot;stat&quot;, &quot;-f%l&quot;, null};</span>
<span class="nc" id="L81">        HardLinkCGUnix.setLinkCountCmdTemplate(linkCountCmdTemplate);</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">      } else if (OS_TYPE == OSType.OS_TYPE_SOLARIS) {</span>
<span class="nc" id="L83">        String[] linkCountCmdTemplate = {&quot;ls&quot;, &quot;-l&quot;, null};</span>
<span class="nc" id="L84">        HardLinkCGUnix.setLinkCountCmdTemplate(linkCountCmdTemplate);</span>
      }
    }
  }

<span class="nc" id="L89">  public HardLink() {</span>
<span class="nc" id="L90">    linkStats = new LinkStats();</span>
<span class="nc" id="L91">  }</span>

  private static OSType getOSType() {
<span class="nc" id="L94">    String osName = System.getProperty(&quot;os.name&quot;);</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">    if (osName.contains(&quot;Windows&quot;) &amp;&amp; (osName.contains(&quot;XP&quot;)</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">            || osName.contains(&quot;2003&quot;)</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            || osName.contains(&quot;Vista&quot;)</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">            || osName.contains(&quot;Windows_7&quot;)</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">            || osName.contains(&quot;Windows 7&quot;)</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">            || osName.contains(&quot;Windows7&quot;))) {</span>
<span class="nc" id="L101">      return OSType.OS_TYPE_WINXP;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">    } else if (osName.contains(&quot;SunOS&quot;)</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            || osName.contains(&quot;Solaris&quot;)) {</span>
<span class="nc" id="L104">       return OSType.OS_TYPE_SOLARIS;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">    } else if (osName.contains(&quot;Mac&quot;)) {</span>
<span class="nc" id="L106">       return OSType.OS_TYPE_MAC;</span>
    } else {
<span class="nc" id="L108">      return OSType.OS_TYPE_UNIX;</span>
    }
  }

  /**
   * This abstract class bridges the OS-dependent implementations of the
   * needed functionality for creating hardlinks and querying link counts.
   * The particular implementation class is chosen during
   * static initialization phase of the HardLink class.
   * The &quot;getter&quot; methods construct shell command strings for various purposes.
   */
  private abstract static class HardLinkCommandGetter {

    /**
     * Get the command string needed to hardlink a bunch of files from
     * a single source directory into a target directory.  The source directory
     * is not specified here, but the command will be executed using the source
     * directory as the &quot;current working directory&quot; of the shell invocation.
     *
     * @param fileBaseNames - array of path-less file names, relative
     *            to the source directory
     * @param linkDir - target directory where the hardlinks will be put
     * @return - an array of Strings suitable for use as a single shell command
     *            with {@code Runtime.exec()}
     * @throws IOException - if any of the file or path names misbehave
     */
    abstract String[] linkMult(String[] fileBaseNames, File linkDir)
                          throws IOException;

    /**
     * Get the command string needed to hardlink a single file.
     */
    abstract String[] linkOne(File file, File linkName) throws IOException;

    /**
     * Get the command string to query the hardlink count of a file.
     */
    abstract String[] linkCount(File file) throws IOException;

    /**
     * Calculate the total string length of the shell command
     * resulting from execution of linkMult, plus the length of the
     * source directory name (which will also be provided to the shell).
     *
     * @param fileDir - source directory, parent of fileBaseNames
     * @param fileBaseNames - array of path-less file names, relative
     *            to the source directory
     * @param linkDir - target directory where the hardlinks will be put
     * @return - total data length (must not exceed maxAllowedCmdArgLength)
     * @throws IOException
     */
    abstract int getLinkMultArgLength(
                     File fileDir, String[] fileBaseNames, File linkDir)
                     throws IOException;

    /**
     * Get the maximum allowed string length of a shell command on this OS,
     * which is just the documented minimum guaranteed supported command
     * length - aprx. 32KB for Unix, and 8KB for Windows.
     */
    abstract int getMaxAllowedCmdArgLength();
  }

  /**
   * Implementation of HardLinkCommandGetter class for Unix.
   */
<span class="nc" id="L174">  static class HardLinkCGUnix extends HardLinkCommandGetter {</span>
<span class="nc" id="L175">    private static String[] hardLinkCommand = {&quot;ln&quot;, null, null};</span>
<span class="nc" id="L176">    private static String[] hardLinkMultPrefix = {&quot;ln&quot;};</span>
<span class="nc" id="L177">    private static String[] hardLinkMultSuffix = {null};</span>
<span class="nc" id="L178">    private static String[] getLinkCountCommand = {&quot;stat&quot;, &quot;-c%h&quot;, null};</span>
    //Unix guarantees at least 32K bytes cmd length.
    //Subtract another 64b to allow for Java 'exec' overhead
    private static final int maxAllowedCmdArgLength = 32 * 1024 - 65;

    private static synchronized
    void setLinkCountCmdTemplate(String[] template) {
      //May update this for specific unix variants,
      //after static initialization phase
<span class="nc" id="L187">      getLinkCountCommand = template;</span>
<span class="nc" id="L188">    }</span>

    /*
     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkOne(java.io.File, java.io.File)
     */
    @Override
    String[] linkOne(File file, File linkName)
    throws IOException {
<span class="nc" id="L196">      String[] buf = new String[hardLinkCommand.length];</span>
<span class="nc" id="L197">      System.arraycopy(hardLinkCommand, 0, buf, 0, hardLinkCommand.length);</span>
      //unix wants argument order: &quot;ln &lt;existing&gt; &lt;new&gt;&quot;
<span class="nc" id="L199">      buf[1] = makeShellPath(file);</span>
<span class="nc" id="L200">      buf[2] = makeShellPath(linkName);</span>
<span class="nc" id="L201">      return buf;</span>
    }

    /*
     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkMult(java.lang.String[], java.io.File)
     */
    @Override
    String[] linkMult(String[] fileBaseNames, File linkDir)
    throws IOException {
<span class="nc" id="L210">      String[] buf = new String[fileBaseNames.length</span>
                                + hardLinkMultPrefix.length
                                + hardLinkMultSuffix.length];
<span class="nc" id="L213">      int mark = 0;</span>
<span class="nc" id="L214">      System.arraycopy(hardLinkMultPrefix, 0, buf, mark,</span>
                       hardLinkMultPrefix.length);
<span class="nc" id="L216">      mark += hardLinkMultPrefix.length;</span>
<span class="nc" id="L217">      System.arraycopy(fileBaseNames, 0, buf, mark, fileBaseNames.length);</span>
<span class="nc" id="L218">      mark += fileBaseNames.length;</span>
<span class="nc" id="L219">      buf[mark] = makeShellPath(linkDir);</span>
<span class="nc" id="L220">      return buf;</span>
    }

    /*
     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkCount(java.io.File)
     */
    @Override
    String[] linkCount(File file)
    throws IOException {
<span class="nc" id="L229">      String[] buf = new String[getLinkCountCommand.length];</span>
<span class="nc" id="L230">      System.arraycopy(getLinkCountCommand, 0, buf, 0,</span>
                       getLinkCountCommand.length);
<span class="nc" id="L232">      buf[getLinkCountCommand.length - 1] = makeShellPath(file);</span>
<span class="nc" id="L233">      return buf;</span>
    }

    /*
     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#getLinkMultArgLength(File, String[], File)
     */
    @Override
    int getLinkMultArgLength(File fileDir, String[] fileBaseNames, File linkDir)
    throws IOException{
<span class="nc" id="L242">      int sum = 0;</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">      for (String x : fileBaseNames) {</span>
        // add 1 to account for terminal null or delimiter space
<span class="nc bnc" id="L245" title="All 2 branches missed.">        sum += 1 + ((x == null) ? 0 : x.length());</span>
      }
<span class="nc" id="L247">      sum += 2 + makeShellPath(fileDir).length()</span>
<span class="nc" id="L248">             + makeShellPath(linkDir).length();</span>
      //add the fixed overhead of the hardLinkMult prefix and suffix
<span class="nc" id="L250">      sum += 3; //length(&quot;ln&quot;) + 1</span>
<span class="nc" id="L251">      return sum;</span>
    }

    /*
     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#getMaxAllowedCmdArgLength()
     */
    @Override
    int getMaxAllowedCmdArgLength() {
<span class="nc" id="L259">      return maxAllowedCmdArgLength;</span>
    }
  }

  /**
   * Implementation of HardLinkCommandGetter class for Windows.
   *
   * &lt;p&gt;Note that the linkCount shell command for Windows is actually
   * a Cygwin shell command, and depends on ${cygwin}/bin
   * being in the Windows PATH environment variable, so
   * stat.exe can be found.
   */
<span class="nc" id="L271">  static class HardLinkCGWin extends HardLinkCommandGetter {</span>
    //The Windows command getter impl class and its member fields are
    //package-private (&quot;default&quot;) access instead of &quot;private&quot; to assist
    //unit testing (sort of) on non-Win servers

<span class="nc" id="L276">    static String[] hardLinkCommand = {</span>
                        &quot;fsutil&quot;, &quot;hardlink&quot;, &quot;create&quot;, null, null};
<span class="nc" id="L278">    static String[] hardLinkMultPrefix = {</span>
                        &quot;cmd&quot;, &quot;/q&quot;, &quot;/c&quot;, &quot;for&quot;, &quot;%f&quot;, &quot;in&quot;, &quot;(&quot;};
<span class="nc" id="L280">    static String   hardLinkMultDir = &quot;\\%f&quot;;</span>
<span class="nc" id="L281">    static String[] hardLinkMultSuffix = {</span>
                        &quot;)&quot;, &quot;do&quot;, &quot;fsutil&quot;, &quot;hardlink&quot;, &quot;create&quot;, null,
                        &quot;%f&quot;, &quot;1&gt;NUL&quot;};
<span class="nc" id="L284">    static String[] getLinkCountCommand = {&quot;stat&quot;, &quot;-c%h&quot;, null};</span>
    //Windows guarantees only 8K - 1 bytes cmd length.
    //Subtract another 64b to allow for Java 'exec' overhead
    private static final int maxAllowedCmdArgLength = 8 * 1024 - 65;

    /*
     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkOne(java.io.File, java.io.File)
     */
    @Override
    String[] linkOne(File file, File linkName)
    throws IOException {
<span class="nc" id="L295">      String[] buf = new String[hardLinkCommand.length];</span>
<span class="nc" id="L296">      System.arraycopy(hardLinkCommand, 0, buf, 0, hardLinkCommand.length);</span>
      //windows wants argument order: &quot;create &lt;new&gt; &lt;existing&gt;&quot;
<span class="nc" id="L298">      buf[4] = file.getCanonicalPath();</span>
<span class="nc" id="L299">      buf[3] = linkName.getCanonicalPath();</span>
<span class="nc" id="L300">      return buf;</span>
    }

    /*
     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkMult(java.lang.String[], java.io.File)
     */
    @Override
    String[] linkMult(String[] fileBaseNames, File linkDir)
    throws IOException {
<span class="nc" id="L309">      String[] buf = new String[fileBaseNames.length</span>
                                + hardLinkMultPrefix.length
                                + hardLinkMultSuffix.length];
<span class="nc" id="L312">      String td = linkDir.getCanonicalPath() + hardLinkMultDir;</span>
<span class="nc" id="L313">      int mark = 0;</span>
<span class="nc" id="L314">      System.arraycopy(hardLinkMultPrefix, 0, buf, mark,</span>
                       hardLinkMultPrefix.length);
<span class="nc" id="L316">      mark += hardLinkMultPrefix.length;</span>
<span class="nc" id="L317">      System.arraycopy(fileBaseNames, 0, buf, mark, fileBaseNames.length);</span>
<span class="nc" id="L318">      mark += fileBaseNames.length;</span>
<span class="nc" id="L319">      System.arraycopy(hardLinkMultSuffix, 0, buf, mark,</span>
                       hardLinkMultSuffix.length);
<span class="nc" id="L321">      mark += hardLinkMultSuffix.length;</span>
<span class="nc" id="L322">      buf[mark - 3] = td;</span>
<span class="nc" id="L323">      return buf;</span>
    }

    /*
     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#linkCount(java.io.File)
     */
    @Override
    String[] linkCount(File file)
    throws IOException {
<span class="nc" id="L332">      String[] buf = new String[getLinkCountCommand.length];</span>
<span class="nc" id="L333">      System.arraycopy(getLinkCountCommand, 0, buf, 0,</span>
                       getLinkCountCommand.length);
      //The linkCount command is actually a Cygwin shell command,
      //not a Windows shell command, so we should use &quot;makeShellPath()&quot;
      //instead of &quot;getCanonicalPath()&quot;.  However, that causes another
      //shell exec to &quot;cygpath.exe&quot;, and &quot;stat.exe&quot; actually can handle
      //DOS-style paths (it just prints a couple hundred bytes of warning
      //to stderr), so we use the more efficient &quot;getCanonicalPath()&quot;.
<span class="nc" id="L341">      buf[getLinkCountCommand.length - 1] = file.getCanonicalPath();</span>
<span class="nc" id="L342">      return buf;</span>
    }

    /*
     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#getLinkMultArgLength(File, String[], File)
     */
    @Override
    int getLinkMultArgLength(File fileDir, String[] fileBaseNames, File linkDir)
    throws IOException {
<span class="nc" id="L351">      int sum = 0;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">      for (String x : fileBaseNames) {</span>
        // add 1 to account for terminal null or delimiter space
<span class="nc bnc" id="L354" title="All 2 branches missed.">        sum += 1 + ((x == null) ? 0 : x.length());</span>
      }
<span class="nc" id="L356">      sum += 2 + fileDir.getCanonicalPath().length() + linkDir.getCanonicalPath().length();</span>
      //add the fixed overhead of the hardLinkMult command
      //(prefix, suffix, and Dir suffix)
<span class="nc" id="L359">      sum += (&quot;cmd.exe /q /c for %f in ( ) do &quot;</span>
<span class="nc" id="L360">              + &quot;fsutil hardlink create \\%f %f 1&gt;NUL &quot;).length();</span>
<span class="nc" id="L361">      return sum;</span>
    }

    /*
     * @see org.apache.hadoop.fs.HardLink.HardLinkCommandGetter#getMaxAllowedCmdArgLength()
     */
    @Override
    int getMaxAllowedCmdArgLength() {
<span class="nc" id="L369">      return maxAllowedCmdArgLength;</span>
    }
  }

  /**
   * Calculate the nominal length of all contributors to the total
   * commandstring length, including fixed overhead of the OS-dependent
   * command.  It's protected rather than private, to assist unit testing,
   * but real clients are not expected to need it -- see the way
   * createHardLinkMult() uses it internally so the user doesn't need to worry
   * about it.
   *
   * @param fileDir - source directory, parent of fileBaseNames
   * @param fileBaseNames - array of path-less file names, relative
   *            to the source directory
   * @param linkDir - target directory where the hardlinks will be put
   * @return - total data length (must not exceed maxAllowedCmdArgLength)
   * @throws IOException
   */
  protected static int getLinkMultArgLength(
          File fileDir, String[] fileBaseNames, File linkDir)
  throws IOException {
<span class="nc" id="L391">    return getHardLinkCommand.getLinkMultArgLength(fileDir,</span>
          fileBaseNames, linkDir);
  }

  /**
   * Return this private value for use by unit tests.
   * Shell commands are not allowed to have a total string length
   * exceeding this size.
   */
  protected static int getMaxAllowedCmdArgLength() {
<span class="nc" id="L401">    return getHardLinkCommand.getMaxAllowedCmdArgLength();</span>
  }

<span class="nc" id="L404">  private static final AtomicBoolean CREATE_LINK_SUPPORTED = new AtomicBoolean(true);</span>

  /*
   * ****************************************************
   * Complexity is above.  User-visible functionality is below
   * ****************************************************
   */

  @VisibleForTesting
  static void enableJdkLinkApi(boolean enable) {
<span class="nc" id="L414">    CREATE_LINK_SUPPORTED.set(enable);</span>
<span class="nc" id="L415">  }</span>

  /**
   * Creates a hardlink.
   * @param file - existing source file
   * @param linkName - desired target link file
   */
  public static void createHardLink(File file, File linkName)
  throws IOException {
<span class="nc bnc" id="L424" title="All 2 branches missed.">    if (file == null) {</span>
<span class="nc" id="L425">      throw new IOException(</span>
          &quot;invalid arguments to createHardLink: source file is null&quot;);
    }
<span class="nc bnc" id="L428" title="All 2 branches missed.">    if (linkName == null) {</span>
<span class="nc" id="L429">      throw new IOException(</span>
          &quot;invalid arguments to createHardLink: link name is null&quot;);
    }

    // if createLink available try first, else fall back to shell command.
<span class="nc bnc" id="L434" title="All 2 branches missed.">    if (CREATE_LINK_SUPPORTED.get()) {</span>
      try {
<span class="nc" id="L436">        Path newFile = Files.createLink(linkName.toPath(), file.toPath());</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        if (newFile.toFile().exists()) {</span>
<span class="nc" id="L438">          return;</span>
        }
<span class="nc" id="L440">      } catch (UnsupportedOperationException e) {</span>
<span class="nc" id="L441">        LOG.error(&quot;createLink not supported&quot;, e);</span>
<span class="nc" id="L442">        CREATE_LINK_SUPPORTED.set(false);</span>
<span class="nc" id="L443">      } catch (IOException e) {</span>
<span class="nc" id="L444">        LOG.error(&quot;error when create hard link use createLink&quot;, e);</span>
<span class="nc" id="L445">        CREATE_LINK_SUPPORTED.set(false);</span>
<span class="nc" id="L446">      }</span>
    }

    // construct and execute shell command
<span class="nc" id="L450">    String[] hardLinkCommand = getHardLinkCommand.linkOne(file, linkName);</span>
<span class="nc" id="L451">    Process process = Runtime.getRuntime().exec(hardLinkCommand);</span>
    try {
<span class="nc bnc" id="L453" title="All 2 branches missed.">      if (process.waitFor() != 0) {</span>
<span class="nc" id="L454">        String errMsg = new BufferedReader(new InputStreamReader(</span>
<span class="nc" id="L455">                                                   process.getInputStream(), UTF_8)).readLine();</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (errMsg == null) {</span>
<span class="nc" id="L457">            errMsg = &quot;&quot;;</span>
        }
<span class="nc" id="L459">        String inpMsg = new BufferedReader(new InputStreamReader(</span>
<span class="nc" id="L460">                                                   process.getErrorStream(), UTF_8)).readLine();</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (inpMsg == null) {</span>
<span class="nc" id="L462">            inpMsg = &quot;&quot;;</span>
        }
<span class="nc" id="L464">        throw new IOException(errMsg + inpMsg);</span>
      }
<span class="nc" id="L466">    } catch (InterruptedException e) {</span>
<span class="nc" id="L467">      Thread.currentThread().interrupt();</span>
<span class="nc" id="L468">      throw new IOException(e);</span>
    } finally {
<span class="nc" id="L470">      process.destroy();</span>
    }
<span class="nc" id="L472">  }</span>

  /**
   * Creates hardlinks from multiple existing files within one parent
   * directory, into one target directory.
   * @param parentDir - directory containing source files
   * @param fileBaseNames - list of path-less file names, as returned by
   *                        parentDir.list()
   * @param linkDir - where the hardlinks should be put.  It must already exist.
   *
   * If the list of files is too long (overflows maxAllowedCmdArgLength),
   * we will automatically split it into multiple invocations of the
   * underlying method.
   */
  public static void createHardLinkMult(File parentDir, String[] fileBaseNames,
      File linkDir) throws IOException {
    //This is the public method all non-test clients are expected to use.
    //Normal case - allow up to maxAllowedCmdArgLength characters in the cmd
<span class="nc" id="L490">    createHardLinkMult(parentDir, fileBaseNames, linkDir,</span>
<span class="nc" id="L491">                       getHardLinkCommand.getMaxAllowedCmdArgLength());</span>
<span class="nc" id="L492">  }</span>

  /*
   * Implements {@link createHardLinkMult} with added variable  &quot;maxLength&quot;,
   * to ease unit testing of the auto-splitting feature for long lists.
   * Likewise why it returns &quot;callCount&quot;, the number of sub-arrays that
   * the file list had to be split into.
   * Non-test clients are expected to call the public method instead.
   */
  protected static int createHardLinkMult(File parentDir,
      String[] fileBaseNames, File linkDir, int maxLength)
  throws IOException {
<span class="nc bnc" id="L504" title="All 2 branches missed.">    if (parentDir == null) {</span>
<span class="nc" id="L505">      throw new IOException(</span>
          &quot;invalid arguments to createHardLinkMult: parent directory is null&quot;);
    }
<span class="nc bnc" id="L508" title="All 2 branches missed.">    if (linkDir == null) {</span>
<span class="nc" id="L509">      throw new IOException(</span>
          &quot;invalid arguments to createHardLinkMult: link directory is null&quot;);
    }
<span class="nc bnc" id="L512" title="All 2 branches missed.">    if (fileBaseNames == null) {</span>
<span class="nc" id="L513">      throw new IOException(</span>
          &quot;invalid arguments to createHardLinkMult: &quot;
          + &quot;filename list can be empty but not null&quot;);
    }
<span class="nc bnc" id="L517" title="All 2 branches missed.">    if (fileBaseNames.length == 0) {</span>
      //the OS cmds can't handle empty list of filenames,
      //but it's legal, so just return.
<span class="nc" id="L520">      return 0;</span>
    }
<span class="nc bnc" id="L522" title="All 2 branches missed.">    if (!linkDir.exists()) {</span>
<span class="nc" id="L523">      throw new FileNotFoundException(linkDir + &quot; not found.&quot;);</span>
    }

    //if the list is too long, split into multiple invocations
<span class="nc" id="L527">    int callCount = 0;</span>
<span class="nc bnc" id="L528" title="All 4 branches missed.">    if (getLinkMultArgLength(parentDir, fileBaseNames, linkDir) &gt; maxLength</span>
          &amp;&amp; fileBaseNames.length &gt; 1) {
<span class="nc" id="L530">      String[] list1 = Arrays.copyOf(fileBaseNames, fileBaseNames.length / 2);</span>
<span class="nc" id="L531">      callCount += createHardLinkMult(parentDir, list1, linkDir, maxLength);</span>
<span class="nc" id="L532">      String[] list2 = Arrays.copyOfRange(fileBaseNames, fileBaseNames.length / 2,</span>
          fileBaseNames.length);
<span class="nc" id="L534">      callCount += createHardLinkMult(parentDir, list2, linkDir, maxLength);</span>
<span class="nc" id="L535">      return callCount;</span>
    } else {
<span class="nc" id="L537">      callCount = 1;</span>
    }

    // construct and execute shell command
<span class="nc" id="L541">    String[] hardLinkCommand = getHardLinkCommand.linkMult(fileBaseNames,</span>
        linkDir);
<span class="nc" id="L543">    Process process = Runtime.getRuntime().exec(hardLinkCommand, null,</span>
        parentDir);
    try {
<span class="nc bnc" id="L546" title="All 2 branches missed.">      if (process.waitFor() != 0) {</span>
<span class="nc" id="L547">        String errMsg = new BufferedReader(new InputStreamReader(</span>
<span class="nc" id="L548">                                                   process.getInputStream(), UTF_8)).readLine();</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">        if (errMsg == null) {</span>
<span class="nc" id="L550">            errMsg = &quot;&quot;;</span>
        }
<span class="nc" id="L552">        String inpMsg = new BufferedReader(new InputStreamReader(</span>
<span class="nc" id="L553">                                                   process.getErrorStream(), UTF_8)).readLine();</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (inpMsg == null) {</span>
<span class="nc" id="L555">            inpMsg = &quot;&quot;;</span>
        }
<span class="nc" id="L557">        throw new IOException(errMsg + inpMsg);</span>
      }
<span class="nc" id="L559">    } catch (InterruptedException e) {</span>
<span class="nc" id="L560">      Thread.currentThread().interrupt();</span>
<span class="nc" id="L561">      throw new IOException(e);</span>
    } finally {
<span class="nc" id="L563">      process.destroy();</span>
    }
<span class="nc" id="L565">    return callCount;</span>
  }

   /**
   * Retrieves the number of links to the specified file.
   */
  public static int getLinkCount(File fileName) throws IOException {
<span class="nc bnc" id="L572" title="All 2 branches missed.">    if (fileName == null) {</span>
<span class="nc" id="L573">      throw new IOException(</span>
          &quot;invalid argument to getLinkCount: file name is null&quot;);
    }
<span class="nc bnc" id="L576" title="All 2 branches missed.">    if (!fileName.exists()) {</span>
<span class="nc" id="L577">      throw new FileNotFoundException(fileName + &quot; not found.&quot;);</span>
    }

    // construct and execute shell command
<span class="nc" id="L581">    String[] cmd = getHardLinkCommand.linkCount(fileName);</span>
<span class="nc" id="L582">    String inpMsg = null;</span>
<span class="nc" id="L583">    String errMsg = null;</span>
<span class="nc" id="L584">    int exitValue = -1;</span>
<span class="nc" id="L585">    BufferedReader in = null;</span>
<span class="nc" id="L586">    BufferedReader err = null;</span>

<span class="nc" id="L588">    Process process = Runtime.getRuntime().exec(cmd);</span>
    try {
<span class="nc" id="L590">      exitValue = process.waitFor();</span>
<span class="nc" id="L591">      in = new BufferedReader(new InputStreamReader(</span>
<span class="nc" id="L592">                                      process.getInputStream(), UTF_8));</span>
<span class="nc" id="L593">      inpMsg = in.readLine();</span>
<span class="nc" id="L594">      err = new BufferedReader(new InputStreamReader(</span>
<span class="nc" id="L595">                                       process.getErrorStream(), UTF_8));</span>
<span class="nc" id="L596">      errMsg = err.readLine();</span>
<span class="nc bnc" id="L597" title="All 4 branches missed.">      if (inpMsg == null || exitValue != 0) {</span>
<span class="nc" id="L598">        throw createIOException(fileName, inpMsg, errMsg, exitValue, null);</span>
      }
<span class="nc bnc" id="L600" title="All 2 branches missed.">      if (OS_TYPE == OSType.OS_TYPE_SOLARIS) {</span>
<span class="nc" id="L601">        String[] result = inpMsg.split(&quot;\\s+&quot;);</span>
<span class="nc" id="L602">        return Integer.parseInt(result[1]);</span>
      } else {
<span class="nc" id="L604">        return Integer.parseInt(inpMsg);</span>
      }
<span class="nc" id="L606">    } catch (NumberFormatException e) {</span>
<span class="nc" id="L607">      throw createIOException(fileName, inpMsg, errMsg, exitValue, e);</span>
<span class="nc" id="L608">    } catch (InterruptedException e) {</span>
<span class="nc" id="L609">      Thread.currentThread().interrupt();</span>
<span class="nc" id="L610">      throw createIOException(fileName, inpMsg, errMsg, exitValue, e);</span>
    } finally {
<span class="nc" id="L612">      process.destroy();</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">      if (in != null) {</span>
<span class="nc" id="L614">          in.close();</span>
      }
<span class="nc bnc" id="L616" title="All 2 branches missed.">      if (err != null) {</span>
<span class="nc" id="L617">          err.close();</span>
      }
    }
  }

  /* Create an IOException for failing to get link count. */
  private static IOException createIOException(File f, String message,
      String error, int exitvalue, Exception cause) {

<span class="nc" id="L626">    final String winErrMsg = &quot;; Windows errors in getLinkCount are often due &quot;</span>
         + &quot;to Cygwin misconfiguration&quot;;

<span class="nc" id="L629">    final String s = &quot;Failed to get link count on file &quot; + f</span>
        + &quot;: message=&quot; + message
        + &quot;; error=&quot; + error
<span class="nc bnc" id="L632" title="All 2 branches missed.">        + ((OS_TYPE == OSType.OS_TYPE_WINXP) ? winErrMsg : &quot;&quot;)</span>
        + &quot;; exit value=&quot; + exitvalue;
<span class="nc bnc" id="L634" title="All 2 branches missed.">    return (cause == null) ? new IOException(s) : new IOException(s, cause);</span>
  }

  /**
   * HardLink statistics counters and methods.
   * Not multi-thread safe, obviously.
   * Init is called during HardLink instantiation, above.
   *
   * &lt;p&gt;These are intended for use by knowledgeable clients, not internally,
   * because many of the internal methods are static and can't update these
   * per-instance counters.
   */
<span class="nc" id="L646">  public static class LinkStats {</span>
<span class="nc" id="L647">    public int countDirs = 0;</span>
<span class="nc" id="L648">    public int countSingleLinks = 0;</span>
<span class="nc" id="L649">    public int countMultLinks = 0;</span>
<span class="nc" id="L650">    public int countFilesMultLinks = 0;</span>
<span class="nc" id="L651">    public int countEmptyDirs = 0;</span>
<span class="nc" id="L652">    public int countPhysicalFileCopies = 0;</span>

    public void clear() {
<span class="nc" id="L655">      countDirs = 0;</span>
<span class="nc" id="L656">      countSingleLinks = 0;</span>
<span class="nc" id="L657">      countMultLinks = 0;</span>
<span class="nc" id="L658">      countFilesMultLinks = 0;</span>
<span class="nc" id="L659">      countEmptyDirs = 0;</span>
<span class="nc" id="L660">      countPhysicalFileCopies = 0;</span>
<span class="nc" id="L661">    }</span>

    public String report() {
<span class="nc" id="L664">      return &quot;HardLinkStats: &quot; + countDirs + &quot; Directories, including &quot;</span>
      + countEmptyDirs + &quot; Empty Directories, &quot;
      + countSingleLinks
      + &quot; single Link operations, &quot; + countMultLinks
      + &quot; multi-Link operations, linking &quot; + countFilesMultLinks
      + &quot; files, total &quot; + (countSingleLinks + countFilesMultLinks)
      + &quot; linkable files.  Also physically copied &quot;
      + countPhysicalFileCopies + &quot; other files.&quot;;
    }
  }

  /**
   * Convert a os-native filename to a path that works for the shell.
   * @param file The file to convert
   * @return The unix pathname
   * @throws IOException on windows, there can be problems with the subprocess
   */
  public static String makeShellPath(File file) throws IOException {
<span class="nc" id="L682">    String filename = file.getCanonicalPath();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">    if (System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;)) {</span>
<span class="nc" id="L684">      BufferedReader r = null;</span>
      try {
<span class="nc" id="L686">        ProcessBuilder pb = new ProcessBuilder(&quot;cygpath&quot;, &quot;-u&quot;, filename);</span>
<span class="nc" id="L687">        Process p = pb.start();</span>
<span class="nc" id="L688">        int err = p.waitFor();</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (err != 0) {</span>
<span class="nc" id="L690">            throw new IOException(&quot;Couldn't resolve path &quot;</span>
                                  + filename + &quot;(&quot; + err + &quot;)&quot;);
        }
<span class="nc" id="L693">        r = new BufferedReader(new InputStreamReader(p.getInputStream(), UTF_8));</span>
<span class="nc" id="L694">        return r.readLine();</span>
<span class="nc" id="L695">      } catch (InterruptedException ie) {</span>
<span class="nc" id="L696">        Thread.currentThread().interrupt();</span>
<span class="nc" id="L697">        throw new IOException(&quot;Couldn't resolve path &quot; + filename, ie);</span>
      } finally {
<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (r != null) {</span>
<span class="nc" id="L700">          r.close();</span>
        }
      }
    } else {
<span class="nc" id="L704">      return filename;</span>
    }
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>