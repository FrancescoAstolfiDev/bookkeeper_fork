<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ByteBufList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.util</a> &gt; <span class="el_source">ByteBufList.java</span></div><h1>ByteBufList.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.util;

import com.google.common.annotations.VisibleForTesting;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandler.Sharable;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelOutboundHandlerAdapter;
import io.netty.channel.ChannelPromise;
import io.netty.util.AbstractReferenceCounted;
import io.netty.util.Recycler;
import io.netty.util.Recycler.Handle;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.ReferenceCounted;
import java.util.ArrayList;

/**
 * ByteBufList is a holder of a sequence of {@link ByteBuf} objects.
 *
 * &lt;p&gt;This class doesn't trying to mimic the {@link ByteBuf}, but rather exposes itself just like a regular object which
 * will need to be encoded on the channel. There are 2 utility encoders:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #ENCODER}: regular encode that will write all the buffers in the {@link ByteBufList} on the channel&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Example:
 *
 * &lt;pre&gt;
 * bootstrap.handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
 *     public void initChannel(SocketChannel ch) throws Exception {
 *         ChannelPipeline pipeline = ch.pipeline();
 *         pipeline.addLast(&quot;bytebufList&quot;, ByteBufList.ENCODER);
 *         pipeline.addLast(&quot;mainhandler&quot;, MyHandler.class);
 *     }
 * });
 * &lt;/pre&gt;
 *
 * &lt;p&gt;ByteBufList is pooling the instances and uses ref-counting to release them.
 */
public class ByteBufList extends AbstractReferenceCounted {
    private final ArrayList&lt;ByteBuf&gt; buffers;
    private final Handle&lt;ByteBufList&gt; recyclerHandle;

    private static final int INITIAL_LIST_SIZE = 4;

<span class="nc" id="L66">    private static final Recycler&lt;ByteBufList&gt; RECYCLER = new Recycler&lt;ByteBufList&gt;() {</span>
        @Override
        protected ByteBufList newObject(Handle&lt;ByteBufList&gt; handle) {
<span class="nc" id="L69">            return new ByteBufList(handle);</span>
        }
    };

<span class="nc" id="L73">    private ByteBufList(Handle&lt;ByteBufList&gt; recyclerHandle) {</span>
<span class="nc" id="L74">        this.recyclerHandle = recyclerHandle;</span>
<span class="nc" id="L75">        this.buffers = new ArrayList&lt;&gt;(INITIAL_LIST_SIZE);</span>
<span class="nc" id="L76">    }</span>

    /**
     * Get a new {@link ByteBufList} from the pool and assign 2 buffers to it.
     *
     * &lt;p&gt;The buffers b1 and b2 lifecycles are now managed by the ByteBufList: when the {@link ByteBufList} is
     * deallocated, b1 and b2 will be released as well.
     *
     * @param b1
     *            first buffer
     * @param b2
     *            second buffer
     * @return a {@link ByteBufList} instance from the pool
     */
    public static ByteBufList get(ByteBuf b1, ByteBuf b2) {
<span class="nc" id="L91">        ByteBufList buf = get();</span>
<span class="nc" id="L92">        buf.add(b1);</span>
<span class="nc" id="L93">        buf.add(b2);</span>
<span class="nc" id="L94">        return buf;</span>
    }

    /**
     * Get a new {@link ByteBufList} from the pool and assign 1 buffer to it.
     *
     * &lt;p&gt;The buffer b1 lifecycle is now managed by the ByteBufList: when the {@link ByteBufList} is
     * deallocated, b1 will be released as well.
     *
     * @param b1
     *            first buffer
     * @return a {@link ByteBufList} instance from the pool
     */
    public static ByteBufList get(ByteBuf b1) {
<span class="nc" id="L108">        ByteBufList buf = get();</span>
<span class="nc" id="L109">        buf.add(b1);</span>
<span class="nc" id="L110">        return buf;</span>
    }

    /**
     * Get a new {@link ByteBufList} instance from the pool that is the clone of an already existing instance.
     */
    public static ByteBufList clone(ByteBufList other) {
<span class="nc" id="L117">        ByteBufList buf = get();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        for (int i = 0; i &lt; other.buffers.size(); i++) {</span>
            // Create a duplicate of the buffer so that there is no interference from other threads
<span class="nc" id="L120">            buf.add(other.buffers.get(i).retainedDuplicate());</span>
        }
<span class="nc" id="L122">        return buf;</span>
    }

    public static ByteBufList get() {
<span class="nc" id="L126">        ByteBufList buf = RECYCLER.get();</span>
<span class="nc" id="L127">        buf.setRefCnt(1);</span>
<span class="nc" id="L128">        return buf;</span>
    }

    /**
     * Append a {@link ByteBuf} at the end of this {@link ByteBufList}.
     */
    public void add(ByteBuf buf) {
<span class="nc" id="L135">        buffers.add(buf);</span>
<span class="nc" id="L136">    }</span>

    /**
     * Prepend a {@link ByteBuf} at the beginning of this {@link ByteBufList}.
     */
    public void prepend(ByteBuf buf) {
<span class="nc" id="L142">        buffers.add(0, buf);</span>
<span class="nc" id="L143">    }</span>

    /**
     * @return the total amount of readable bytes across all the {@link ByteBuf} included in the list
     */
    public int readableBytes() {
<span class="nc" id="L149">        int readableBytes = 0;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        for (int i = 0; i &lt; buffers.size(); i++) {</span>
<span class="nc" id="L151">            readableBytes += buffers.get(i).readableBytes();</span>
        }
<span class="nc" id="L153">        return readableBytes;</span>
    }

    /**
     * Get access to a particular buffer in the list.
     *
     * @param index
     *            the index of the buffer
     * @return the buffer
     */
    public ByteBuf getBuffer(int index) {
<span class="nc" id="L164">        return buffers.get(index);</span>
    }

    /**
     * @return the number of buffers included in the {@link ByteBufList}
     */
    public int size() {
<span class="nc" id="L171">        return buffers.size();</span>
    }

    /**
     * Write bytes from the current {@link ByteBufList} into a byte array.
     *
     * &lt;p&gt;This won't modify the reader index of the internal buffers.
     *
     * @param dst
     *            the destination byte array
     * @return the number of copied bytes
     */
    public int getBytes(byte[] dst) {
<span class="nc" id="L184">        int copied = 0;</span>
<span class="nc bnc" id="L185" title="All 4 branches missed.">        for (int idx = 0; idx &lt; buffers.size() &amp;&amp; copied &lt; dst.length; idx++) {</span>
<span class="nc" id="L186">            ByteBuf b = buffers.get(idx);</span>
<span class="nc" id="L187">            int len = Math.min(b.readableBytes(), dst.length - copied);</span>
<span class="nc" id="L188">            b.getBytes(b.readerIndex(), dst, copied, len);</span>

<span class="nc" id="L190">            copied += len;</span>
        }

<span class="nc" id="L193">        return copied;</span>
    }

    /**
     * Creates a copy of the readable content of the internal buffers and returns the copy.
     * @return an array containing all the internal buffers content
     */
    public byte[] toArray() {
<span class="nc" id="L201">        byte[] a = new byte[readableBytes()];</span>
<span class="nc" id="L202">        getBytes(a);</span>
<span class="nc" id="L203">        return a;</span>
    }

    /**
     * Returns {@code true} if this buffer has a single backing byte array.
     * If this method returns true, you can safely call {@link #array()} and
     * {@link #arrayOffset()}.
     * @return true, if this {@link ByteBufList} is backed by a single array
     */
    public boolean hasArray() {
<span class="nc bnc" id="L213" title="All 4 branches missed.">        return buffers.size() == 1 &amp;&amp; buffers.get(0).hasArray();</span>
    }

    /**
     * Returns a reference to the array backing this {@link ByteBufList}.
     * This method must only be called if {@link #hasArray()} returns {@code true}.
     * @return the array backing this {@link ByteBufList}
     */
    public byte[] array() {
<span class="nc" id="L222">        return buffers.get(0).array();</span>
    }

    /**
     * Returns the offset of the first byte within the backing byte array of
     * this buffer.
     * This method must only be called if {@link #hasArray()} returns {@code true}.
     * @return the offset of the first byte within the backing byte array.
     */
    public int arrayOffset() {
<span class="nc" id="L232">        return buffers.get(0).arrayOffset();</span>
    }

    /**
     * @return a single buffer with the content of both individual buffers
     */
    @VisibleForTesting
    public static ByteBuf coalesce(ByteBufList list) {
<span class="nc" id="L240">        ByteBuf res = Unpooled.buffer(list.readableBytes());</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        for (int i = 0; i &lt; list.buffers.size(); i++) {</span>
<span class="nc" id="L242">            ByteBuf b = list.buffers.get(i);</span>
<span class="nc" id="L243">            res.writeBytes(b, b.readerIndex(), b.readableBytes());</span>
        }

<span class="nc" id="L246">        return res;</span>
    }

    @Override
    public ByteBufList retain() {
<span class="nc" id="L251">        super.retain();</span>
<span class="nc" id="L252">        return this;</span>
    }

    @Override
    protected void deallocate() {
<span class="nc bnc" id="L257" title="All 2 branches missed.">        for (int i = 0; i &lt; buffers.size(); i++) {</span>
<span class="nc" id="L258">            buffers.get(i).release();</span>
        }

<span class="nc" id="L261">        buffers.clear();</span>
<span class="nc" id="L262">        recyclerHandle.recycle(this);</span>
<span class="nc" id="L263">    }</span>

    @Override
    public ReferenceCounted touch(Object hint) {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        for (int i = 0; i &lt; buffers.size(); i++) {</span>
<span class="nc" id="L268">            buffers.get(i).touch(hint);</span>
        }
<span class="nc" id="L270">        return this;</span>
    }

    /**
     * Encoder for the {@link ByteBufList} that doesn't prepend any size header.
     */
<span class="nc" id="L276">    public static final Encoder ENCODER = new Encoder();</span>

    /**
     * {@link ByteBufList} encoder.
     */
    @Sharable
<span class="nc" id="L282">    public static class Encoder extends ChannelOutboundHandlerAdapter {</span>

        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (msg instanceof ByteBufList) {</span>
<span class="nc" id="L287">                ByteBufList b = (ByteBufList) msg;</span>

<span class="nc" id="L289">                ChannelPromise compositePromise = ctx.newPromise();</span>
<span class="nc" id="L290">                compositePromise.addListener(future -&gt; {</span>
                    // release the ByteBufList after the write operation is completed
<span class="nc" id="L292">                    ReferenceCountUtil.safeRelease(b);</span>
                    // complete the promise passed as an argument unless it's a void promise
<span class="nc bnc" id="L294" title="All 4 branches missed.">                    if (promise != null &amp;&amp; !promise.isVoid()) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                        if (future.isSuccess()) {</span>
<span class="nc" id="L296">                            promise.setSuccess();</span>
                        } else {
<span class="nc" id="L298">                            promise.setFailure(future.cause());</span>
                        }
                    }
<span class="nc" id="L301">                });</span>

                // Write each buffer individually on the socket. The retain() here is needed to preserve the fact
                // that ByteBuf are automatically released after a write. If the ByteBufPair ref count is increased
                // and it gets written multiple times, the individual buffers refcount should be reflected as well.
<span class="nc" id="L306">                int buffersCount = b.buffers.size();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                for (int i = 0; i &lt; buffersCount; i++) {</span>
<span class="nc" id="L308">                    ByteBuf bx = b.buffers.get(i);</span>
                    // Last buffer will carry on the final promise to notify when everything was written on the
                    // socket
<span class="nc bnc" id="L311" title="All 2 branches missed.">                    ctx.write(bx.retainedDuplicate(), i == (buffersCount - 1) ? compositePromise : ctx.voidPromise());</span>
                }
<span class="nc" id="L313">            } else {</span>
<span class="nc" id="L314">                ctx.write(msg, promise);</span>
            }
<span class="nc" id="L316">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>