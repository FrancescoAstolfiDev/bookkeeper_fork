<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultEntryLogger.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie</a> &gt; <span class="el_source">DefaultEntryLogger.java</span></div><h1>DefaultEntryLogger.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.bookkeeper.bookie;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import com.google.common.collect.MapMaker;
import com.google.common.collect.Sets;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.concurrent.FastThreadLocal;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousCloseException;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.regex.Pattern;
import org.apache.bookkeeper.bookie.storage.CompactionEntryLog;
import org.apache.bookkeeper.bookie.storage.EntryLogScanner;
import org.apache.bookkeeper.bookie.storage.EntryLogger;
import org.apache.bookkeeper.conf.ServerConfiguration;
import org.apache.bookkeeper.stats.NullStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.util.DiskChecker;
import org.apache.bookkeeper.util.HardLink;
import org.apache.bookkeeper.util.IOUtils;
import org.apache.bookkeeper.util.LedgerDirUtil;
import org.apache.bookkeeper.util.collections.ConcurrentLongLongHashMap;
import org.apache.bookkeeper.util.collections.ConcurrentLongLongHashMap.BiConsumerLong;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class manages the writing of the bookkeeper entries. All the new
 * entries are written to a common log. The LedgerCache will have pointers
 * into files created by this class with offsets into the files to find
 * the actual ledger entry. The entry log files created by this class are
 * identified by a long.
 */
public class DefaultEntryLogger implements EntryLogger {
<span class="nc" id="L84">    private static final Logger LOG = LoggerFactory.getLogger(DefaultEntryLogger.class);</span>

    @VisibleForTesting
    static final int UNINITIALIZED_LOG_ID = -0xDEAD;

    static class BufferedLogChannel extends BufferedChannel {
        private final long logId;
        private final EntryLogMetadata entryLogMetadata;
        private final File logFile;
<span class="nc" id="L93">        private long ledgerIdAssigned = UNASSIGNED_LEDGERID;</span>

        public BufferedLogChannel(ByteBufAllocator allocator, FileChannel fc, int writeCapacity, int readCapacity,
                long logId, File logFile, long unpersistedBytesBound) throws IOException {
<span class="nc" id="L97">            super(allocator, fc, writeCapacity, readCapacity, unpersistedBytesBound);</span>
<span class="nc" id="L98">            this.logId = logId;</span>
<span class="nc" id="L99">            this.entryLogMetadata = new EntryLogMetadata(logId);</span>
<span class="nc" id="L100">            this.logFile = logFile;</span>
<span class="nc" id="L101">        }</span>
        public long getLogId() {
<span class="nc" id="L103">            return logId;</span>
        }

        public File getLogFile() {
<span class="nc" id="L107">            return logFile;</span>
        }

        public void registerWrittenEntry(long ledgerId, long entrySize) {
<span class="nc" id="L111">            entryLogMetadata.addLedgerSize(ledgerId, entrySize);</span>
<span class="nc" id="L112">        }</span>

        public ConcurrentLongLongHashMap getLedgersMap() {
<span class="nc" id="L115">            return entryLogMetadata.getLedgersMap();</span>
        }

        public Long getLedgerIdAssigned() {
<span class="nc" id="L119">            return ledgerIdAssigned;</span>
        }

        public void setLedgerIdAssigned(Long ledgerId) {
<span class="nc" id="L123">            this.ledgerIdAssigned = ledgerId;</span>
<span class="nc" id="L124">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L128">            return MoreObjects.toStringHelper(BufferedChannel.class)</span>
<span class="nc" id="L129">                .add(&quot;logId&quot;, logId)</span>
<span class="nc" id="L130">                .add(&quot;logFile&quot;, logFile)</span>
<span class="nc" id="L131">                .add(&quot;ledgerIdAssigned&quot;, ledgerIdAssigned)</span>
<span class="nc" id="L132">                .toString();</span>
        }

        /**
         * Append the ledger map at the end of the entry log.
         * Updates the entry log file header with the offset and size of the map.
         */
        void appendLedgersMap() throws IOException {

<span class="nc" id="L141">            long ledgerMapOffset = this.position();</span>

<span class="nc" id="L143">            ConcurrentLongLongHashMap ledgersMap = this.getLedgersMap();</span>
<span class="nc" id="L144">            int numberOfLedgers = (int) ledgersMap.size();</span>

            // Write the ledgers map into several batches

<span class="nc" id="L148">            final int maxMapSize = LEDGERS_MAP_HEADER_SIZE + LEDGERS_MAP_ENTRY_SIZE * LEDGERS_MAP_MAX_BATCH_SIZE;</span>
<span class="nc" id="L149">            final ByteBuf serializedMap = ByteBufAllocator.DEFAULT.buffer(maxMapSize);</span>

            try {
<span class="nc" id="L152">                ledgersMap.forEach(new BiConsumerLong() {</span>
<span class="nc" id="L153">                    int remainingLedgers = numberOfLedgers;</span>
<span class="nc" id="L154">                    boolean startNewBatch = true;</span>
<span class="nc" id="L155">                    int remainingInBatch = 0;</span>

                    @Override
                    public void accept(long ledgerId, long size) {
<span class="nc bnc" id="L159" title="All 2 branches missed.">                        if (startNewBatch) {</span>
<span class="nc" id="L160">                            int batchSize = Math.min(remainingLedgers, LEDGERS_MAP_MAX_BATCH_SIZE);</span>
<span class="nc" id="L161">                            int ledgerMapSize = LEDGERS_MAP_HEADER_SIZE + LEDGERS_MAP_ENTRY_SIZE * batchSize;</span>

<span class="nc" id="L163">                            serializedMap.clear();</span>
<span class="nc" id="L164">                            serializedMap.writeInt(ledgerMapSize - 4);</span>
<span class="nc" id="L165">                            serializedMap.writeLong(INVALID_LID);</span>
<span class="nc" id="L166">                            serializedMap.writeLong(LEDGERS_MAP_ENTRY_ID);</span>
<span class="nc" id="L167">                            serializedMap.writeInt(batchSize);</span>

<span class="nc" id="L169">                            startNewBatch = false;</span>
<span class="nc" id="L170">                            remainingInBatch = batchSize;</span>
                        }
                        // Dump the ledger in the current batch
<span class="nc" id="L173">                        serializedMap.writeLong(ledgerId);</span>
<span class="nc" id="L174">                        serializedMap.writeLong(size);</span>
<span class="nc" id="L175">                        --remainingLedgers;</span>

<span class="nc bnc" id="L177" title="All 2 branches missed.">                        if (--remainingInBatch == 0) {</span>
                            // Close current batch
                            try {
<span class="nc" id="L180">                                write(serializedMap);</span>
<span class="nc" id="L181">                            } catch (IOException e) {</span>
<span class="nc" id="L182">                                throw new RuntimeException(e);</span>
<span class="nc" id="L183">                            }</span>

<span class="nc" id="L185">                            startNewBatch = true;</span>
                        }
<span class="nc" id="L187">                    }</span>
                });
<span class="nc" id="L189">            } catch (RuntimeException e) {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                if (e.getCause() instanceof IOException) {</span>
<span class="nc" id="L191">                    throw (IOException) e.getCause();</span>
                } else {
<span class="nc" id="L193">                    throw e;</span>
                }
            } finally {
<span class="nc" id="L196">                ReferenceCountUtil.release(serializedMap);</span>
            }
            // Flush the ledger's map out before we write the header.
            // Otherwise the header might point to something that is not fully
            // written
<span class="nc" id="L201">            super.flush();</span>

            // Update the headers with the map offset and count of ledgers
<span class="nc" id="L204">            ByteBuffer mapInfo = ByteBuffer.allocate(8 + 4);</span>
<span class="nc" id="L205">            mapInfo.putLong(ledgerMapOffset);</span>
<span class="nc" id="L206">            mapInfo.putInt(numberOfLedgers);</span>
<span class="nc" id="L207">            mapInfo.flip();</span>
<span class="nc" id="L208">            this.fileChannel.write(mapInfo, LEDGERS_MAP_OFFSET_POSITION);</span>
<span class="nc" id="L209">        }</span>
    }

    private final LedgerDirsManager ledgerDirsManager;
    private final boolean entryLogPerLedgerEnabled;

    final RecentEntryLogsStatus recentlyCreatedEntryLogsStatus;

    /**
     * locks for compaction log.
     */
<span class="nc" id="L220">    private final Object compactionLogLock = new Object();</span>

    private volatile BufferedLogChannel compactionLogChannel;

    final EntryLoggerAllocator entryLoggerAllocator;
    private final EntryLogManager entryLogManager;

<span class="nc" id="L227">    private final CopyOnWriteArrayList&lt;EntryLogListener&gt; listeners = new CopyOnWriteArrayList&lt;EntryLogListener&gt;();</span>

    private static final int HEADER_V0 = 0; // Old log file format (no ledgers map index)
    private static final int HEADER_V1 = 1; // Introduced ledger map index
    static final int HEADER_CURRENT_VERSION = HEADER_V1;

    private static class Header {
        final int version;
        final long ledgersMapOffset;
        final int ledgersCount;

<span class="nc" id="L238">        Header(int version, long ledgersMapOffset, int ledgersCount) {</span>
<span class="nc" id="L239">            this.version = version;</span>
<span class="nc" id="L240">            this.ledgersMapOffset = ledgersMapOffset;</span>
<span class="nc" id="L241">            this.ledgersCount = ledgersCount;</span>
<span class="nc" id="L242">        }</span>
    }

    /**
     * The 1K block at the head of the entry logger file
     * that contains the fingerprint and meta-data.
     *
     * &lt;pre&gt;
     * Header is composed of:
     * Fingerprint: 4 bytes &quot;BKLO&quot;
     * Log file HeaderVersion enum: 4 bytes
     * Ledger map offset: 8 bytes
     * Ledgers Count: 4 bytes
     * &lt;/pre&gt;
     */
    static final int LOGFILE_HEADER_SIZE = 1024;
    static final int HEADER_VERSION_POSITION = 4;
    static final int LEDGERS_MAP_OFFSET_POSITION = HEADER_VERSION_POSITION + 4;

    /**
     * Ledgers map is composed of multiple parts that can be split into separated entries. Each of them is composed of:
     *
     * &lt;pre&gt;
     * length: (4 bytes) [0-3]
     * ledger id (-1): (8 bytes) [4 - 11]
     * entry id: (8 bytes) [12-19]
     * num ledgers stored in current metadata entry: (4 bytes) [20 - 23]
     * ledger entries: sequence of (ledgerid, size) (8 + 8 bytes each) [24..]
     * &lt;/pre&gt;
     */
    static final int LEDGERS_MAP_HEADER_SIZE = 4 + 8 + 8 + 4;
    static final int LEDGERS_MAP_ENTRY_SIZE = 8 + 8;

    // Break the ledgers map into multiple batches, each of which can contain up to 10K ledgers
    static final int LEDGERS_MAP_MAX_BATCH_SIZE = 10000;

    static final long INVALID_LID = -1L;

    // EntryId used to mark an entry (belonging to INVALID_ID) as a component of the serialized ledgers map
    static final long LEDGERS_MAP_ENTRY_ID = -2L;

    static final int MIN_SANE_ENTRY_SIZE = 8 + 8;
    static final long MB = 1024 * 1024;

    private final int maxSaneEntrySize;

    private final ByteBufAllocator allocator;

    final ServerConfiguration conf;

    /**
     * Entry Log Listener.
     */
    interface EntryLogListener {
        /**
         * Rotate a new entry log to write.
         */
        void onRotateEntryLog();
    }

    public DefaultEntryLogger(ServerConfiguration conf) throws IOException {
<span class="nc" id="L303">        this(conf, new LedgerDirsManager(conf, conf.getLedgerDirs(),</span>
<span class="nc" id="L304">                new DiskChecker(conf.getDiskUsageThreshold(), conf.getDiskUsageWarnThreshold())));</span>
<span class="nc" id="L305">    }</span>

    /**
     * Create an EntryLogger that stores it's log files in the given directories.
     */
    public DefaultEntryLogger(ServerConfiguration conf,
                              LedgerDirsManager ledgerDirsManager) throws IOException {
<span class="nc" id="L312">        this(conf, ledgerDirsManager, null, NullStatsLogger.INSTANCE, PooledByteBufAllocator.DEFAULT);</span>
<span class="nc" id="L313">    }</span>

    public DefaultEntryLogger(ServerConfiguration conf,
                              LedgerDirsManager ledgerDirsManager, EntryLogListener listener, StatsLogger statsLogger,
<span class="nc" id="L317">                              ByteBufAllocator allocator) throws IOException {</span>
        //We reserve 500 bytes as overhead for the protocol.  This is not 100% accurate
        // but the protocol varies so an exact value is difficult to determine
<span class="nc" id="L320">        this.maxSaneEntrySize = conf.getNettyMaxFrameSizeBytes() - 500;</span>
<span class="nc" id="L321">        this.allocator = allocator;</span>
<span class="nc" id="L322">        this.ledgerDirsManager = ledgerDirsManager;</span>
<span class="nc" id="L323">        this.conf = conf;</span>
<span class="nc" id="L324">        entryLogPerLedgerEnabled = conf.isEntryLogPerLedgerEnabled();</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (listener != null) {</span>
<span class="nc" id="L326">            addListener(listener);</span>
        }

        // Find the largest logId
<span class="nc" id="L330">        long logId = INVALID_LID;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        for (File dir : ledgerDirsManager.getAllLedgerDirs()) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (!dir.exists()) {</span>
<span class="nc" id="L333">                throw new FileNotFoundException(</span>
                        &quot;Entry log directory '&quot; + dir + &quot;' does not exist&quot;);
            }
            long lastLogId;
<span class="nc" id="L337">            long lastLogFileFromFile = getLastLogIdFromFile(dir);</span>
<span class="nc" id="L338">            long lastLogIdInDir = getLastLogIdInDir(dir);</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">            if (lastLogFileFromFile &lt; lastLogIdInDir) {</span>
<span class="nc" id="L340">                LOG.info(&quot;The lastLogFileFromFile is {}, the lastLogIdInDir is {}, &quot;</span>
<span class="nc" id="L341">                        + &quot;use lastLogIdInDir as the lastLogId.&quot;, lastLogFileFromFile, lastLogIdInDir);</span>
<span class="nc" id="L342">                lastLogId = lastLogIdInDir;</span>
            } else {
<span class="nc" id="L344">                lastLogId = lastLogFileFromFile;</span>
            }

<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (lastLogId &gt; logId) {</span>
<span class="nc" id="L348">                logId = lastLogId;</span>
            }
<span class="nc" id="L350">        }</span>
<span class="nc" id="L351">        this.recentlyCreatedEntryLogsStatus = new RecentEntryLogsStatus(logId + 1);</span>
<span class="nc" id="L352">        this.entryLoggerAllocator = new EntryLoggerAllocator(conf, ledgerDirsManager, recentlyCreatedEntryLogsStatus,</span>
                logId, allocator);
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (entryLogPerLedgerEnabled) {</span>
<span class="nc" id="L355">            this.entryLogManager = new EntryLogManagerForEntryLogPerLedger(conf, ledgerDirsManager,</span>
                    entryLoggerAllocator, listeners, recentlyCreatedEntryLogsStatus, statsLogger);
        } else {
<span class="nc" id="L358">            this.entryLogManager = new EntryLogManagerForSingleEntryLog(conf, ledgerDirsManager, entryLoggerAllocator,</span>
                    listeners, recentlyCreatedEntryLogsStatus);
        }
<span class="nc" id="L361">    }</span>

    EntryLogManager getEntryLogManager() {
<span class="nc" id="L364">        return entryLogManager;</span>
    }

    void addListener(EntryLogListener listener) {
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (null != listener) {</span>
<span class="nc" id="L369">            listeners.add(listener);</span>
        }
<span class="nc" id="L371">    }</span>

    /**
     * If the log id of current writable channel is the same as entryLogId and the position
     * we want to read might end up reading from a position in the write buffer of the
     * buffered channel, route this read to the current logChannel. Else,
     * read from the BufferedReadChannel that is provided.
     * @param entryLogId
     * @param channel
     * @param buff remaining() on this bytebuffer tells us the last position that we
     *             expect to read.
     * @param pos The starting position from where we want to read.
     * @return
     */
    private int readFromLogChannel(long entryLogId, BufferedReadChannel channel, ByteBuf buff, long pos)
            throws IOException {
<span class="nc" id="L387">        BufferedLogChannel bc = entryLogManager.getCurrentLogIfPresent(entryLogId);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (null != bc) {</span>
<span class="nc" id="L389">            synchronized (bc) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                if (pos + buff.writableBytes() &gt;= bc.getFileChannelPosition()) {</span>
<span class="nc" id="L391">                    return bc.read(buff, pos);</span>
                }
<span class="nc" id="L393">            }</span>
        }
<span class="nc" id="L395">        return channel.read(buff, pos);</span>
    }

    /**
     * A thread-local variable that wraps a mapping of log ids to bufferedchannels
     * These channels should be used only for reading. logChannel is the one
     * that is used for writes.
     */
<span class="nc" id="L403">    private final ThreadLocal&lt;Map&lt;Long, BufferedReadChannel&gt;&gt; logid2Channel =</span>
<span class="nc" id="L404">            new ThreadLocal&lt;Map&lt;Long, BufferedReadChannel&gt;&gt;() {</span>
        @Override
        public Map&lt;Long, BufferedReadChannel&gt; initialValue() {
            // Since this is thread local there only one modifier
            // We dont really need the concurrency, but we need to use
            // the weak values. Therefore using the concurrency level of 1
<span class="nc" id="L410">            return new MapMaker().concurrencyLevel(1)</span>
<span class="nc" id="L411">                .weakValues()</span>
<span class="nc" id="L412">                .makeMap();</span>
        }
    };

    /**
     * Each thread local buffered read channel can share the same file handle because reads are not relative
     * and don't cause a change in the channel's position. We use this map to store the file channels. Each
     * file channel is mapped to a log id which represents an open log file.
     */
<span class="nc" id="L421">    private final ConcurrentMap&lt;Long, FileChannel&gt; logid2FileChannel = new ConcurrentHashMap&lt;Long, FileChannel&gt;();</span>

    /**
     * Put the logId, bc pair in the map responsible for the current thread.
     * @param logId
     * @param bc
     */
    public BufferedReadChannel putInReadChannels(long logId, BufferedReadChannel bc) {
<span class="nc" id="L429">        Map&lt;Long, BufferedReadChannel&gt; threadMap = logid2Channel.get();</span>
<span class="nc" id="L430">        return threadMap.put(logId, bc);</span>
    }

    /**
     * Remove all entries for this log file in each thread's cache.
     * @param logId
     */
    public void removeFromChannelsAndClose(long logId) {
<span class="nc" id="L438">        FileChannel fileChannel = logid2FileChannel.remove(logId);</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">        if (null != fileChannel) {</span>
            try {
<span class="nc" id="L441">                fileChannel.close();</span>
<span class="nc" id="L442">            } catch (IOException e) {</span>
<span class="nc" id="L443">                LOG.warn(&quot;Exception while closing channel for log file:&quot; + logId);</span>
<span class="nc" id="L444">            }</span>
        }
<span class="nc" id="L446">    }</span>

    public BufferedReadChannel getFromChannels(long logId) {
<span class="nc" id="L449">        return logid2Channel.get().get(logId);</span>
    }

    @VisibleForTesting
    long getLeastUnflushedLogId() {
<span class="nc" id="L454">        return recentlyCreatedEntryLogsStatus.getLeastUnflushedLogId();</span>
    }

    @Override
    public Set&lt;Long&gt; getFlushedLogIds() {
<span class="nc" id="L459">        Set&lt;Long&gt; logIds = new HashSet&lt;&gt;();</span>
<span class="nc" id="L460">        synchronized (recentlyCreatedEntryLogsStatus) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            for (File dir : ledgerDirsManager.getAllLedgerDirs()) {</span>
<span class="nc bnc" id="L462" title="All 4 branches missed.">                if (dir.exists() &amp;&amp; dir.isDirectory()) {</span>
<span class="nc" id="L463">                    File[] files = dir.listFiles(file -&gt; file.getName().endsWith(&quot;.log&quot;));</span>
<span class="nc bnc" id="L464" title="All 4 branches missed.">                    if (files != null &amp;&amp; files.length &gt; 0) {</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">                        for (File f : files) {</span>
<span class="nc" id="L466">                            long logId = fileName2LogId(f.getName());</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                            if (recentlyCreatedEntryLogsStatus.isFlushedLogId(logId)) {</span>
<span class="nc" id="L468">                                logIds.add(logId);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L473">            }</span>
<span class="nc" id="L474">        }</span>
<span class="nc" id="L475">        return logIds;</span>
    }

    long getPreviousAllocatedEntryLogId() {
<span class="nc" id="L479">        return entryLoggerAllocator.getPreallocatedLogId();</span>
    }

    /**
     * Get the current log file for compaction.
     */
    private File getCurCompactionLogFile() {
<span class="nc" id="L486">        synchronized (compactionLogLock) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">            if (compactionLogChannel == null) {</span>
<span class="nc" id="L488">                return null;</span>
            }
<span class="nc" id="L490">            return compactionLogChannel.getLogFile();</span>
        }
    }

    void prepareSortedLedgerStorageCheckpoint(long numBytesFlushed) throws IOException {
<span class="nc" id="L495">        entryLogManager.prepareSortedLedgerStorageCheckpoint(numBytesFlushed);</span>
<span class="nc" id="L496">    }</span>

    void prepareEntryMemTableFlush() {
<span class="nc" id="L499">        entryLogManager.prepareEntryMemTableFlush();</span>
<span class="nc" id="L500">    }</span>

    boolean commitEntryMemTableFlush() throws IOException {
<span class="nc" id="L503">        return entryLogManager.commitEntryMemTableFlush();</span>
    }

    /**
     * get EntryLoggerAllocator, Just for tests.
     */
    EntryLoggerAllocator getEntryLoggerAllocator() {
<span class="nc" id="L510">        return entryLoggerAllocator;</span>
    }

    /**
     * Remove entry log.
     *
     * @param entryLogId
     *          Entry Log File Id
     */
    @Override
    public boolean removeEntryLog(long entryLogId) {
<span class="nc" id="L521">        removeFromChannelsAndClose(entryLogId);</span>
        File entryLogFile;
        try {
<span class="nc" id="L524">            entryLogFile = findFile(entryLogId);</span>
<span class="nc" id="L525">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L526">            LOG.error(&quot;Trying to delete an entryLog file that could not be found: &quot;</span>
                    + entryLogId + &quot;.log&quot;);
<span class="nc" id="L528">            return true;</span>
<span class="nc" id="L529">        }</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        if (!entryLogFile.delete()) {</span>
<span class="nc" id="L531">            LOG.warn(&quot;Could not delete entry log file {}&quot;, entryLogFile);</span>
<span class="nc" id="L532">            return false;</span>
        }
<span class="nc" id="L534">        return true;</span>
    }

    private long getLastLogIdFromFile(File dir) {
<span class="nc" id="L538">        long id = readLastLogId(dir);</span>
        // read success
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (id &gt; 0) {</span>
<span class="nc" id="L541">            return id;</span>
        }
        // read failed, scan the ledger directories to find biggest log id
<span class="nc" id="L544">        File[] logFiles = dir.listFiles(file -&gt; file.getName().endsWith(&quot;.log&quot;));</span>
<span class="nc" id="L545">        List&lt;Long&gt; logs = new ArrayList&lt;Long&gt;();</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (logFiles != null) {</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">            for (File lf : logFiles) {</span>
<span class="nc" id="L548">                long logId = fileName2LogId(lf.getName());</span>
<span class="nc" id="L549">                logs.add(logId);</span>
            }
        }
        // no log file found in this directory
<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (0 == logs.size()) {</span>
<span class="nc" id="L554">            return INVALID_LID;</span>
        }
        // order the collections
<span class="nc" id="L557">        Collections.sort(logs);</span>
<span class="nc" id="L558">        return logs.get(logs.size() - 1);</span>
    }

    private long getLastLogIdInDir(File dir) {
<span class="nc" id="L562">        List&lt;Integer&gt; currentIds = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L563">        currentIds.addAll(LedgerDirUtil.logIdsInDirectory(dir));</span>
<span class="nc" id="L564">        currentIds.addAll(LedgerDirUtil.compactedLogIdsInDirectory(dir));</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (currentIds.isEmpty()) {</span>
<span class="nc" id="L566">            return -1;</span>
        }
<span class="nc" id="L568">        Pair&lt;Integer, Integer&gt; largestGap = LedgerDirUtil.findLargestGap(currentIds);</span>
<span class="nc" id="L569">        return largestGap.getLeft() - 1;</span>
    }

    /**
     * reads id from the &quot;lastId&quot; file in the given directory.
     */
    private long readLastLogId(File f) {
        FileInputStream fis;
        try {
<span class="nc" id="L578">            fis = new FileInputStream(new File(f, &quot;lastId&quot;));</span>
<span class="nc" id="L579">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L580">            return INVALID_LID;</span>
<span class="nc" id="L581">        }</span>
<span class="nc" id="L582">        try (BufferedReader br = new BufferedReader(new InputStreamReader(fis, UTF_8))) {</span>
<span class="nc" id="L583">            String lastIdString = br.readLine();</span>
<span class="nc" id="L584">            return Long.parseLong(lastIdString, 16);</span>
<span class="nc" id="L585">        } catch (IOException | NumberFormatException e) {</span>
<span class="nc" id="L586">            return INVALID_LID;</span>
        }
    }

    void clearCompactingLogId() {
<span class="nc" id="L591">        entryLoggerAllocator.clearCompactingLogId();</span>
<span class="nc" id="L592">    }</span>

    /**
     * Flushes all rotated log channels. After log channels are flushed,
     * move leastUnflushedLogId ptr to current logId.
     */
    void checkpoint() throws IOException {
<span class="nc" id="L599">        entryLogManager.checkpoint();</span>
<span class="nc" id="L600">    }</span>

    @Override
    public void flush() throws IOException {
<span class="nc" id="L604">        entryLogManager.flush();</span>
<span class="nc" id="L605">    }</span>

    long addEntry(long ledger, ByteBuffer entry) throws IOException {
<span class="nc" id="L608">        return entryLogManager.addEntry(ledger, Unpooled.wrappedBuffer(entry), true);</span>
    }

    long addEntry(long ledger, ByteBuf entry, boolean rollLog) throws IOException {
<span class="nc" id="L612">        return entryLogManager.addEntry(ledger, entry, rollLog);</span>
    }

    @Override
    public long addEntry(long ledger, ByteBuf entry) throws IOException {
<span class="nc" id="L617">        return entryLogManager.addEntry(ledger, entry, true);</span>
    }

<span class="nc" id="L620">    private final FastThreadLocal&lt;ByteBuf&gt; sizeBuffer = new FastThreadLocal&lt;ByteBuf&gt;() {</span>
        @Override
        protected ByteBuf initialValue() throws Exception {
            // Max usage is size (4 bytes) + ledgerId (8 bytes) + entryid (8 bytes)
<span class="nc" id="L624">            return Unpooled.buffer(4 + 8 + 8);</span>
        }
    };

    private long addEntryForCompaction(long ledgerId, ByteBuf entry) throws IOException {
<span class="nc" id="L629">        synchronized (compactionLogLock) {</span>
<span class="nc" id="L630">            int entrySize = entry.readableBytes() + 4;</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (compactionLogChannel == null) {</span>
<span class="nc" id="L632">                createNewCompactionLog();</span>
            }

<span class="nc" id="L635">            ByteBuf sizeBuffer = this.sizeBuffer.get();</span>
<span class="nc" id="L636">            sizeBuffer.clear();</span>
<span class="nc" id="L637">            sizeBuffer.writeInt(entry.readableBytes());</span>
<span class="nc" id="L638">            compactionLogChannel.write(sizeBuffer);</span>

<span class="nc" id="L640">            long pos = compactionLogChannel.position();</span>
<span class="nc" id="L641">            compactionLogChannel.write(entry);</span>
<span class="nc" id="L642">            compactionLogChannel.registerWrittenEntry(ledgerId, entrySize);</span>
<span class="nc" id="L643">            return (compactionLogChannel.getLogId() &lt;&lt; 32L) | pos;</span>
        }
    }

    private void flushCompactionLog() throws IOException {
<span class="nc" id="L648">        synchronized (compactionLogLock) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (compactionLogChannel != null) {</span>
<span class="nc" id="L650">                compactionLogChannel.appendLedgersMap();</span>
<span class="nc" id="L651">                compactionLogChannel.flushAndForceWrite(false);</span>
<span class="nc" id="L652">                LOG.info(&quot;Flushed compaction log file {} with logId {}.&quot;,</span>
<span class="nc" id="L653">                    compactionLogChannel.getLogFile(),</span>
<span class="nc" id="L654">                    compactionLogChannel.getLogId());</span>
                // since this channel is only used for writing, after flushing the channel,
                // we had to close the underlying file channel. Otherwise, we might end up
                // leaking fds which cause the disk spaces could not be reclaimed.
<span class="nc" id="L658">                compactionLogChannel.close();</span>
            } else {
<span class="nc" id="L660">                throw new IOException(&quot;Failed to flush compaction log which has already been removed.&quot;);</span>
            }
<span class="nc" id="L662">        }</span>
<span class="nc" id="L663">    }</span>

    private void createNewCompactionLog() throws IOException {
<span class="nc" id="L666">        synchronized (compactionLogLock) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (compactionLogChannel == null) {</span>
<span class="nc" id="L668">                compactionLogChannel = entryLogManager.createNewLogForCompaction();</span>
            }
<span class="nc" id="L670">        }</span>
<span class="nc" id="L671">    }</span>

    /**
     * Remove the current compaction log, usually invoked when compaction failed and
     * we need to do some clean up to remove the compaction log file.
     */
    private void removeCurCompactionLog() {
<span class="nc" id="L678">        synchronized (compactionLogLock) {</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if (compactionLogChannel != null) {</span>
<span class="nc bnc" id="L680" title="All 4 branches missed.">                if (compactionLogChannel.getLogFile().exists() &amp;&amp; !compactionLogChannel.getLogFile().delete()) {</span>
<span class="nc" id="L681">                    LOG.warn(&quot;Could not delete compaction log file {}&quot;, compactionLogChannel.getLogFile());</span>
                }

                try {
<span class="nc" id="L685">                    compactionLogChannel.close();</span>
<span class="nc" id="L686">                } catch (IOException e) {</span>
<span class="nc" id="L687">                    LOG.error(&quot;Failed to close file channel for compaction log {}&quot;, compactionLogChannel.getLogId(),</span>
                            e);
<span class="nc" id="L689">                }</span>
<span class="nc" id="L690">                compactionLogChannel = null;</span>
            }
<span class="nc" id="L692">        }</span>
<span class="nc" id="L693">    }</span>

    static long logIdForOffset(long offset) {
<span class="nc" id="L696">        return offset &gt;&gt; 32L;</span>
    }


    static long posForOffset(long location) {
<span class="nc" id="L701">        return location &amp; 0xffffffffL;</span>
    }


    /**
     * Exception type for representing lookup errors.  Useful for disambiguating different error
     * conditions for reporting purposes.
     */
    static class EntryLookupException extends Exception {
        EntryLookupException(String message) {
<span class="nc" id="L711">            super(message);</span>
<span class="nc" id="L712">        }</span>

        /**
         * Represents case where log file is missing.
         */
        static class MissingLogFileException extends EntryLookupException {
            MissingLogFileException(long ledgerId, long entryId, long entryLogId, long pos) {
<span class="nc" id="L719">                super(String.format(&quot;Missing entryLog %d for ledgerId %d, entry %d at offset %d&quot;,</span>
<span class="nc" id="L720">                        entryLogId,</span>
<span class="nc" id="L721">                        ledgerId,</span>
<span class="nc" id="L722">                        entryId,</span>
<span class="nc" id="L723">                        pos));</span>
<span class="nc" id="L724">            }</span>
        }

        /**
         * Represents case where entry log is present, but does not contain the specified entry.
         */
        static class MissingEntryException extends EntryLookupException {
            MissingEntryException(long ledgerId, long entryId, long entryLogId, long pos) {
<span class="nc" id="L732">                super(String.format(&quot;pos %d (entry %d for ledgerId %d) past end of entryLog %d&quot;,</span>
<span class="nc" id="L733">                        pos,</span>
<span class="nc" id="L734">                        entryId,</span>
<span class="nc" id="L735">                        ledgerId,</span>
<span class="nc" id="L736">                        entryLogId));</span>
<span class="nc" id="L737">            }</span>
        }

        /**
         * Represents case where log is present, but encoded entry length header is invalid.
         */
        static class InvalidEntryLengthException extends EntryLookupException {
            InvalidEntryLengthException(long ledgerId, long entryId, long entryLogId, long pos) {
<span class="nc" id="L745">                super(String.format(&quot;Invalid entry length at pos %d (entry %d for ledgerId %d) for entryLog %d&quot;,</span>
<span class="nc" id="L746">                        pos,</span>
<span class="nc" id="L747">                        entryId,</span>
<span class="nc" id="L748">                        ledgerId,</span>
<span class="nc" id="L749">                        entryLogId));</span>
<span class="nc" id="L750">            }</span>
        }

        /**
         * Represents case where the entry at pos is wrong.
         */
        static class WrongEntryException extends EntryLookupException {
            WrongEntryException(long foundEntryId, long foundLedgerId, long ledgerId,
                                long entryId, long entryLogId, long pos) {
<span class="nc" id="L759">                super(String.format(</span>
                        &quot;Found entry %d, ledger %d at pos %d entryLog %d, should have found entry %d for ledgerId %d&quot;,
<span class="nc" id="L761">                        foundEntryId,</span>
<span class="nc" id="L762">                        foundLedgerId,</span>
<span class="nc" id="L763">                        pos,</span>
<span class="nc" id="L764">                        entryLogId,</span>
<span class="nc" id="L765">                        entryId,</span>
<span class="nc" id="L766">                        ledgerId));</span>
<span class="nc" id="L767">            }</span>
        }
    }

    private BufferedReadChannel getFCForEntryInternal(
            long ledgerId, long entryId, long entryLogId, long pos)
            throws EntryLookupException, IOException {
        try {
<span class="nc" id="L775">            return getChannelForLogId(entryLogId);</span>
<span class="nc" id="L776">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L777">            throw new EntryLookupException.MissingLogFileException(ledgerId, entryId, entryLogId, pos);</span>
        }
    }

    private ByteBuf readEntrySize(long ledgerId, long entryId, long entryLogId, long pos, BufferedReadChannel fc)
            throws EntryLookupException, IOException {
<span class="nc" id="L783">        ByteBuf sizeBuff = sizeBuffer.get();</span>
<span class="nc" id="L784">        sizeBuff.clear();</span>

<span class="nc" id="L786">        long entrySizePos = pos - 4; // we want to get the entrySize as well as the ledgerId and entryId</span>

        try {
<span class="nc bnc" id="L789" title="All 2 branches missed.">            if (readFromLogChannel(entryLogId, fc, sizeBuff, entrySizePos) != sizeBuff.capacity()) {</span>
<span class="nc" id="L790">                throw new EntryLookupException.MissingEntryException(ledgerId, entryId, entryLogId, entrySizePos);</span>
            }
<span class="nc" id="L792">        } catch (BufferedChannelBase.BufferedChannelClosedException | AsynchronousCloseException e) {</span>
<span class="nc" id="L793">            throw new EntryLookupException.MissingLogFileException(ledgerId, entryId, entryLogId, entrySizePos);</span>
<span class="nc" id="L794">        }</span>
<span class="nc" id="L795">        return sizeBuff;</span>
    }

    void checkEntry(long ledgerId, long entryId, long location) throws EntryLookupException, IOException {
<span class="nc" id="L799">        long entryLogId = logIdForOffset(location);</span>
<span class="nc" id="L800">        long pos = posForOffset(location);</span>
<span class="nc" id="L801">        BufferedReadChannel fc = getFCForEntryInternal(ledgerId, entryId, entryLogId, pos);</span>
<span class="nc" id="L802">        ByteBuf sizeBuf = readEntrySize(ledgerId, entryId, entryLogId, pos, fc);</span>
<span class="nc" id="L803">        validateEntry(ledgerId, entryId, entryLogId, pos, sizeBuf);</span>
<span class="nc" id="L804">    }</span>

    private void validateEntry(long ledgerId, long entryId, long entryLogId, long pos, ByteBuf sizeBuff)
            throws IOException, EntryLookupException {
<span class="nc" id="L808">        int entrySize = sizeBuff.readInt();</span>

        // entrySize does not include the ledgerId
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (entrySize &gt; maxSaneEntrySize) {</span>
<span class="nc" id="L812">            LOG.warn(&quot;Sanity check failed for entry size of &quot; + entrySize + &quot; at location &quot; + pos + &quot; in &quot;</span>
                    + entryLogId);
        }
<span class="nc bnc" id="L815" title="All 2 branches missed.">        if (entrySize &lt; MIN_SANE_ENTRY_SIZE) {</span>
<span class="nc" id="L816">            LOG.error(&quot;Read invalid entry length {}&quot;, entrySize);</span>
<span class="nc" id="L817">            throw new EntryLookupException.InvalidEntryLengthException(ledgerId, entryId, entryLogId, pos);</span>
        }

<span class="nc" id="L820">        long thisLedgerId = sizeBuff.getLong(4);</span>
<span class="nc" id="L821">        long thisEntryId = sizeBuff.getLong(12);</span>
<span class="nc bnc" id="L822" title="All 4 branches missed.">        if (thisLedgerId != ledgerId || thisEntryId != entryId) {</span>
<span class="nc" id="L823">            throw new EntryLookupException.WrongEntryException(</span>
                    thisEntryId, thisLedgerId, ledgerId, entryId, entryLogId, pos);
        }
<span class="nc" id="L826">    }</span>

    @Override
    public ByteBuf readEntry(long ledgerId, long entryId, long entryLocation)
            throws IOException, Bookie.NoEntryException {
<span class="nc" id="L831">        return internalReadEntry(ledgerId, entryId, entryLocation, true /* validateEntry */);</span>
    }

    @Override
    public ByteBuf readEntry(long location) throws IOException, Bookie.NoEntryException {
<span class="nc" id="L836">        return internalReadEntry(-1L, -1L, location, false /* validateEntry */);</span>
    }


    private ByteBuf internalReadEntry(long ledgerId, long entryId, long location, boolean validateEntry)
            throws IOException, Bookie.NoEntryException {
<span class="nc" id="L842">        long entryLogId = logIdForOffset(location);</span>
<span class="nc" id="L843">        long pos = posForOffset(location);</span>


<span class="nc" id="L846">        BufferedReadChannel fc = null;</span>
<span class="nc" id="L847">        int entrySize = -1;</span>
        try {
<span class="nc" id="L849">            fc = getFCForEntryInternal(ledgerId, entryId, entryLogId, pos);</span>

<span class="nc" id="L851">            ByteBuf sizeBuff = readEntrySize(ledgerId, entryId, entryLogId, pos, fc);</span>
<span class="nc" id="L852">            entrySize = sizeBuff.getInt(0);</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">            if (validateEntry) {</span>
<span class="nc" id="L854">                validateEntry(ledgerId, entryId, entryLogId, pos, sizeBuff);</span>
            }
<span class="nc" id="L856">        } catch (EntryLookupException e) {</span>
<span class="nc" id="L857">            throw new IOException(&quot;Bad entry read from log file id: &quot; + entryLogId, e);</span>
<span class="nc" id="L858">        }</span>

<span class="nc" id="L860">        ByteBuf data = allocator.buffer(entrySize, entrySize);</span>
<span class="nc" id="L861">        int rc = readFromLogChannel(entryLogId, fc, data, pos);</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">        if (rc != entrySize) {</span>
<span class="nc" id="L863">            ReferenceCountUtil.release(data);</span>
<span class="nc" id="L864">            throw new IOException(&quot;Bad entry read from log file id: &quot; + entryLogId,</span>
                    new EntryLookupException(&quot;Short read for &quot; + ledgerId + &quot;@&quot;
                                              + entryId + &quot; in &quot; + entryLogId + &quot;@&quot;
                                              + pos + &quot;(&quot; + rc + &quot;!=&quot; + entrySize + &quot;)&quot;));
        }
<span class="nc" id="L869">        data.writerIndex(entrySize);</span>

<span class="nc" id="L871">        return data;</span>
    }

    /**
     * Read the header of an entry log.
     */
    private Header getHeaderForLogId(long entryLogId) throws IOException {
<span class="nc" id="L878">        BufferedReadChannel bc = getChannelForLogId(entryLogId);</span>

        // Allocate buffer to read (version, ledgersMapOffset, ledgerCount)
<span class="nc" id="L881">        ByteBuf headers = allocator.directBuffer(LOGFILE_HEADER_SIZE);</span>
        try {
<span class="nc" id="L883">            bc.read(headers, 0);</span>

            // Skip marker string &quot;BKLO&quot;
<span class="nc" id="L886">            headers.readInt();</span>

<span class="nc" id="L888">            int headerVersion = headers.readInt();</span>
<span class="nc bnc" id="L889" title="All 4 branches missed.">            if (headerVersion &lt; HEADER_V0 || headerVersion &gt; HEADER_CURRENT_VERSION) {</span>
<span class="nc" id="L890">                LOG.info(&quot;Unknown entry log header version for log {}: {}&quot;, entryLogId, headerVersion);</span>
            }

<span class="nc" id="L893">            long ledgersMapOffset = headers.readLong();</span>
<span class="nc" id="L894">            int ledgersCount = headers.readInt();</span>
<span class="nc" id="L895">            return new Header(headerVersion, ledgersMapOffset, ledgersCount);</span>
        } finally {
<span class="nc" id="L897">            ReferenceCountUtil.release(headers);</span>
        }
    }

    @VisibleForTesting
    BufferedReadChannel getChannelForLogId(long entryLogId) throws IOException {
<span class="nc" id="L903">        BufferedReadChannel fc = getFromChannels(entryLogId);</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">        if (fc != null) {</span>
<span class="nc" id="L905">            return fc;</span>
        }
<span class="nc" id="L907">        File file = findFile(entryLogId);</span>
        // get channel is used to open an existing entry log file
        // it would be better to open using read mode
<span class="nc" id="L910">        FileChannel newFc = new RandomAccessFile(file, &quot;r&quot;).getChannel();</span>
<span class="nc" id="L911">        FileChannel oldFc = logid2FileChannel.putIfAbsent(entryLogId, newFc);</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">        if (null != oldFc) {</span>
<span class="nc" id="L913">            newFc.close();</span>
<span class="nc" id="L914">            newFc = oldFc;</span>
        }
        // We set the position of the write buffer of this buffered channel to Long.MAX_VALUE
        // so that there are no overlaps with the write buffer while reading
<span class="nc bnc" id="L918" title="All 2 branches missed.">        if (entryLogManager instanceof EntryLogManagerForSingleEntryLog) {</span>
<span class="nc" id="L919">            fc = new BufferedReadChannel(newFc, conf.getReadBufferBytes(), entryLoggerAllocator.isSealed(entryLogId));</span>
        } else {
<span class="nc" id="L921">            fc = new BufferedReadChannel(newFc, conf.getReadBufferBytes(), false);</span>
        }
<span class="nc" id="L923">        putInReadChannels(entryLogId, fc);</span>
<span class="nc" id="L924">        return fc;</span>
    }

    /**
     * Whether the log file exists or not.
     */
    @Override
    public boolean logExists(long logId) {
<span class="nc bnc" id="L932" title="All 2 branches missed.">        for (File d : ledgerDirsManager.getAllLedgerDirs()) {</span>
<span class="nc" id="L933">            File f = new File(d, Long.toHexString(logId) + &quot;.log&quot;);</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">            if (f.exists()) {</span>
<span class="nc" id="L935">                return true;</span>
            }
<span class="nc" id="L937">        }</span>
<span class="nc" id="L938">        return false;</span>
    }

    /**
     * Returns a set with the ids of all the entry log files.
     *
     * @throws IOException
     */
    public Set&lt;Long&gt; getEntryLogsSet() throws IOException {
<span class="nc" id="L947">        Set&lt;Long&gt; entryLogs = Sets.newTreeSet();</span>

<span class="nc" id="L949">        final FilenameFilter logFileFilter = new FilenameFilter() {</span>
            @Override
            public boolean accept(File dir, String name) {
<span class="nc" id="L952">                return name.endsWith(&quot;.log&quot;);</span>
            }
        };

<span class="nc bnc" id="L956" title="All 2 branches missed.">        for (File d : ledgerDirsManager.getAllLedgerDirs()) {</span>
<span class="nc" id="L957">            File[] files = d.listFiles(logFileFilter);</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">            if (files == null) {</span>
<span class="nc" id="L959">                throw new IOException(&quot;Failed to get list of files in directory &quot; + d);</span>
            }

<span class="nc bnc" id="L962" title="All 2 branches missed.">            for (File f : files) {</span>
<span class="nc" id="L963">                Long entryLogId = Long.parseLong(f.getName().split(&quot;.log&quot;)[0], 16);</span>
<span class="nc" id="L964">                entryLogs.add(entryLogId);</span>
            }
<span class="nc" id="L966">        }</span>
<span class="nc" id="L967">        return entryLogs;</span>
    }

    private File findFile(long logId) throws FileNotFoundException {
<span class="nc bnc" id="L971" title="All 2 branches missed.">        for (File d : ledgerDirsManager.getAllLedgerDirs()) {</span>
<span class="nc" id="L972">            File f = new File(d, Long.toHexString(logId) + &quot;.log&quot;);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">            if (f.exists()) {</span>
<span class="nc" id="L974">                return f;</span>
            }
<span class="nc" id="L976">        }</span>
<span class="nc" id="L977">        throw new FileNotFoundException(&quot;No file for log &quot; + Long.toHexString(logId));</span>
    }

    /**
     * Scan entry log.
     *
     * @param entryLogId Entry Log Id
     * @param scanner Entry Log Scanner
     * @throws IOException
     */
    @Override
    public void scanEntryLog(long entryLogId, EntryLogScanner scanner) throws IOException {
        // Buffer where to read the entrySize (4 bytes) and the ledgerId (8 bytes)
<span class="nc" id="L990">        ByteBuf headerBuffer = Unpooled.buffer(4 + 8);</span>
        BufferedReadChannel bc;
        // Get the BufferedChannel for the current entry log file
        try {
<span class="nc" id="L994">            bc = getChannelForLogId(entryLogId);</span>
<span class="nc" id="L995">        } catch (IOException e) {</span>
<span class="nc" id="L996">            LOG.warn(&quot;Failed to get channel to scan entry log: &quot; + entryLogId + &quot;.log&quot;);</span>
<span class="nc" id="L997">            throw e;</span>
<span class="nc" id="L998">        }</span>
        // Start the read position in the current entry log file to be after
        // the header where all of the ledger entries are.
<span class="nc" id="L1001">        long pos = LOGFILE_HEADER_SIZE;</span>

        // Start with a reasonably sized buffer size
<span class="nc" id="L1004">        ByteBuf data = allocator.directBuffer(1024 * 1024);</span>

        try {

            // Read through the entry log file and extract the ledger ID's.
            while (true) {
                // Check if we've finished reading the entry log file.
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                if (pos &gt;= bc.size()) {</span>
<span class="nc" id="L1012">                    break;</span>
                }
<span class="nc bnc" id="L1014" title="All 2 branches missed.">                if (readFromLogChannel(entryLogId, bc, headerBuffer, pos) != headerBuffer.capacity()) {</span>
<span class="nc" id="L1015">                    LOG.warn(&quot;Short read for entry size from entrylog {}&quot;, entryLogId);</span>
<span class="nc" id="L1016">                    return;</span>
                }
<span class="nc" id="L1018">                long offset = pos;</span>

<span class="nc" id="L1020">                int entrySize = headerBuffer.readInt();</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">                if (entrySize &lt;= 0) { // hitting padding</span>
<span class="nc" id="L1022">                    pos++;</span>
<span class="nc" id="L1023">                    headerBuffer.clear();</span>
<span class="nc" id="L1024">                    continue;</span>
                }
<span class="nc" id="L1026">                long ledgerId = headerBuffer.readLong();</span>
<span class="nc" id="L1027">                headerBuffer.clear();</span>

<span class="nc" id="L1029">                pos += 4;</span>
<span class="nc bnc" id="L1030" title="All 4 branches missed.">                if (ledgerId == INVALID_LID || !scanner.accept(ledgerId)) {</span>
                    // skip this entry
<span class="nc" id="L1032">                    pos += entrySize;</span>
<span class="nc" id="L1033">                    continue;</span>
                }
                // read the entry
<span class="nc" id="L1036">                data.clear();</span>
<span class="nc" id="L1037">                data.capacity(entrySize);</span>
<span class="nc" id="L1038">                int rc = readFromLogChannel(entryLogId, bc, data, pos);</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">                if (rc != entrySize) {</span>
<span class="nc" id="L1040">                    LOG.warn(&quot;Short read for ledger entry from entryLog {}@{} ({} != {})&quot;,</span>
<span class="nc" id="L1041">                            entryLogId, pos, rc, entrySize);</span>
<span class="nc" id="L1042">                    return;</span>
                }
                // process the entry
<span class="nc" id="L1045">                scanner.process(ledgerId, offset, data);</span>

                // Advance position to the next entry
<span class="nc" id="L1048">                pos += entrySize;</span>
<span class="nc" id="L1049">            }</span>
        } finally {
<span class="nc" id="L1051">            ReferenceCountUtil.release(data);</span>
        }
<span class="nc" id="L1053">    }</span>

    public EntryLogMetadata getEntryLogMetadata(long entryLogId, AbstractLogCompactor.Throttler throttler)
        throws IOException {
        // First try to extract the EntryLogMetadata from the index, if there's no index then fallback to scanning the
        // entry log
        try {
<span class="nc" id="L1060">            return extractEntryLogMetadataFromIndex(entryLogId);</span>
<span class="nc" id="L1061">        } catch (FileNotFoundException fne) {</span>
<span class="nc" id="L1062">            LOG.warn(&quot;Cannot find entry log file {}.log : {}&quot;, Long.toHexString(entryLogId), fne.getMessage());</span>
<span class="nc" id="L1063">            throw fne;</span>
<span class="nc" id="L1064">        } catch (Exception e) {</span>
<span class="nc" id="L1065">            LOG.info(&quot;Failed to get ledgers map index from: {}.log : {}&quot;, entryLogId, e.getMessage());</span>

            // Fall-back to scanning
<span class="nc" id="L1068">            return extractEntryLogMetadataByScanning(entryLogId, throttler);</span>
        }
    }

    EntryLogMetadata extractEntryLogMetadataFromIndex(long entryLogId) throws IOException {
<span class="nc" id="L1073">        Header header = getHeaderForLogId(entryLogId);</span>

<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if (header.version &lt; HEADER_V1) {</span>
<span class="nc" id="L1076">            throw new IOException(&quot;Old log file header without ledgers map on entryLogId &quot; + entryLogId);</span>
        }

<span class="nc bnc" id="L1079" title="All 2 branches missed.">        if (header.ledgersMapOffset == 0L) {</span>
            // The index was not stored in the log file (possibly because the bookie crashed before flushing it)
<span class="nc" id="L1081">            throw new IOException(&quot;No ledgers map index found on entryLogId &quot; + entryLogId);</span>
        }

<span class="nc bnc" id="L1084" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1085">            LOG.debug(&quot;Recovering ledgers maps for log {} at offset: {}&quot;, entryLogId, header.ledgersMapOffset);</span>
        }

<span class="nc" id="L1088">        BufferedReadChannel bc = getChannelForLogId(entryLogId);</span>

        // There can be multiple entries containing the various components of the serialized ledgers map
<span class="nc" id="L1091">        long offset = header.ledgersMapOffset;</span>
<span class="nc" id="L1092">        EntryLogMetadata meta = new EntryLogMetadata(entryLogId);</span>

<span class="nc" id="L1094">        final int maxMapSize = LEDGERS_MAP_HEADER_SIZE + LEDGERS_MAP_ENTRY_SIZE * LEDGERS_MAP_MAX_BATCH_SIZE;</span>
<span class="nc" id="L1095">        ByteBuf ledgersMap = allocator.directBuffer(maxMapSize);</span>

        try {
<span class="nc bnc" id="L1098" title="All 2 branches missed.">            while (offset &lt; bc.size()) {</span>
                // Read ledgers map size
<span class="nc" id="L1100">                sizeBuffer.get().clear();</span>
<span class="nc" id="L1101">                bc.read(sizeBuffer.get(), offset);</span>

<span class="nc" id="L1103">                int ledgersMapSize = sizeBuffer.get().readInt();</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                if (ledgersMapSize &lt;= 0) {</span>
<span class="nc" id="L1105">                    break;</span>
                }
                // Read the index into a buffer
<span class="nc" id="L1108">                ledgersMap.clear();</span>
<span class="nc" id="L1109">                bc.read(ledgersMap, offset + 4, ledgersMapSize);</span>

                // Discard ledgerId and entryId
<span class="nc" id="L1112">                long lid = ledgersMap.readLong();</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">                if (lid != INVALID_LID) {</span>
<span class="nc" id="L1114">                    throw new IOException(&quot;Cannot deserialize ledgers map from ledger &quot; + lid);</span>
                }

<span class="nc" id="L1117">                long entryId = ledgersMap.readLong();</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                if (entryId != LEDGERS_MAP_ENTRY_ID) {</span>
<span class="nc" id="L1119">                    throw new IOException(&quot;Cannot deserialize ledgers map from entryId &quot; + entryId);</span>
                }

                // Read the number of ledgers in the current entry batch
<span class="nc" id="L1123">                int ledgersCount = ledgersMap.readInt();</span>

                // Extract all (ledger,size) tuples from buffer
<span class="nc bnc" id="L1126" title="All 2 branches missed.">                for (int i = 0; i &lt; ledgersCount; i++) {</span>
<span class="nc" id="L1127">                    long ledgerId = ledgersMap.readLong();</span>
<span class="nc" id="L1128">                    long size = ledgersMap.readLong();</span>

<span class="nc bnc" id="L1130" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1131">                        LOG.debug(&quot;Recovering ledgers maps for log {} -- Found ledger: {} with size: {}&quot;,</span>
<span class="nc" id="L1132">                                entryLogId, ledgerId, size);</span>
                    }
<span class="nc" id="L1134">                    meta.addLedgerSize(ledgerId, size);</span>
                }
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                if (ledgersMap.isReadable()) {</span>
<span class="nc" id="L1137">                    throw new IOException(&quot;Invalid entry size when reading ledgers map&quot;);</span>
                }

                // Move to next entry, if any
<span class="nc" id="L1141">                offset += ledgersMapSize + 4;</span>
<span class="nc" id="L1142">            }</span>
<span class="nc" id="L1143">        } catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L1144">            throw new IOException(e);</span>
        } finally {
<span class="nc" id="L1146">            ReferenceCountUtil.release(ledgersMap);</span>
        }

<span class="nc bnc" id="L1149" title="All 2 branches missed.">        if (meta.getLedgersMap().size() != header.ledgersCount) {</span>
<span class="nc" id="L1150">            throw new IOException(&quot;Not all ledgers were found in ledgers map index. expected: &quot; + header.ledgersCount</span>
<span class="nc" id="L1151">                    + &quot; -- found: &quot; + meta.getLedgersMap().size() + &quot; -- entryLogId: &quot; + entryLogId);</span>
        }

<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (header.ledgersCount == 0) {</span>
<span class="nc" id="L1155">            throw new IOException(&quot;No ledgers map found in entryLogId &quot; + entryLogId + &quot;, do scan to double confirm&quot;);</span>
        }

<span class="nc" id="L1158">        return meta;</span>
    }

    private EntryLogMetadata extractEntryLogMetadataByScanning(long entryLogId,
                                                               AbstractLogCompactor.Throttler throttler)
        throws IOException {
<span class="nc" id="L1164">        final EntryLogMetadata meta = new EntryLogMetadata(entryLogId);</span>

        // Read through the entry log file and extract the entry log meta
<span class="nc" id="L1167">        scanEntryLog(entryLogId, new EntryLogScanner() {</span>
            @Override
            public void process(long ledgerId, long offset, ByteBuf entry) throws IOException {
<span class="nc bnc" id="L1170" title="All 2 branches missed.">                if (throttler != null) {</span>
<span class="nc" id="L1171">                    throttler.acquire(entry.readableBytes());</span>
                }
                // add new entry size of a ledger to entry log meta
<span class="nc" id="L1174">                meta.addLedgerSize(ledgerId, entry.readableBytes() + 4);</span>
<span class="nc" id="L1175">            }</span>

            @Override
            public boolean accept(long ledgerId) {
<span class="nc bnc" id="L1179" title="All 2 branches missed.">                return ledgerId &gt;= 0;</span>
            }
        });

<span class="nc bnc" id="L1183" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1184">            LOG.debug(&quot;Retrieved entry log meta data entryLogId: {}, meta: {}&quot;, entryLogId, meta);</span>
        }
<span class="nc" id="L1186">        return meta;</span>
    }

    /**
     * Shutdown method to gracefully stop entry logger.
     */
    @Override
    public void close() {
        // since logChannel is buffered channel, do flush when shutting down
<span class="nc" id="L1195">        LOG.info(&quot;Stopping EntryLogger&quot;);</span>
        try {
<span class="nc" id="L1197">            flush();</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">            for (FileChannel fc : logid2FileChannel.values()) {</span>
<span class="nc" id="L1199">                fc.close();</span>
<span class="nc" id="L1200">            }</span>
            // clear the mapping, so we don't need to go through the channels again in finally block in normal case.
<span class="nc" id="L1202">            logid2FileChannel.clear();</span>
<span class="nc" id="L1203">            entryLogManager.close();</span>
<span class="nc" id="L1204">            synchronized (compactionLogLock) {</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">                if (compactionLogChannel != null) {</span>
<span class="nc" id="L1206">                    compactionLogChannel.close();</span>
<span class="nc" id="L1207">                    compactionLogChannel = null;</span>
                }
<span class="nc" id="L1209">            }</span>
<span class="nc" id="L1210">        } catch (IOException ie) {</span>
            // we have no idea how to avoid io exception during shutting down, so just ignore it
<span class="nc" id="L1212">            LOG.error(&quot;Error flush entry log during shutting down, which may cause entry log corrupted.&quot;, ie);</span>
        } finally {
<span class="nc bnc" id="L1214" title="All 2 branches missed.">            for (FileChannel fc : logid2FileChannel.values()) {</span>
<span class="nc" id="L1215">                IOUtils.close(LOG, fc);</span>
<span class="nc" id="L1216">            }</span>

<span class="nc" id="L1218">            entryLogManager.forceClose();</span>
<span class="nc" id="L1219">            synchronized (compactionLogLock) {</span>
<span class="nc" id="L1220">                IOUtils.close(LOG, compactionLogChannel);</span>
<span class="nc" id="L1221">            }</span>
        }
        // shutdown the pre-allocation thread
<span class="nc" id="L1224">        entryLoggerAllocator.stop();</span>
<span class="nc" id="L1225">    }</span>

    protected LedgerDirsManager getLedgerDirsManager() {
<span class="nc" id="L1228">        return ledgerDirsManager;</span>
    }

    /**
     * Convert log filename (hex format with suffix) to logId in long.
     */
    static long fileName2LogId(String fileName) {
<span class="nc bnc" id="L1235" title="All 4 branches missed.">        if (fileName != null &amp;&amp; fileName.contains(&quot;.&quot;)) {</span>
<span class="nc" id="L1236">            fileName = fileName.split(&quot;\\.&quot;)[0];</span>
        }
        try {
<span class="nc" id="L1239">            return Long.parseLong(fileName, 16);</span>
<span class="nc" id="L1240">        } catch (Exception nfe) {</span>
<span class="nc" id="L1241">            LOG.error(&quot;Invalid log file name {} found when trying to convert to logId.&quot;, fileName, nfe);</span>
        }
<span class="nc" id="L1243">        return INVALID_LID;</span>
    }

    /**
     * Convert log Id to hex string.
     */
    static String logId2HexString(long logId) {
<span class="nc" id="L1250">        return Long.toHexString(logId);</span>
    }

    /**
     * Datastructure which maintains the status of logchannels. When a
     * logChannel is created entry of &lt; entryLogId, false &gt; will be made to this
     * sortedmap and when logChannel is rotated and flushed then the entry is
     * updated to &lt; entryLogId, true &gt; and all the lowest entries with
     * &lt; entryLogId, true &gt; status will be removed from the sortedmap. So that way
     * we could get least unflushed LogId.
     *
     */
    static class RecentEntryLogsStatus {
        private final SortedMap&lt;Long, Boolean&gt; entryLogsStatusMap;
        private long leastUnflushedLogId;

<span class="nc" id="L1266">        RecentEntryLogsStatus(long leastUnflushedLogId) {</span>
<span class="nc" id="L1267">            entryLogsStatusMap = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L1268">            this.leastUnflushedLogId = leastUnflushedLogId;</span>
<span class="nc" id="L1269">        }</span>

        synchronized void createdEntryLog(Long entryLogId) {
<span class="nc" id="L1272">            entryLogsStatusMap.put(entryLogId, false);</span>
<span class="nc" id="L1273">        }</span>

        synchronized void flushRotatedEntryLog(Long entryLogId) {
<span class="nc" id="L1276">            entryLogsStatusMap.replace(entryLogId, true);</span>
<span class="nc bnc" id="L1277" title="All 4 branches missed.">            while ((!entryLogsStatusMap.isEmpty()) &amp;&amp; (entryLogsStatusMap.get(entryLogsStatusMap.firstKey()))) {</span>
<span class="nc" id="L1278">                long leastFlushedLogId = entryLogsStatusMap.firstKey();</span>
<span class="nc" id="L1279">                entryLogsStatusMap.remove(leastFlushedLogId);</span>
<span class="nc" id="L1280">                leastUnflushedLogId = leastFlushedLogId + 1;</span>
<span class="nc" id="L1281">            }</span>
<span class="nc" id="L1282">        }</span>

        synchronized long getLeastUnflushedLogId() {
<span class="nc" id="L1285">            return leastUnflushedLogId;</span>
        }

        synchronized boolean isFlushedLogId(long entryLogId) {
<span class="nc bnc" id="L1289" title="All 4 branches missed.">            return entryLogsStatusMap.getOrDefault(entryLogId, Boolean.FALSE) || entryLogId &lt; leastUnflushedLogId;</span>
        }
    }

    @Override
    public CompactionEntryLog newCompactionLog(long logToCompact) throws IOException {
<span class="nc" id="L1295">        createNewCompactionLog();</span>

<span class="nc" id="L1297">        File compactingLogFile = getCurCompactionLogFile();</span>
<span class="nc" id="L1298">        long compactionLogId = fileName2LogId(compactingLogFile.getName());</span>
<span class="nc" id="L1299">        File compactedLogFile = compactedLogFileFromCompacting(compactingLogFile, logToCompact);</span>
<span class="nc" id="L1300">        File finalLogFile = new File(compactingLogFile.getParentFile(),</span>
<span class="nc" id="L1301">                                     compactingLogFile.getName().substring(0,</span>
<span class="nc" id="L1302">                                             compactingLogFile.getName().indexOf(&quot;.log&quot;) + 4));</span>
<span class="nc" id="L1303">        return new EntryLoggerCompactionEntryLog(</span>
                compactionLogId, logToCompact, compactingLogFile, compactedLogFile, finalLogFile);

    }

    private class EntryLoggerCompactionEntryLog implements CompactionEntryLog {
        private final long compactionLogId;
        private final long logIdToCompact;
        private final File compactingLogFile;
        private final File compactedLogFile;
        private final File finalLogFile;

        EntryLoggerCompactionEntryLog(long compactionLogId, long logIdToCompact,
                                      File compactingLogFile,
                                      File compactedLogFile,
<span class="nc" id="L1318">                                      File finalLogFile) {</span>
<span class="nc" id="L1319">            this.compactionLogId = compactionLogId;</span>
<span class="nc" id="L1320">            this.logIdToCompact = logIdToCompact;</span>
<span class="nc" id="L1321">            this.compactingLogFile = compactingLogFile;</span>
<span class="nc" id="L1322">            this.compactedLogFile = compactedLogFile;</span>
<span class="nc" id="L1323">            this.finalLogFile = finalLogFile;</span>
<span class="nc" id="L1324">        }</span>

        @Override
        public long addEntry(long ledgerId, ByteBuf entry) throws IOException {
<span class="nc" id="L1328">            return addEntryForCompaction(ledgerId, entry);</span>
        }
        @Override
        public void scan(EntryLogScanner scanner) throws IOException {
<span class="nc" id="L1332">            scanEntryLog(compactionLogId, scanner);</span>
<span class="nc" id="L1333">        }</span>
        @Override
        public void flush() throws IOException {
<span class="nc" id="L1336">            flushCompactionLog();</span>
<span class="nc" id="L1337">        }</span>
        @Override
        public void abort() {
<span class="nc" id="L1340">            removeCurCompactionLog();</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">            if (compactedLogFile.exists()) {</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">                if (!compactedLogFile.delete()) {</span>
<span class="nc" id="L1343">                    LOG.warn(&quot;Could not delete file: {}&quot;, compactedLogFile);</span>
                }
            }
<span class="nc" id="L1346">        }</span>

        @Override
        public void markCompacted() throws IOException {
<span class="nc bnc" id="L1350" title="All 2 branches missed.">            if (compactingLogFile.exists()) {</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">                if (!compactedLogFile.exists()) {</span>
<span class="nc" id="L1352">                    HardLink.createHardLink(compactingLogFile, compactedLogFile);</span>
                }
            } else {
<span class="nc" id="L1355">                throw new IOException(&quot;Compaction log doesn't exist any more after flush: &quot; + compactingLogFile);</span>
            }
<span class="nc" id="L1357">            removeCurCompactionLog();</span>
<span class="nc" id="L1358">        }</span>

        @Override
        public void makeAvailable() throws IOException {
<span class="nc bnc" id="L1362" title="All 2 branches missed.">            if (!finalLogFile.exists()) {</span>
<span class="nc" id="L1363">                HardLink.createHardLink(compactedLogFile, finalLogFile);</span>
            }
<span class="nc" id="L1365">        }</span>
        @Override
        public void finalizeAndCleanup() {
<span class="nc bnc" id="L1368" title="All 2 branches missed.">            if (compactedLogFile.exists()) {</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">                if (!compactedLogFile.delete()) {</span>
<span class="nc" id="L1370">                    LOG.warn(&quot;Could not delete file: {}&quot;, compactedLogFile);</span>
                }
            }
<span class="nc bnc" id="L1373" title="All 2 branches missed.">            if (compactingLogFile.exists()) {</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">                if (!compactingLogFile.delete()) {</span>
<span class="nc" id="L1375">                    LOG.warn(&quot;Could not delete file: {}&quot;, compactingLogFile);</span>
                }
            }
<span class="nc" id="L1378">        }</span>

        @Override
        public long getDstLogId() {
<span class="nc" id="L1382">            return compactionLogId;</span>
        }
        @Override
        public long getSrcLogId() {
<span class="nc" id="L1386">            return logIdToCompact;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L1391">            return MoreObjects.toStringHelper(this)</span>
<span class="nc" id="L1392">                .add(&quot;logId&quot;, compactionLogId)</span>
<span class="nc" id="L1393">                .add(&quot;compactedLogId&quot;, logIdToCompact)</span>
<span class="nc" id="L1394">                .add(&quot;compactingLogFile&quot;, compactingLogFile)</span>
<span class="nc" id="L1395">                .add(&quot;compactedLogFile&quot;, compactedLogFile)</span>
<span class="nc" id="L1396">                .add(&quot;finalLogFile&quot;, finalLogFile)</span>
<span class="nc" id="L1397">                .toString();</span>
        }
    }

    @Override
    public Collection&lt;CompactionEntryLog&gt; incompleteCompactionLogs() {
<span class="nc" id="L1403">        List&lt;File&gt; ledgerDirs = ledgerDirsManager.getAllLedgerDirs();</span>
<span class="nc" id="L1404">        List&lt;CompactionEntryLog&gt; compactionLogs = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1406" title="All 2 branches missed.">        for (File dir : ledgerDirs) {</span>
<span class="nc" id="L1407">            File[] compactingPhaseFiles = dir.listFiles(</span>
<span class="nc" id="L1408">                    file -&gt; file.getName().endsWith(TransactionalEntryLogCompactor.COMPACTING_SUFFIX));</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">            if (compactingPhaseFiles != null) {</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">                for (File file : compactingPhaseFiles) {</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">                    if (file.delete()) {</span>
<span class="nc" id="L1412">                        LOG.info(&quot;Deleted failed compaction file {}&quot;, file);</span>
                    }
                }
            }
<span class="nc" id="L1416">            File[] compactedPhaseFiles = dir.listFiles(</span>
<span class="nc" id="L1417">                    file -&gt; file.getName().endsWith(TransactionalEntryLogCompactor.COMPACTED_SUFFIX));</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">            if (compactedPhaseFiles != null) {</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">                for (File compactedFile : compactedPhaseFiles) {</span>
<span class="nc" id="L1420">                    LOG.info(&quot;Found compacted log file {} has partially flushed index, recovering index.&quot;,</span>
                             compactedFile);

<span class="nc" id="L1423">                    File compactingLogFile = new File(compactedFile.getParentFile(), &quot;doesntexist&quot;);</span>
<span class="nc" id="L1424">                    long compactionLogId = -1L;</span>
<span class="nc" id="L1425">                    long compactedLogId = -1L;</span>
<span class="nc" id="L1426">                    String[] parts = compactedFile.getName().split(Pattern.quote(&quot;.&quot;));</span>
<span class="nc" id="L1427">                    boolean valid = true;</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">                    if (parts.length != 4) {</span>
<span class="nc" id="L1429">                        valid = false;</span>
                    } else {
                        try {
<span class="nc" id="L1432">                            compactionLogId = Long.parseLong(parts[0], 16);</span>
<span class="nc" id="L1433">                            compactedLogId = Long.parseLong(parts[2], 16);</span>
<span class="nc" id="L1434">                        } catch (NumberFormatException nfe) {</span>
<span class="nc" id="L1435">                            valid = false;</span>
<span class="nc" id="L1436">                        }</span>
                    }

<span class="nc bnc" id="L1439" title="All 2 branches missed.">                    if (!valid) {</span>
<span class="nc" id="L1440">                        LOG.info(&quot;Invalid compacted file found ({}), deleting&quot;, compactedFile);</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">                        if (!compactedFile.delete()) {</span>
<span class="nc" id="L1442">                            LOG.warn(&quot;Couldn't delete invalid compacted file ({})&quot;, compactedFile);</span>
                        }
                        continue;
                    }
<span class="nc" id="L1446">                    File finalLogFile = new File(compactedFile.getParentFile(), compactionLogId + &quot;.log&quot;);</span>

<span class="nc" id="L1448">                    compactionLogs.add(</span>
                            new EntryLoggerCompactionEntryLog(compactionLogId, compactedLogId,
                                                              compactingLogFile, compactedFile, finalLogFile));
                }
            }
<span class="nc" id="L1453">        }</span>
<span class="nc" id="L1454">        return compactionLogs;</span>
    }

    private static File compactedLogFileFromCompacting(File compactionLogFile, long compactingLogId) {
<span class="nc" id="L1458">        File dir = compactionLogFile.getParentFile();</span>
<span class="nc" id="L1459">        String filename = compactionLogFile.getName();</span>
<span class="nc" id="L1460">        String newSuffix = &quot;.log.&quot; + DefaultEntryLogger.logId2HexString(compactingLogId)</span>
            + TransactionalEntryLogCompactor.COMPACTED_SUFFIX;
<span class="nc" id="L1462">        String hardLinkFilename = filename.replace(TransactionalEntryLogCompactor.COMPACTING_SUFFIX, newSuffix);</span>
<span class="nc" id="L1463">        return new File(dir, hardLinkFilename);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>