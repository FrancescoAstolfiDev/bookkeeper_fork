<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GarbageCollectorThread.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie</a> &gt; <span class="el_source">GarbageCollectorThread.java</span></div><h1>GarbageCollectorThread.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.bookkeeper.bookie;

import static org.apache.bookkeeper.util.BookKeeperConstants.METADATA_CACHE;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Strings;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.netty.util.concurrent.DefaultThreadFactory;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import lombok.Getter;
import org.apache.bookkeeper.bookie.BookieException.EntryLogMetadataMapException;
import org.apache.bookkeeper.bookie.GarbageCollector.GarbageCleaner;
import org.apache.bookkeeper.bookie.stats.GarbageCollectorStats;
import org.apache.bookkeeper.bookie.storage.EntryLogger;
import org.apache.bookkeeper.bookie.storage.ldb.PersistentEntryLogMetadataMap;
import org.apache.bookkeeper.common.util.MathUtils;
import org.apache.bookkeeper.conf.ServerConfiguration;
import org.apache.bookkeeper.meta.LedgerManager;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.commons.lang3.mutable.MutableBoolean;
import org.apache.commons.lang3.mutable.MutableLong;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This is the garbage collector thread that runs in the background to
 * remove any entry log files that no longer contains any active ledger.
 */
public class GarbageCollectorThread implements Runnable {
<span class="nc" id="L62">    private static final Logger LOG = LoggerFactory.getLogger(GarbageCollectorThread.class);</span>
    private static final int SECOND = 1000;
    private static final int ENTRY_LOG_USAGE_SEGMENT_COUNT = 10;
<span class="nc" id="L65">    private static final long MINUTE = TimeUnit.MINUTES.toMillis(1);</span>

    // Maps entry log files to the set of ledgers that comprise the file and the size usage per ledger
    private final EntryLogMetadataMap entryLogMetaMap;

    private final ScheduledExecutorService gcExecutor;
<span class="nc" id="L71">    Future&lt;?&gt; scheduledFuture = null;</span>

    // This is the fixed delay in milliseconds before running the Garbage Collector Thread again.
    final long gcWaitTime;

    // Compaction parameters
<span class="nc" id="L77">    boolean isForceMinorCompactionAllow = false;</span>
<span class="nc" id="L78">    boolean enableMinorCompaction = false;</span>
    final double minorCompactionThreshold;
    final long minorCompactionInterval;
    final long minorCompactionMaxTimeMillis;
    long lastMinorCompactionTime;

<span class="nc" id="L84">    boolean isForceMajorCompactionAllow = false;</span>
<span class="nc" id="L85">    boolean enableMajorCompaction = false;</span>
    final double majorCompactionThreshold;
    final long majorCompactionInterval;
    long majorCompactionMaxTimeMillis;
    long lastMajorCompactionTime;

    final long entryLocationCompactionInterval;
    long randomCompactionDelay;
    long lastEntryLocationCompactionTime;

<span class="nc" id="L95">    @Getter</span>
    final boolean isForceGCAllowWhenNoSpace;

    // Entry Logger Handle
    final EntryLogger entryLogger;
    AbstractLogCompactor compactor;

    // Stats loggers for garbage collection operations
    private final GarbageCollectorStats gcStats;

    private volatile long activeEntryLogSize;
    private volatile long totalEntryLogSize;
    private volatile int numActiveEntryLogs;
    private volatile double entryLogCompactRatio;
    private volatile int[] currentEntryLogUsageBuckets;

    final CompactableLedgerStorage ledgerStorage;

    // flag to ensure gc thread will not be interrupted during compaction
    // to reduce the risk getting entry log corrupted
<span class="nc" id="L115">    final AtomicBoolean compacting = new AtomicBoolean(false);</span>

    // use to get the compacting status
<span class="nc" id="L118">    final AtomicBoolean minorCompacting = new AtomicBoolean(false);</span>
<span class="nc" id="L119">    final AtomicBoolean majorCompacting = new AtomicBoolean(false);</span>

<span class="nc" id="L121">    volatile boolean running = true;</span>

    // Boolean to trigger a forced GC.
<span class="nc" id="L124">    final AtomicBoolean forceGarbageCollection = new AtomicBoolean(false);</span>
    // Boolean to disable major compaction, when disk is almost full
<span class="nc" id="L126">    final AtomicBoolean suspendMajorCompaction = new AtomicBoolean(false);</span>
    // Boolean to disable minor compaction, when disk is full
<span class="nc" id="L128">    final AtomicBoolean suspendMinorCompaction = new AtomicBoolean(false);</span>

    final ScanAndCompareGarbageCollector garbageCollector;
    final GarbageCleaner garbageCleaner;

    final ServerConfiguration conf;
    final LedgerDirsManager ledgerDirsManager;

<span class="nc" id="L136">    private static final AtomicLong threadNum = new AtomicLong(0);</span>
    final AbstractLogCompactor.Throttler throttler;

    /**
     * Create a garbage collector thread.
     *
     * @param conf
     *          Server Configuration Object.
     * @throws IOException
     */
    public GarbageCollectorThread(ServerConfiguration conf, LedgerManager ledgerManager,
                                  final LedgerDirsManager ledgerDirsManager,
                                  final CompactableLedgerStorage ledgerStorage,
                                  EntryLogger entryLogger,
                                  StatsLogger statsLogger) throws IOException {
<span class="nc" id="L151">        this(conf, ledgerManager, ledgerDirsManager, ledgerStorage, entryLogger, statsLogger, newExecutor());</span>
<span class="nc" id="L152">    }</span>

    @VisibleForTesting
    static ScheduledExecutorService newExecutor() {
<span class="nc" id="L156">        return Executors.newSingleThreadScheduledExecutor(new DefaultThreadFactory(&quot;GarbageCollectorThread&quot;));</span>
    }

    /**
     * Create a garbage collector thread.
     *
     * @param conf
     *          Server Configuration Object.
     * @throws IOException
     */
    public GarbageCollectorThread(ServerConfiguration conf,
                                  LedgerManager ledgerManager,
                                  final LedgerDirsManager ledgerDirsManager,
                                  final CompactableLedgerStorage ledgerStorage,
                                  EntryLogger entryLogger,
                                  StatsLogger statsLogger,
                                  ScheduledExecutorService gcExecutor)
<span class="nc" id="L173">        throws IOException {</span>
<span class="nc" id="L174">        this.gcExecutor = gcExecutor;</span>
<span class="nc" id="L175">        this.conf = conf;</span>

<span class="nc" id="L177">        this.ledgerDirsManager = ledgerDirsManager;</span>
<span class="nc" id="L178">        this.entryLogger = entryLogger;</span>
<span class="nc" id="L179">        this.entryLogMetaMap = createEntryLogMetadataMap();</span>
<span class="nc" id="L180">        this.ledgerStorage = ledgerStorage;</span>
<span class="nc" id="L181">        this.gcWaitTime = conf.getGcWaitTime();</span>

<span class="nc" id="L183">        this.numActiveEntryLogs = 0;</span>
<span class="nc" id="L184">        this.activeEntryLogSize = 0L;</span>
<span class="nc" id="L185">        this.totalEntryLogSize = 0L;</span>
<span class="nc" id="L186">        this.entryLogCompactRatio = 0.0;</span>
<span class="nc" id="L187">        this.currentEntryLogUsageBuckets = new int[ENTRY_LOG_USAGE_SEGMENT_COUNT];</span>
<span class="nc" id="L188">        this.garbageCollector = new ScanAndCompareGarbageCollector(ledgerManager, ledgerStorage, conf, statsLogger);</span>
<span class="nc" id="L189">        this.gcStats = new GarbageCollectorStats(</span>
            statsLogger,
<span class="nc" id="L191">            () -&gt; numActiveEntryLogs,</span>
<span class="nc" id="L192">            () -&gt; activeEntryLogSize,</span>
<span class="nc" id="L193">            () -&gt; totalEntryLogSize,</span>
<span class="nc" id="L194">            () -&gt; garbageCollector.getNumActiveLedgers(),</span>
<span class="nc" id="L195">            () -&gt; entryLogCompactRatio,</span>
<span class="nc" id="L196">            () -&gt; currentEntryLogUsageBuckets</span>
        );

<span class="nc" id="L199">        this.garbageCleaner = ledgerId -&gt; {</span>
            try {
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L202">                    LOG.debug(&quot;delete ledger : &quot; + ledgerId);</span>
                }
<span class="nc" id="L204">                gcStats.getDeletedLedgerCounter().inc();</span>
<span class="nc" id="L205">                ledgerStorage.deleteLedger(ledgerId);</span>
<span class="nc" id="L206">            } catch (IOException e) {</span>
<span class="nc" id="L207">                LOG.error(&quot;Exception when deleting the ledger index file on the Bookie: &quot;, e);</span>
<span class="nc" id="L208">            }</span>
<span class="nc" id="L209">        };</span>

        // compaction parameters
<span class="nc" id="L212">        minorCompactionThreshold = conf.getMinorCompactionThreshold();</span>
<span class="nc" id="L213">        minorCompactionInterval = conf.getMinorCompactionInterval() * SECOND;</span>
<span class="nc" id="L214">        majorCompactionThreshold = conf.getMajorCompactionThreshold();</span>
<span class="nc" id="L215">        majorCompactionInterval = conf.getMajorCompactionInterval() * SECOND;</span>
<span class="nc" id="L216">        isForceGCAllowWhenNoSpace = conf.getIsForceGCAllowWhenNoSpace();</span>
<span class="nc" id="L217">        majorCompactionMaxTimeMillis = conf.getMajorCompactionMaxTimeMillis();</span>
<span class="nc" id="L218">        minorCompactionMaxTimeMillis = conf.getMinorCompactionMaxTimeMillis();</span>
<span class="nc" id="L219">        entryLocationCompactionInterval = conf.getEntryLocationCompactionInterval() * SECOND;</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (entryLocationCompactionInterval &gt; 0) {</span>
<span class="nc" id="L221">            randomCompactionDelay = ThreadLocalRandom.current().nextLong(entryLocationCompactionInterval);</span>
        }

<span class="nc" id="L224">        boolean isForceAllowCompaction = conf.isForceAllowCompaction();</span>

<span class="nc" id="L226">        AbstractLogCompactor.LogRemovalListener remover = new AbstractLogCompactor.LogRemovalListener() {</span>
            @Override
            public void removeEntryLog(long logToRemove) {
                try {
<span class="nc" id="L230">                    GarbageCollectorThread.this.removeEntryLog(logToRemove);</span>
<span class="nc" id="L231">                } catch (EntryLogMetadataMapException e) {</span>
                    // Ignore and continue because ledger will not be cleaned up
                    // from entry-logger in this pass and will be taken care in
                    // next schedule task
<span class="nc" id="L235">                    LOG.warn(&quot;Failed to remove entry-log metadata {}&quot;, logToRemove, e);</span>
<span class="nc" id="L236">                }</span>
<span class="nc" id="L237">            }</span>
        };
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (conf.getUseTransactionalCompaction()) {</span>
<span class="nc" id="L240">            this.compactor = new TransactionalEntryLogCompactor(conf, entryLogger, ledgerStorage, remover);</span>
        } else {
<span class="nc" id="L242">            this.compactor = new EntryLogCompactor(conf, entryLogger, ledgerStorage, remover);</span>
        }

<span class="nc" id="L245">        this.throttler = new AbstractLogCompactor.Throttler(conf);</span>
<span class="nc bnc" id="L246" title="All 4 branches missed.">        if (minorCompactionInterval &gt; 0 &amp;&amp; minorCompactionThreshold &gt; 0) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (minorCompactionThreshold &gt; 1.0d) {</span>
<span class="nc" id="L248">                throw new IOException(&quot;Invalid minor compaction threshold &quot;</span>
                                    + minorCompactionThreshold);
            }
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if (minorCompactionInterval &lt; gcWaitTime) {</span>
<span class="nc" id="L252">                throw new IOException(&quot;Too short minor compaction interval : &quot;</span>
                                    + minorCompactionInterval);
            }
<span class="nc" id="L255">            enableMinorCompaction = true;</span>
        }

<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (isForceAllowCompaction) {</span>
<span class="nc bnc" id="L259" title="All 4 branches missed.">            if (minorCompactionThreshold &gt; 0 &amp;&amp; minorCompactionThreshold &lt; 1.0d) {</span>
<span class="nc" id="L260">                isForceMinorCompactionAllow = true;</span>
            }
<span class="nc bnc" id="L262" title="All 4 branches missed.">            if (majorCompactionThreshold &gt; 0 &amp;&amp; majorCompactionThreshold &lt; 1.0d) {</span>
<span class="nc" id="L263">                isForceMajorCompactionAllow = true;</span>
            }
        }

<span class="nc bnc" id="L267" title="All 4 branches missed.">        if (majorCompactionInterval &gt; 0 &amp;&amp; majorCompactionThreshold &gt; 0) {</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (majorCompactionThreshold &gt; 1.0d) {</span>
<span class="nc" id="L269">                throw new IOException(&quot;Invalid major compaction threshold &quot;</span>
                                    + majorCompactionThreshold);
            }
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (majorCompactionInterval &lt; gcWaitTime) {</span>
<span class="nc" id="L273">                throw new IOException(&quot;Too short major compaction interval : &quot;</span>
                                    + majorCompactionInterval);
            }
<span class="nc" id="L276">            enableMajorCompaction = true;</span>
        }

<span class="nc bnc" id="L279" title="All 4 branches missed.">        if (enableMinorCompaction &amp;&amp; enableMajorCompaction) {</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">            if (minorCompactionInterval &gt;= majorCompactionInterval</span>
                || minorCompactionThreshold &gt;= majorCompactionThreshold) {
<span class="nc" id="L282">                throw new IOException(&quot;Invalid minor/major compaction settings : minor (&quot;</span>
                                    + minorCompactionThreshold + &quot;, &quot; + minorCompactionInterval
                                    + &quot;), major (&quot; + majorCompactionThreshold + &quot;, &quot;
                                    + majorCompactionInterval + &quot;)&quot;);
            }
        }

<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (entryLocationCompactionInterval &gt; 0) {</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (entryLocationCompactionInterval &lt; gcWaitTime) {</span>
<span class="nc" id="L291">                throw new IOException(</span>
                        &quot;Too short entry location compaction interval : &quot; + entryLocationCompactionInterval);
            }
        }

<span class="nc" id="L296">        LOG.info(&quot;Minor Compaction : enabled=&quot; + enableMinorCompaction + &quot;, threshold=&quot;</span>
               + minorCompactionThreshold + &quot;, interval=&quot; + minorCompactionInterval);
<span class="nc" id="L298">        LOG.info(&quot;Major Compaction : enabled=&quot; + enableMajorCompaction + &quot;, threshold=&quot;</span>
               + majorCompactionThreshold + &quot;, interval=&quot; + majorCompactionInterval);
<span class="nc" id="L300">        LOG.info(&quot;Entry Location Compaction : interval=&quot; + entryLocationCompactionInterval + &quot;, randomCompactionDelay=&quot;</span>
                + randomCompactionDelay);

<span class="nc" id="L303">        lastMinorCompactionTime = lastMajorCompactionTime =</span>
<span class="nc" id="L304">            lastEntryLocationCompactionTime = System.currentTimeMillis();</span>
<span class="nc" id="L305">    }</span>

    private EntryLogMetadataMap createEntryLogMetadataMap() throws IOException {
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (conf.isGcEntryLogMetadataCacheEnabled()) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            String baseDir = Strings.isNullOrEmpty(conf.getGcEntryLogMetadataCachePath())</span>
<span class="nc" id="L310">                ? this.ledgerDirsManager.getAllLedgerDirs().get(0).getPath() : conf.getGcEntryLogMetadataCachePath();</span>
            try {
<span class="nc" id="L312">                return new PersistentEntryLogMetadataMap(baseDir, conf);</span>
<span class="nc" id="L313">            } catch (IOException e) {</span>
<span class="nc" id="L314">                LOG.error(&quot;Failed to initialize persistent-metadata-map , clean up {}&quot;,</span>
                    baseDir + &quot;/&quot; + METADATA_CACHE, e);
<span class="nc" id="L316">                throw e;</span>
            }
        } else {
<span class="nc" id="L319">            return new InMemoryEntryLogMetadataMap();</span>
        }
    }

    public void enableForceGC() {
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (forceGarbageCollection.compareAndSet(false, true)) {</span>
<span class="nc" id="L325">            LOG.info(&quot;Forced garbage collection triggered by thread: {}&quot;, Thread.currentThread().getName());</span>
<span class="nc" id="L326">            triggerGC(true, suspendMajorCompaction.get(),</span>
<span class="nc" id="L327">                      suspendMinorCompaction.get());</span>
        }
<span class="nc" id="L329">    }</span>

    public void enableForceGC(boolean forceMajor, boolean forceMinor) {
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (forceGarbageCollection.compareAndSet(false, true)) {</span>
<span class="nc" id="L333">            LOG.info(&quot;Forced garbage collection triggered by thread: {}, forceMajor: {}, forceMinor: {}&quot;,</span>
<span class="nc" id="L334">                Thread.currentThread().getName(), forceMajor, forceMinor);</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">            triggerGC(true, !forceMajor, !forceMinor);</span>
        }
<span class="nc" id="L337">    }</span>

    public void disableForceGC() {
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (forceGarbageCollection.compareAndSet(true, false)) {</span>
<span class="nc" id="L341">            LOG.info(&quot;{} disabled force garbage collection since bookie has enough space now.&quot;, Thread</span>
<span class="nc" id="L342">                    .currentThread().getName());</span>
        }
<span class="nc" id="L344">    }</span>

    Future&lt;?&gt; triggerGC(final boolean force,
                        final boolean suspendMajor,
                        final boolean suspendMinor) {
<span class="nc" id="L349">        return gcExecutor.submit(() -&gt; {</span>
<span class="nc" id="L350">                runWithFlags(force, suspendMajor, suspendMinor);</span>
<span class="nc" id="L351">            });</span>
    }

    Future&lt;?&gt; triggerGC() {
<span class="nc" id="L355">        final boolean force = forceGarbageCollection.get();</span>
<span class="nc" id="L356">        final boolean suspendMajor = suspendMajorCompaction.get();</span>
<span class="nc" id="L357">        final boolean suspendMinor = suspendMinorCompaction.get();</span>

<span class="nc" id="L359">        return gcExecutor.submit(() -&gt; {</span>
<span class="nc" id="L360">                runWithFlags(force, suspendMajor, suspendMinor);</span>
<span class="nc" id="L361">            });</span>
    }

    public boolean isInForceGC() {
<span class="nc" id="L365">        return forceGarbageCollection.get();</span>
    }

    public boolean isMajorGcSuspend() {
<span class="nc" id="L369">        return suspendMajorCompaction.get();</span>
    }

    public boolean isMinorGcSuspend() {
<span class="nc" id="L373">        return suspendMinorCompaction.get();</span>
    }

    public void suspendMajorGC() {
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (suspendMajorCompaction.compareAndSet(false, true)) {</span>
<span class="nc" id="L378">            LOG.info(&quot;Suspend Major Compaction triggered by thread: {}&quot;, Thread.currentThread().getName());</span>
        }
<span class="nc" id="L380">    }</span>

    public void resumeMajorGC() {
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (suspendMajorCompaction.compareAndSet(true, false)) {</span>
<span class="nc" id="L384">            LOG.info(&quot;{} Major Compaction back to normal since bookie has enough space now.&quot;,</span>
<span class="nc" id="L385">                    Thread.currentThread().getName());</span>
        }
<span class="nc" id="L387">    }</span>

    public void suspendMinorGC() {
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (suspendMinorCompaction.compareAndSet(false, true)) {</span>
<span class="nc" id="L391">            LOG.info(&quot;Suspend Minor Compaction triggered by thread: {}&quot;, Thread.currentThread().getName());</span>
        }
<span class="nc" id="L393">    }</span>

    public void resumeMinorGC() {
<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (suspendMinorCompaction.compareAndSet(true, false)) {</span>
<span class="nc" id="L397">            LOG.info(&quot;{} Minor Compaction back to normal since bookie has enough space now.&quot;,</span>
<span class="nc" id="L398">                    Thread.currentThread().getName());</span>
        }
<span class="nc" id="L400">    }</span>

    public void start() {
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (scheduledFuture != null) {</span>
<span class="nc" id="L404">            scheduledFuture.cancel(false);</span>
        }
<span class="nc" id="L406">        long initialDelay = getModInitialDelay();</span>
<span class="nc" id="L407">        scheduledFuture = gcExecutor.scheduleWithFixedDelay(this, initialDelay, gcWaitTime, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L408">    }</span>

    /**
     * when number of ledger's Dir are more than 1,the same of GarbageCollectorThread will do the same thing,
     * Especially
     * 1) deleting ledger, then SyncThread will be timed to do rocksDB compact
     * 2) compact: entry, cost cpu.
     * then get Mod initial Delay time to simply avoid GarbageCollectorThread working at the same time
     */
    public long getModInitialDelay() {
<span class="nc" id="L418">        int ledgerDirsNum = conf.getLedgerDirs().length;</span>
<span class="nc" id="L419">        long splitTime = gcWaitTime / ledgerDirsNum;</span>
<span class="nc" id="L420">        long currentThreadNum = threadNum.incrementAndGet();</span>
<span class="nc" id="L421">        return gcWaitTime + currentThreadNum * splitTime;</span>
    }

    @Override
    public void run() {
<span class="nc" id="L426">        boolean force = forceGarbageCollection.get();</span>
<span class="nc" id="L427">        boolean suspendMajor = suspendMajorCompaction.get();</span>
<span class="nc" id="L428">        boolean suspendMinor = suspendMinorCompaction.get();</span>

<span class="nc" id="L430">        runWithFlags(force, suspendMajor, suspendMinor);</span>
<span class="nc" id="L431">    }</span>

    public void runWithFlags(boolean force, boolean suspendMajor, boolean suspendMinor) {
<span class="nc" id="L434">        long threadStart = MathUtils.nowInNano();</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (force) {</span>
<span class="nc" id="L436">            LOG.info(&quot;Garbage collector thread forced to perform GC before expiry of wait time.&quot;);</span>
        }
        // Recover and clean up previous state if using transactional compaction
<span class="nc" id="L439">        compactor.cleanUpAndRecover();</span>

        try {
            // gc inactive/deleted ledgers
            // this is used in extractMetaFromEntryLogs to calculate the usage of entry log
<span class="nc" id="L444">            doGcLedgers();</span>


<span class="nc" id="L447">            long extractMetaStart = MathUtils.nowInNano();</span>
            try {
                // Extract all of the ledger ID's that comprise all of the entry logs
                // (except for the current new one which is still being written to).
<span class="nc" id="L451">                extractMetaFromEntryLogs();</span>

                // gc entry logs
<span class="nc" id="L454">                doGcEntryLogs();</span>
<span class="nc" id="L455">                gcStats.getExtractMetaRuntime()</span>
<span class="nc" id="L456">                        .registerSuccessfulEvent(MathUtils.elapsedNanos(extractMetaStart), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L457">            } catch (EntryLogMetadataMapException e) {</span>
<span class="nc" id="L458">                gcStats.getExtractMetaRuntime()</span>
<span class="nc" id="L459">                        .registerFailedEvent(MathUtils.elapsedNanos(extractMetaStart), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L460">                throw e;</span>
<span class="nc" id="L461">            }</span>

<span class="nc bnc" id="L463" title="All 2 branches missed.">            if (suspendMajor) {</span>
<span class="nc" id="L464">                LOG.info(&quot;Disk almost full, suspend major compaction to slow down filling disk.&quot;);</span>
            }
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (suspendMinor) {</span>
<span class="nc" id="L467">                LOG.info(&quot;Disk full, suspend minor compaction to slow down filling disk.&quot;);</span>
            }

<span class="nc" id="L470">            long curTime = System.currentTimeMillis();</span>
<span class="nc" id="L471">            long compactStart = MathUtils.nowInNano();</span>
<span class="nc bnc" id="L472" title="All 12 branches missed.">            if (((isForceMajorCompactionAllow &amp;&amp; force) || (enableMajorCompaction</span>
                    &amp;&amp; (force || curTime - lastMajorCompactionTime &gt; majorCompactionInterval)))
                    &amp;&amp; (!suspendMajor)) {
                // enter major compaction
<span class="nc" id="L476">                LOG.info(&quot;Enter major compaction, suspendMajor {}, lastMajorCompactionTime {}&quot;, suspendMajor,</span>
<span class="nc" id="L477">                        lastMajorCompactionTime);</span>
<span class="nc" id="L478">                majorCompacting.set(true);</span>
                try {
<span class="nc" id="L480">                    doCompactEntryLogs(majorCompactionThreshold, majorCompactionMaxTimeMillis);</span>
<span class="nc" id="L481">                } catch (EntryLogMetadataMapException e) {</span>
<span class="nc" id="L482">                    gcStats.getCompactRuntime()</span>
<span class="nc" id="L483">                            .registerFailedEvent(MathUtils.elapsedNanos(compactStart), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L484">                    throw e;</span>
                } finally {
<span class="nc" id="L486">                    lastMajorCompactionTime = System.currentTimeMillis();</span>
                    // and also move minor compaction time
<span class="nc" id="L488">                    lastMinorCompactionTime = lastMajorCompactionTime;</span>
<span class="nc" id="L489">                    gcStats.getMajorCompactionCounter().inc();</span>
<span class="nc" id="L490">                    majorCompacting.set(false);</span>
<span class="nc" id="L491">                }</span>

<span class="nc bnc" id="L493" title="All 12 branches missed.">            } else if (((isForceMinorCompactionAllow &amp;&amp; force) || (enableMinorCompaction</span>
                    &amp;&amp; (force || curTime - lastMinorCompactionTime &gt; minorCompactionInterval)))
                    &amp;&amp; (!suspendMinor)) {
                // enter minor compaction
<span class="nc" id="L497">                LOG.info(&quot;Enter minor compaction, suspendMinor {}, lastMinorCompactionTime {}&quot;, suspendMinor,</span>
<span class="nc" id="L498">                        lastMinorCompactionTime);</span>
<span class="nc" id="L499">                minorCompacting.set(true);</span>
                try {
<span class="nc" id="L501">                    doCompactEntryLogs(minorCompactionThreshold, minorCompactionMaxTimeMillis);</span>
<span class="nc" id="L502">                }  catch (EntryLogMetadataMapException e) {</span>
<span class="nc" id="L503">                    gcStats.getCompactRuntime()</span>
<span class="nc" id="L504">                            .registerFailedEvent(MathUtils.elapsedNanos(compactStart), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L505">                    throw e;</span>
                } finally {
<span class="nc" id="L507">                    lastMinorCompactionTime = System.currentTimeMillis();</span>
<span class="nc" id="L508">                    gcStats.getMinorCompactionCounter().inc();</span>
<span class="nc" id="L509">                    minorCompacting.set(false);</span>
                }
            }
<span class="nc bnc" id="L512" title="All 4 branches missed.">            if (entryLocationCompactionInterval &gt; 0 &amp;&amp; (curTime - lastEntryLocationCompactionTime &gt; (</span>
                    entryLocationCompactionInterval + randomCompactionDelay))) {
                // enter entry location compaction
<span class="nc" id="L515">                LOG.info(</span>
                        &quot;Enter entry location compaction, entryLocationCompactionInterval {}, randomCompactionDelay &quot;
                                + &quot;{}, lastEntryLocationCompactionTime {}&quot;,
<span class="nc" id="L518">                        entryLocationCompactionInterval, randomCompactionDelay, lastEntryLocationCompactionTime);</span>
<span class="nc" id="L519">                ledgerStorage.entryLocationCompact();</span>
<span class="nc" id="L520">                lastEntryLocationCompactionTime = System.currentTimeMillis();</span>
<span class="nc" id="L521">                randomCompactionDelay = ThreadLocalRandom.current().nextLong(entryLocationCompactionInterval);</span>
<span class="nc" id="L522">                LOG.info(&quot;Next entry location compaction interval {}&quot;,</span>
<span class="nc" id="L523">                        entryLocationCompactionInterval + randomCompactionDelay);</span>
<span class="nc" id="L524">                gcStats.getEntryLocationCompactionCounter().inc();</span>
            }
<span class="nc" id="L526">            gcStats.getCompactRuntime()</span>
<span class="nc" id="L527">                    .registerSuccessfulEvent(MathUtils.elapsedNanos(compactStart), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L528">            gcStats.getGcThreadRuntime().registerSuccessfulEvent(</span>
<span class="nc" id="L529">                    MathUtils.nowInNano() - threadStart, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L530">        } catch (EntryLogMetadataMapException e) {</span>
<span class="nc" id="L531">            LOG.error(&quot;Error in entryLog-metadatamap, Failed to complete GC/Compaction due to entry-log {}&quot;,</span>
<span class="nc" id="L532">                    e.getMessage(), e);</span>
<span class="nc" id="L533">            gcStats.getGcThreadRuntime().registerFailedEvent(MathUtils.elapsedNanos(threadStart), TimeUnit.NANOSECONDS);</span>
        } finally {
<span class="nc bnc" id="L535" title="All 4 branches missed.">            if (force &amp;&amp; forceGarbageCollection.compareAndSet(true, false)) {</span>
<span class="nc" id="L536">                LOG.info(&quot;{} Set forceGarbageCollection to false after force GC to make it forceGC-able again.&quot;,</span>
<span class="nc" id="L537">                        Thread.currentThread().getName());</span>
            }
        }

<span class="nc" id="L541">    }</span>

    /**
     * Do garbage collection ledger index files.
     */
    private void doGcLedgers() {
<span class="nc" id="L547">        long gcLedgersStart = MathUtils.nowInNano();</span>
        try {
<span class="nc" id="L549">            garbageCollector.gc(garbageCleaner);</span>
<span class="nc" id="L550">            gcStats.getGcLedgerRuntime()</span>
<span class="nc" id="L551">                    .registerSuccessfulEvent(MathUtils.elapsedNanos(gcLedgersStart), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L552">        } catch (Throwable t) {</span>
<span class="nc" id="L553">            LOG.warn(&quot;Exception when doing gc ledger.&quot;, t);</span>
<span class="nc" id="L554">            gcStats.getGcLedgerRuntime()</span>
<span class="nc" id="L555">                    .registerFailedEvent(MathUtils.elapsedNanos(gcLedgersStart), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L556">        }</span>
<span class="nc" id="L557">    }</span>

    /**
     * Garbage collect those entry loggers which are not associated with any active ledgers.
     */
    private void doGcEntryLogs() throws EntryLogMetadataMapException {
        // Get a cumulative count, don't update until complete
<span class="nc" id="L564">        AtomicLong activeEntryLogSizeAcc = new AtomicLong(0L);</span>
<span class="nc" id="L565">        AtomicLong totalEntryLogSizeAcc = new AtomicLong(0L);</span>

        // Loop through all of the entry logs and remove the non-active ledgers.
<span class="nc" id="L568">        entryLogMetaMap.forEach((entryLogId, meta) -&gt; {</span>
            try {
<span class="nc" id="L570">                boolean modified = removeIfLedgerNotExists(meta);</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                if (meta.isEmpty()) {</span>
                    // This means the entry log is not associated with any active
                    // ledgers anymore.
                    // We can remove this entry log file now.
<span class="nc" id="L575">                    LOG.info(&quot;Deleting entryLogId {} as it has no active ledgers!&quot;, entryLogId);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">                    if (removeEntryLog(entryLogId)) {</span>
<span class="nc" id="L577">                        gcStats.getReclaimedSpaceViaDeletes().addCount(meta.getTotalSize());</span>
                    } else {
<span class="nc" id="L579">                        gcStats.getReclaimFailedToDelete().inc();</span>
                    }
<span class="nc bnc" id="L581" title="All 2 branches missed.">                } else if (modified) {</span>
                    // update entryLogMetaMap only when the meta modified.
<span class="nc" id="L583">                    entryLogMetaMap.put(meta.getEntryLogId(), meta);</span>
                }
<span class="nc" id="L585">            } catch (EntryLogMetadataMapException e) {</span>
                // Ignore and continue because ledger will not be cleaned up
                // from entry-logger in this pass and will be taken care in next
                // schedule task
<span class="nc" id="L589">                LOG.warn(&quot;Failed to remove ledger from entry-log metadata {}&quot;, entryLogId, e);</span>
<span class="nc" id="L590">            }</span>
<span class="nc" id="L591">            activeEntryLogSizeAcc.getAndAdd(meta.getRemainingSize());</span>
<span class="nc" id="L592">            totalEntryLogSizeAcc.getAndAdd(meta.getTotalSize());</span>
<span class="nc" id="L593">        });</span>
<span class="nc" id="L594">        this.activeEntryLogSize = activeEntryLogSizeAcc.get();</span>
<span class="nc" id="L595">        this.totalEntryLogSize = totalEntryLogSizeAcc.get();</span>
<span class="nc" id="L596">        this.numActiveEntryLogs = entryLogMetaMap.size();</span>
<span class="nc" id="L597">    }</span>

    private boolean removeIfLedgerNotExists(EntryLogMetadata meta) throws EntryLogMetadataMapException {
<span class="nc" id="L600">        MutableBoolean modified = new MutableBoolean(false);</span>
<span class="nc" id="L601">        meta.removeLedgerIf((entryLogLedger) -&gt; {</span>
            // Remove the entry log ledger from the set if it isn't active.
            try {
<span class="nc" id="L604">                boolean exist = ledgerStorage.ledgerExists(entryLogLedger);</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                if (!exist) {</span>
<span class="nc" id="L606">                    modified.setTrue();</span>
                }
<span class="nc bnc" id="L608" title="All 2 branches missed.">                return !exist;</span>
<span class="nc" id="L609">            } catch (IOException e) {</span>
<span class="nc" id="L610">                LOG.error(&quot;Error reading from ledger storage&quot;, e);</span>
<span class="nc" id="L611">                return false;</span>
            }
        });

<span class="nc" id="L615">        return modified.getValue();</span>
    }

    /**
     * Compact entry logs if necessary.
     *
     * &lt;p&gt;
     * Compaction will be executed from low unused space to high unused space.
     * Those entry log files whose remaining size percentage is higher than threshold
     * would not be compacted.
     * &lt;/p&gt;
     */
    @VisibleForTesting
    void doCompactEntryLogs(double threshold, long maxTimeMillis) throws EntryLogMetadataMapException {
<span class="nc" id="L629">        LOG.info(&quot;Do compaction to compact those files lower than {}&quot;, threshold);</span>

<span class="nc" id="L631">        final int numBuckets = ENTRY_LOG_USAGE_SEGMENT_COUNT;</span>
<span class="nc" id="L632">        int[] entryLogUsageBuckets = new int[numBuckets];</span>
<span class="nc" id="L633">        int[] compactedBuckets = new int[numBuckets];</span>

<span class="nc" id="L635">        ArrayList&lt;LinkedList&lt;Long&gt;&gt; compactableBuckets = new ArrayList&lt;&gt;(numBuckets);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">        for (int i = 0; i &lt; numBuckets; i++) {</span>
<span class="nc" id="L637">            compactableBuckets.add(new LinkedList&lt;&gt;());</span>
        }

<span class="nc" id="L640">        long start = System.currentTimeMillis();</span>
<span class="nc" id="L641">        MutableLong end = new MutableLong(start);</span>
<span class="nc" id="L642">        MutableLong timeDiff = new MutableLong(0);</span>

<span class="nc" id="L644">        entryLogMetaMap.forEach((entryLogId, meta) -&gt; {</span>
<span class="nc" id="L645">            double usage = meta.getUsage();</span>
<span class="nc bnc" id="L646" title="All 4 branches missed.">            if (conf.isUseTargetEntryLogSizeForGc() &amp;&amp; usage &lt; 1.0d) {</span>
<span class="nc" id="L647">                usage = (double) meta.getRemainingSize() / Math.max(meta.getTotalSize(), conf.getEntryLogSizeLimit());</span>
            }
<span class="nc" id="L649">            int bucketIndex = calculateUsageIndex(numBuckets, usage);</span>
<span class="nc" id="L650">            entryLogUsageBuckets[bucketIndex]++;</span>

<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (timeDiff.getValue() &lt; maxTimeMillis) {</span>
<span class="nc" id="L653">                end.setValue(System.currentTimeMillis());</span>
<span class="nc" id="L654">                timeDiff.setValue(end.getValue() - start);</span>
            }
<span class="nc bnc" id="L656" title="All 4 branches missed.">            if ((usage &gt;= threshold</span>
<span class="nc bnc" id="L657" title="All 4 branches missed.">                || (maxTimeMillis &gt; 0 &amp;&amp; timeDiff.getValue() &gt;= maxTimeMillis)</span>
                || !running)) {
                // We allow the usage limit calculation to continue so that we get an accurate
                // report of where the usage was prior to running compaction.
<span class="nc" id="L661">                return;</span>
            }

<span class="nc" id="L664">            compactableBuckets.get(bucketIndex).add(meta.getEntryLogId());</span>
<span class="nc" id="L665">        });</span>
<span class="nc" id="L666">        currentEntryLogUsageBuckets = entryLogUsageBuckets;</span>
<span class="nc" id="L667">        gcStats.setEntryLogUsageBuckets(currentEntryLogUsageBuckets);</span>
<span class="nc" id="L668">        LOG.info(</span>
                &quot;Compaction: entry log usage buckets before compaction [10% 20% 30% 40% 50% 60% 70% 80% 90% 100%] = {}&quot;,
                entryLogUsageBuckets);

<span class="nc" id="L672">        final int maxBucket = calculateUsageIndex(numBuckets, threshold);</span>
<span class="nc" id="L673">        int totalEntryLogIds = 0;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">        for (int currBucket = 0; currBucket &lt;= maxBucket; currBucket++) {</span>
<span class="nc" id="L675">            totalEntryLogIds += compactableBuckets.get(currBucket).size();</span>
        }
<span class="nc" id="L677">        long lastPrintTimestamp = 0;</span>
<span class="nc" id="L678">        AtomicInteger processedEntryLogCnt = new AtomicInteger(0);</span>

        stopCompaction:
<span class="nc bnc" id="L681" title="All 2 branches missed.">        for (int currBucket = 0; currBucket &lt;= maxBucket; currBucket++) {</span>
<span class="nc" id="L682">            LinkedList&lt;Long&gt; entryLogIds = compactableBuckets.get(currBucket);</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">            while (!entryLogIds.isEmpty()) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (timeDiff.getValue() &lt; maxTimeMillis) {</span>
<span class="nc" id="L685">                    end.setValue(System.currentTimeMillis());</span>
<span class="nc" id="L686">                    timeDiff.setValue(end.getValue() - start);</span>
                }

<span class="nc bnc" id="L689" title="All 6 branches missed.">                if ((maxTimeMillis &gt; 0 &amp;&amp; timeDiff.getValue() &gt;= maxTimeMillis) || !running) {</span>
                    // We allow the usage limit calculation to continue so that we get an accurate
                    // report of where the usage was prior to running compaction.
<span class="nc" id="L692">                    break stopCompaction;</span>
                }

<span class="nc" id="L695">                final int bucketIndex = currBucket;</span>
<span class="nc" id="L696">                final long logId = entryLogIds.remove();</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                if (System.currentTimeMillis() - lastPrintTimestamp &gt;= MINUTE) {</span>
<span class="nc" id="L698">                    lastPrintTimestamp = System.currentTimeMillis();</span>
<span class="nc" id="L699">                    LOG.info(&quot;Compaction progress {} / {}, current compaction entryLogId: {}&quot;,</span>
<span class="nc" id="L700">                        processedEntryLogCnt.get(), totalEntryLogIds, logId);</span>
                }
<span class="nc" id="L702">                entryLogMetaMap.forKey(logId, (entryLogId, meta) -&gt; {</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">                    if (meta == null) {</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                        if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L705">                            LOG.debug(&quot;Metadata for entry log {} already deleted&quot;, logId);</span>
                        }
<span class="nc" id="L707">                        return;</span>
                    }
<span class="nc bnc" id="L709" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L710">                        LOG.debug(&quot;Compacting entry log {} with usage {} below threshold {}&quot;,</span>
<span class="nc" id="L711">                                meta.getEntryLogId(), meta.getUsage(), threshold);</span>
                    }

<span class="nc" id="L714">                    long priorRemainingSize = meta.getRemainingSize();</span>
<span class="nc" id="L715">                    compactEntryLog(meta);</span>
<span class="nc" id="L716">                    gcStats.getReclaimedSpaceViaCompaction().addCount(meta.getTotalSize() - priorRemainingSize);</span>
<span class="nc" id="L717">                    compactedBuckets[bucketIndex]++;</span>
<span class="nc" id="L718">                    processedEntryLogCnt.getAndIncrement();</span>
<span class="nc" id="L719">                });</span>
<span class="nc" id="L720">            }</span>
        }

<span class="nc bnc" id="L723" title="All 2 branches missed.">        if (LOG.isDebugEnabled()) {</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (!running) {</span>
<span class="nc" id="L725">                LOG.debug(&quot;Compaction exited due to gc not running&quot;);</span>
            }
<span class="nc bnc" id="L727" title="All 4 branches missed.">            if (maxTimeMillis &gt; 0 &amp;&amp; timeDiff.getValue() &gt; maxTimeMillis) {</span>
<span class="nc" id="L728">                LOG.debug(&quot;Compaction ran for {}ms but was limited by {}ms&quot;, timeDiff, maxTimeMillis);</span>
            }
        }
<span class="nc" id="L731">        int totalEntryLogNum = Arrays.stream(entryLogUsageBuckets).sum();</span>
<span class="nc" id="L732">        int compactedEntryLogNum = Arrays.stream(compactedBuckets).sum();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">        this.entryLogCompactRatio = totalEntryLogNum == 0 ? 0 : (double) compactedEntryLogNum / totalEntryLogNum;</span>
<span class="nc" id="L734">        LOG.info(&quot;Compaction: entry log usage buckets[10% 20% 30% 40% 50% 60% 70% 80% 90% 100%] = {}, compacted {}, &quot;</span>
<span class="nc" id="L735">                + &quot;compacted entry log ratio {}&quot;, entryLogUsageBuckets, compactedBuckets, entryLogCompactRatio);</span>
<span class="nc" id="L736">    }</span>

    /**
     * Calculate the index for the batch based on the usage between 0 and 1.
     *
     * @param numBuckets Number of reporting buckets.
     * @param usage 0.0 - 1.0 value representing the usage of the entry log.
     * @return index based on the number of buckets The last bucket will have the 1.0 if added.
     */
    int calculateUsageIndex(int numBuckets, double usage) {
<span class="nc" id="L746">        return Math.min(</span>
                numBuckets - 1,
<span class="nc" id="L748">                (int) Math.floor(usage * numBuckets));</span>
    }

    /**
     * Shutdown the garbage collector thread.
     *
     * @throws InterruptedException if there is an exception stopping gc thread.
     */
    @SuppressFBWarnings(&quot;SWL_SLEEP_WITH_LOCK_HELD&quot;)
    public synchronized void shutdown() throws InterruptedException {
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (!this.running) {</span>
<span class="nc" id="L759">            return;</span>
        }
<span class="nc" id="L761">        this.running = false;</span>
<span class="nc" id="L762">        LOG.info(&quot;Shutting down GarbageCollectorThread&quot;);</span>

<span class="nc" id="L764">        throttler.cancelledAcquire();</span>
<span class="nc" id="L765">        compactor.throttler.cancelledAcquire();</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">        while (!compacting.compareAndSet(false, true)) {</span>
            // Wait till the thread stops compacting
<span class="nc" id="L768">            Thread.sleep(100);</span>
        }

        // Interrupt GC executor thread
<span class="nc" id="L772">        gcExecutor.shutdownNow();</span>
        try {
<span class="nc" id="L774">            entryLogMetaMap.close();</span>
<span class="nc" id="L775">        } catch (Exception e) {</span>
<span class="nc" id="L776">            LOG.warn(&quot;Failed to close entryLog metadata-map&quot;, e);</span>
<span class="nc" id="L777">        }</span>
<span class="nc" id="L778">    }</span>

    /**
     * Remove entry log.
     *
     * @param entryLogId
     *          Entry Log File Id
     * @throws EntryLogMetadataMapException
     */
    protected boolean removeEntryLog(long entryLogId) throws EntryLogMetadataMapException {
        // remove entry log file successfully
<span class="nc bnc" id="L789" title="All 2 branches missed.">        if (entryLogger.removeEntryLog(entryLogId)) {</span>
<span class="nc" id="L790">            LOG.info(&quot;Removing entry log metadata for {}&quot;, entryLogId);</span>
<span class="nc" id="L791">            entryLogMetaMap.remove(entryLogId);</span>
<span class="nc" id="L792">            return true;</span>
        }

<span class="nc" id="L795">        return false;</span>
    }

    /**
     * Compact an entry log.
     *
     * @param entryLogMeta
     */
    protected void compactEntryLog(EntryLogMetadata entryLogMeta) {
        // Similar with Sync Thread
        // try to mark compacting flag to make sure it would not be interrupted
        // by shutdown during compaction. otherwise it will receive
        // ClosedByInterruptException which may cause index file &amp; entry logger
        // closed and corrupted.
<span class="nc bnc" id="L809" title="All 2 branches missed.">        if (!compacting.compareAndSet(false, true)) {</span>
            // set compacting flag failed, means compacting is true now
            // indicates that compaction is in progress for this EntryLogId.
<span class="nc" id="L812">            return;</span>
        }

        try {
            // Do the actual compaction
<span class="nc" id="L817">            compactor.compact(entryLogMeta);</span>
<span class="nc" id="L818">        } catch (Exception e) {</span>
<span class="nc" id="L819">            LOG.error(&quot;Failed to compact entry log {} due to unexpected error&quot;, entryLogMeta.getEntryLogId(), e);</span>
        } finally {
            // Mark compaction done
<span class="nc" id="L822">            compacting.set(false);</span>
        }
<span class="nc" id="L824">    }</span>

    /**
     * Method to read in all of the entry logs (those that we haven't done so yet),
     * and find the set of ledger ID's that make up each entry log file.
     *
     * @throws EntryLogMetadataMapException
     */
    protected void extractMetaFromEntryLogs() throws EntryLogMetadataMapException {
<span class="nc bnc" id="L833" title="All 2 branches missed.">        for (long entryLogId : entryLogger.getFlushedLogIds()) {</span>
            // Comb the current entry log file if it has not already been extracted.
<span class="nc bnc" id="L835" title="All 2 branches missed.">            if (entryLogMetaMap.containsKey(entryLogId)) {</span>
<span class="nc" id="L836">                continue;</span>
            }

            // check whether log file exists or not
            // if it doesn't exist, this log file might have been garbage collected.
<span class="nc bnc" id="L841" title="All 2 branches missed.">            if (!entryLogger.logExists(entryLogId)) {</span>
<span class="nc" id="L842">                continue;</span>
            }


            try {
                // Read through the entry log file and extract the entry log meta
<span class="nc" id="L848">                EntryLogMetadata entryLogMeta = entryLogger.getEntryLogMetadata(entryLogId, throttler);</span>
<span class="nc" id="L849">                LOG.info(&quot;Extracted entry log meta from entryLogId: {}, ledgers {}&quot;,</span>
<span class="nc" id="L850">                    entryLogId, entryLogMeta.getLedgersMap().keys());</span>
<span class="nc" id="L851">                removeIfLedgerNotExists(entryLogMeta);</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">                if (entryLogMeta.isEmpty()) {</span>
                    // This means the entry log is not associated with any active
                    // ledgers anymore.
                    // We can remove this entry log file now.
<span class="nc" id="L856">                    LOG.info(&quot;Deleting entryLogId {} as it has no active ledgers!&quot;, entryLogId);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">                    if (removeEntryLog(entryLogId)) {</span>
<span class="nc" id="L858">                        gcStats.getReclaimedSpaceViaDeletes().addCount(entryLogMeta.getTotalSize());</span>
                    } else {
<span class="nc" id="L860">                        gcStats.getReclaimFailedToDelete().inc();</span>
                    }
                } else {
<span class="nc" id="L863">                    entryLogMetaMap.put(entryLogId, entryLogMeta);</span>
                }
<span class="nc" id="L865">            } catch (IOException | RuntimeException e) {</span>
<span class="nc" id="L866">                LOG.warn(&quot;Premature exception when processing {} recovery will take care of the problem&quot;,</span>
<span class="nc" id="L867">                        entryLogId, e);</span>
<span class="nc" id="L868">            } catch (OutOfMemoryError oome) {</span>
                // somewhat similar to https://github.com/apache/bookkeeper/pull/3901
                // entrylog file can be corrupted but instead having a negative entry size
                // it ends up with very large value for the entry size causing OODME
<span class="nc" id="L872">                LOG.warn(&quot;OutOfMemoryError when processing {} - skipping the entry log&quot;, entryLogId, oome);</span>
<span class="nc" id="L873">            }</span>
<span class="nc" id="L874">        }</span>
<span class="nc" id="L875">    }</span>

    CompactableLedgerStorage getLedgerStorage() {
<span class="nc" id="L878">        return ledgerStorage;</span>
    }

    @VisibleForTesting
    EntryLogMetadataMap getEntryLogMetaMap() {
<span class="nc" id="L883">        return entryLogMetaMap;</span>
    }

    public GarbageCollectionStatus getGarbageCollectionStatus() {
<span class="nc" id="L887">        return GarbageCollectionStatus.builder()</span>
<span class="nc" id="L888">            .forceCompacting(forceGarbageCollection.get())</span>
<span class="nc" id="L889">            .majorCompacting(majorCompacting.get())</span>
<span class="nc" id="L890">            .minorCompacting(minorCompacting.get())</span>
<span class="nc" id="L891">            .lastMajorCompactionTime(lastMajorCompactionTime)</span>
<span class="nc" id="L892">            .lastMinorCompactionTime(lastMinorCompactionTime)</span>
<span class="nc" id="L893">            .lastEntryLocationCompactionTime(lastEntryLocationCompactionTime)</span>
<span class="nc" id="L894">            .majorCompactionCounter(gcStats.getMajorCompactionCounter().get())</span>
<span class="nc" id="L895">            .minorCompactionCounter(gcStats.getMinorCompactionCounter().get())</span>
<span class="nc" id="L896">            .entryLocationCompactionCounter(gcStats.getEntryLocationCompactionCounter().get())</span>
<span class="nc" id="L897">            .build();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>