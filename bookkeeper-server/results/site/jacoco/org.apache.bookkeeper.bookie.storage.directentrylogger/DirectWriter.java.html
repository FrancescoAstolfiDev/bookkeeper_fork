<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DirectWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.bookie.storage.directentrylogger</a> &gt; <span class="el_source">DirectWriter.java</span></div><h1>DirectWriter.java</h1><pre class="source lang-java linenums">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.bookie.storage.directentrylogger;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static org.apache.bookkeeper.common.util.ExceptionMessageHelper.exMsg;

import io.netty.buffer.ByteBuf;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import org.apache.bookkeeper.common.util.nativeio.NativeIO;
import org.apache.bookkeeper.common.util.nativeio.NativeIOException;
import org.apache.bookkeeper.slogger.Slogger;
import org.apache.commons.lang3.SystemUtils;

class DirectWriter implements LogWriter {
    final NativeIO nativeIO;
    final int fd;
    final int id;
    final String filename;
    final BufferPool bufferPool;
    final ExecutorService writeExecutor;
<span class="nc" id="L46">    final Object bufferLock = new Object();</span>
<span class="nc" id="L47">    final List&lt;Future&lt;?&gt;&gt; outstandingWrites = new ArrayList&lt;Future&lt;?&gt;&gt;();</span>
    final Slogger slog;
    Buffer nativeBuffer;
    long offset;
<span class="nc" id="L51">    private static volatile boolean useFallocate = true;</span>

    DirectWriter(int id,
                 String filename,
                 long maxFileSize,
                 ExecutorService writeExecutor,
                 BufferPool bufferPool,
<span class="nc" id="L58">                 NativeIO nativeIO, Slogger slog) throws IOException {</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">        checkArgument(maxFileSize &gt; 0, &quot;Max file size (%d) must be positive&quot;);</span>
<span class="nc" id="L60">        this.id = id;</span>
<span class="nc" id="L61">        this.filename = filename;</span>
<span class="nc" id="L62">        this.writeExecutor = writeExecutor;</span>
<span class="nc" id="L63">        this.nativeIO = nativeIO;</span>
<span class="nc" id="L64">        this.slog = slog.ctx(DirectWriter.class);</span>

<span class="nc" id="L66">        offset = 0;</span>

        try {
<span class="nc" id="L69">            fd = nativeIO.open(filename,</span>
                               NativeIO.O_CREAT | NativeIO.O_WRONLY | NativeIO.O_DIRECT,
                               00644);
<span class="nc bnc" id="L72" title="All 2 branches missed.">            checkState(fd &gt;= 0, &quot;Open should have thrown exception, fd is invalid : %d&quot;, fd);</span>
<span class="nc" id="L73">        } catch (NativeIOException ne) {</span>
<span class="nc" id="L74">            throw new IOException(exMsg(ne.getMessage()).kv(&quot;file&quot;, filename)</span>
<span class="nc" id="L75">                                  .kv(&quot;errno&quot;, ne.getErrno()).toString(), ne);</span>
<span class="nc" id="L76">        }</span>

<span class="nc bnc" id="L78" title="All 2 branches missed.">        if (useFallocate) {</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">            if (!SystemUtils.IS_OS_LINUX) {</span>
<span class="nc" id="L80">                disableUseFallocate();</span>
<span class="nc" id="L81">                this.slog.warn(Events.FALLOCATE_NOT_AVAILABLE);</span>
            } else {
                try {
<span class="nc" id="L84">                    int ret = nativeIO.fallocate(fd, NativeIO.FALLOC_FL_ZERO_RANGE, 0, maxFileSize);</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">                    checkState(ret == 0, &quot;Exception should have been thrown on non-zero ret: %d&quot;, ret);</span>
<span class="nc" id="L86">                } catch (NativeIOException ex) {</span>
                    // fallocate(2) is not supported on all filesystems.  Since this is an optimization, disable
                    // subsequent usage instead of failing the operation.
<span class="nc" id="L89">                    disableUseFallocate();</span>
<span class="nc" id="L90">                    this.slog.kv(&quot;message&quot;, ex.getMessage())</span>
<span class="nc" id="L91">                        .kv(&quot;file&quot;, filename)</span>
<span class="nc" id="L92">                        .kv(&quot;errno&quot;, ex.getErrno())</span>
<span class="nc" id="L93">                        .warn(Events.FALLOCATE_NOT_AVAILABLE);</span>
<span class="nc" id="L94">                }</span>
            }
        }

<span class="nc" id="L98">        this.bufferPool = bufferPool;</span>
<span class="nc" id="L99">        this.nativeBuffer = bufferPool.acquire();</span>
<span class="nc" id="L100">    }</span>

    private static void disableUseFallocate() {
<span class="nc" id="L103">        DirectWriter.useFallocate = false;</span>
<span class="nc" id="L104">    }</span>

    @Override
    public int logId() {
<span class="nc" id="L108">        return id;</span>
    }

    @Override
    public void writeAt(long offset, ByteBuf buf) throws IOException {
<span class="nc" id="L113">        checkArgument(Buffer.isAligned(offset),</span>
                      &quot;Offset to writeAt must be aligned to %d: %d is not&quot;, Buffer.ALIGNMENT, offset);
<span class="nc" id="L115">        checkArgument(Buffer.isAligned(buf.readableBytes()),</span>
                      &quot;Buffer must write multiple of alignment bytes (%d), %d is not&quot;,
<span class="nc" id="L117">                      Buffer.ALIGNMENT, buf.readableBytes());</span>

<span class="nc" id="L119">        int bytesToWrite = buf.readableBytes();</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (bytesToWrite &lt;= 0) {</span>
<span class="nc" id="L121">            return;</span>
        }

<span class="nc" id="L124">        Buffer tmpBuffer = bufferPool.acquire();</span>
<span class="nc" id="L125">        tmpBuffer.reset();</span>
<span class="nc" id="L126">        tmpBuffer.writeByteBuf(buf);</span>
<span class="nc" id="L127">        Future&lt;?&gt; f = writeExecutor.submit(() -&gt; {</span>
<span class="nc" id="L128">            writeByteBuf(tmpBuffer, bytesToWrite, offset);</span>
<span class="nc" id="L129">            return null;</span>
            });
<span class="nc" id="L131">        addOutstandingWrite(f);</span>
<span class="nc" id="L132">    }</span>

    private void writeByteBuf(Buffer buffer, int bytesToWrite, long offsetToWrite) throws IOException{
        try {
<span class="nc bnc" id="L136" title="All 2 branches missed.">            if (bytesToWrite &lt;= 0) {</span>
<span class="nc" id="L137">                return;</span>
            }
<span class="nc" id="L139">            int ret = nativeIO.pwrite(fd, buffer.pointer(), bytesToWrite, offsetToWrite);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (ret != bytesToWrite) {</span>
<span class="nc" id="L141">                throw new IOException(exMsg(&quot;Incomplete write&quot;)</span>
<span class="nc" id="L142">                    .kv(&quot;filename&quot;, filename)</span>
<span class="nc" id="L143">                    .kv(&quot;pointer&quot;, buffer.pointer())</span>
<span class="nc" id="L144">                    .kv(&quot;offset&quot;, offsetToWrite)</span>
<span class="nc" id="L145">                    .kv(&quot;writeSize&quot;, bytesToWrite)</span>
<span class="nc" id="L146">                    .kv(&quot;bytesWritten&quot;, ret)</span>
<span class="nc" id="L147">                    .toString());</span>
            }
<span class="nc" id="L149">        } catch (NativeIOException ne) {</span>
<span class="nc" id="L150">            throw new IOException(exMsg(&quot;Write error&quot;)</span>
<span class="nc" id="L151">                .kv(&quot;filename&quot;, filename)</span>
<span class="nc" id="L152">                .kv(&quot;offset&quot;, offsetToWrite)</span>
<span class="nc" id="L153">                .kv(&quot;writeSize&quot;, bytesToWrite)</span>
<span class="nc" id="L154">                .kv(&quot;pointer&quot;, buffer.pointer())</span>
<span class="nc" id="L155">                .kv(&quot;errno&quot;, ne.getErrno())</span>
<span class="nc" id="L156">                .toString());</span>
        } finally {
<span class="nc" id="L158">            bufferPool.release(buffer);</span>
        }
<span class="nc" id="L160">    }</span>

    @Override
    public int writeDelimited(ByteBuf buf) throws IOException {
<span class="nc" id="L164">        synchronized (bufferLock) {</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">            if (!nativeBuffer.hasSpace(serializedSize(buf))) {</span>
<span class="nc" id="L166">                flushBuffer();</span>
            }

<span class="nc" id="L169">            int readable = buf.readableBytes();</span>
<span class="nc" id="L170">            long bufferPosition = position() + Integer.BYTES;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (bufferPosition &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L172">                throw new IOException(exMsg(&quot;Cannot write past max int&quot;)</span>
<span class="nc" id="L173">                                      .kv(&quot;filename&quot;, filename)</span>
<span class="nc" id="L174">                                      .kv(&quot;writeSize&quot;, readable)</span>
<span class="nc" id="L175">                                      .kv(&quot;position&quot;, bufferPosition)</span>
<span class="nc" id="L176">                                      .toString());</span>
            }
<span class="nc" id="L178">            nativeBuffer.writeInt(readable);</span>
<span class="nc" id="L179">            nativeBuffer.writeByteBuf(buf);</span>
<span class="nc" id="L180">            return (int) bufferPosition;</span>
        }
    }

    @Override
    public void position(long offset) throws IOException {
<span class="nc" id="L186">        synchronized (bufferLock) {</span>
<span class="nc bnc" id="L187" title="All 4 branches missed.">            if (nativeBuffer != null &amp;&amp; nativeBuffer.position() &gt; 0) {</span>
<span class="nc" id="L188">                flushBuffer();</span>
            }
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if ((offset % Buffer.ALIGNMENT) != 0) {</span>
<span class="nc" id="L191">                throw new IOException(exMsg(&quot;offset must be multiple of alignment&quot;)</span>
<span class="nc" id="L192">                                      .kv(&quot;offset&quot;, offset)</span>
<span class="nc" id="L193">                                      .kv(&quot;alignment&quot;, Buffer.ALIGNMENT)</span>
<span class="nc" id="L194">                                      .toString());</span>
            }
<span class="nc" id="L196">            this.offset = offset;</span>
<span class="nc" id="L197">        }</span>
<span class="nc" id="L198">    }</span>

    @Override
    public long position() {
<span class="nc" id="L202">        synchronized (bufferLock) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            return this.offset + (nativeBuffer != null ? nativeBuffer.position() : 0);</span>
        }
    }

    @Override
    public void flush() throws IOException {
<span class="nc" id="L209">        flushBuffer();</span>

<span class="nc" id="L211">        waitForOutstandingWrites();</span>

        try {
<span class="nc" id="L214">            int ret = nativeIO.fsync(fd);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">            checkState(ret == 0, &quot;Fsync should throw exception on non-zero return (%d)&quot;, ret);</span>
<span class="nc" id="L216">        } catch (NativeIOException ne) {</span>
<span class="nc" id="L217">            throw new IOException(exMsg(ne.getMessage())</span>
<span class="nc" id="L218">                                  .kv(&quot;file&quot;, filename)</span>
<span class="nc" id="L219">                                  .kv(&quot;errno&quot;, ne.getErrno()).toString());</span>
<span class="nc" id="L220">        }</span>
<span class="nc" id="L221">    }</span>

    @Override
    public void close() throws IOException {
<span class="nc" id="L225">        synchronized (bufferLock) {</span>
<span class="nc bnc" id="L226" title="All 4 branches missed.">            if (nativeBuffer != null &amp;&amp; nativeBuffer.position() &gt; 0) {</span>
<span class="nc" id="L227">                flush();</span>
            }
<span class="nc" id="L229">        }</span>

        try {
<span class="nc" id="L232">            int ret = nativeIO.close(fd);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            checkState(ret == 0, &quot;Close should throw exception on non-zero return (%d)&quot;, ret);</span>
<span class="nc" id="L234">        } catch (NativeIOException ne) {</span>
<span class="nc" id="L235">            throw new IOException(exMsg(ne.getMessage())</span>
<span class="nc" id="L236">                                  .kv(&quot;file&quot;, filename)</span>
<span class="nc" id="L237">                                  .kv(&quot;errno&quot;, ne.getErrno()).toString());</span>
        } finally {
<span class="nc" id="L239">            synchronized (bufferLock) {</span>
<span class="nc" id="L240">                bufferPool.release(nativeBuffer);</span>
<span class="nc" id="L241">                nativeBuffer = null;</span>
<span class="nc" id="L242">            }</span>
        }
<span class="nc" id="L244">    }</span>

    private void addOutstandingWrite(Future&lt;?&gt; toAdd) throws IOException {
<span class="nc" id="L247">        synchronized (outstandingWrites) {</span>
<span class="nc" id="L248">            outstandingWrites.add(toAdd);</span>

<span class="nc" id="L250">            Iterator&lt;Future&lt;?&gt;&gt; iter = outstandingWrites.iterator();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            while (iter.hasNext()) { // clear out completed futures</span>
<span class="nc" id="L252">                Future&lt;?&gt; f = iter.next();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">                if (f.isDone()) {</span>
<span class="nc" id="L254">                    waitForFuture(f);</span>
<span class="nc" id="L255">                    iter.remove();</span>
                } else {
                    break;
                }
<span class="nc" id="L259">            }</span>
<span class="nc" id="L260">        }</span>
<span class="nc" id="L261">    }</span>

    private void waitForOutstandingWrites() throws IOException {
<span class="nc" id="L264">        synchronized (outstandingWrites) {</span>
<span class="nc" id="L265">            Iterator&lt;Future&lt;?&gt;&gt; iter = outstandingWrites.iterator();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            while (iter.hasNext()) { // clear out completed futures</span>
<span class="nc" id="L267">                Future&lt;?&gt; f = iter.next();</span>
<span class="nc" id="L268">                waitForFuture(f);</span>
<span class="nc" id="L269">                iter.remove();</span>
<span class="nc" id="L270">            }</span>
<span class="nc" id="L271">        }</span>
<span class="nc" id="L272">    }</span>

    private void waitForFuture(Future&lt;?&gt; f) throws IOException {
        try {
<span class="nc" id="L276">            f.get();</span>
<span class="nc" id="L277">        } catch (InterruptedException ie) {</span>
<span class="nc" id="L278">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L279">            throw new IOException(ie);</span>
<span class="nc" id="L280">        } catch (Throwable t) {</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            if (t.getCause() instanceof IOException) {</span>
<span class="nc" id="L282">                throw (IOException) t.getCause();</span>
            } else {
<span class="nc" id="L284">                throw new IOException(t);</span>
            }
<span class="nc" id="L286">        }</span>
<span class="nc" id="L287">    }</span>

    private void flushBuffer() throws IOException {
<span class="nc" id="L290">        synchronized (bufferLock) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (this.nativeBuffer != null) {</span>
<span class="nc" id="L292">                int bytesToWrite = this.nativeBuffer.padToAlignment();</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                if (bytesToWrite == 0) {</span>
<span class="nc" id="L294">                    return;</span>
                }

<span class="nc" id="L297">                Buffer bufferToFlush = this.nativeBuffer;</span>
<span class="nc" id="L298">                this.nativeBuffer = null;</span>

<span class="nc" id="L300">                long offsetToWrite = offset;</span>
<span class="nc" id="L301">                offset += bytesToWrite;</span>

<span class="nc" id="L303">                Future&lt;?&gt; f = writeExecutor.submit(() -&gt; {</span>
<span class="nc" id="L304">                    writeByteBuf(bufferToFlush, bytesToWrite, offsetToWrite);</span>
<span class="nc" id="L305">                    return null;</span>
                });
<span class="nc" id="L307">                addOutstandingWrite(f);</span>

                // must acquire after triggering the write
                // otherwise it could try to acquire a buffer without kicking off
                // a subroutine that will free another
<span class="nc" id="L312">                this.nativeBuffer = bufferPool.acquire();</span>
            }
<span class="nc" id="L314">        }</span>
<span class="nc" id="L315">    }</span>

    @Override
    public int serializedSize(ByteBuf buf) {
<span class="nc" id="L319">        return buf.readableBytes() + Integer.BYTES;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>