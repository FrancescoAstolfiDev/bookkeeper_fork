<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RackawareEnsemblePlacementPolicyImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">RackawareEnsemblePlacementPolicyImpl.java</span></div><h1>RackawareEnsemblePlacementPolicyImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.client;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIES_JOINED;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.BOOKIES_LEFT;
import static org.apache.bookkeeper.bookie.BookKeeperServerStats.FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNT;
import static org.apache.bookkeeper.client.BookKeeperClientStats.CLIENT_SCOPE;
import static org.apache.bookkeeper.client.BookKeeperClientStats.NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK;
import static org.apache.bookkeeper.client.BookKeeperClientStats.READ_REQUESTS_REORDERED;
import static org.apache.bookkeeper.client.RegionAwareEnsemblePlacementPolicy.UNKNOWN_REGION;

import com.beust.jcommander.internal.Lists;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import io.netty.util.HashedWheelTimer;
import java.io.IOException;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.bookkeeper.client.BKException.BKNotEnoughBookiesException;
import org.apache.bookkeeper.client.BookieInfoReader.BookieInfo;
import org.apache.bookkeeper.client.WeightedRandomSelection.WeightedObject;
import org.apache.bookkeeper.common.util.ReflectionUtils;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.conf.Configurable;
import org.apache.bookkeeper.feature.FeatureProvider;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.net.BookieNode;
import org.apache.bookkeeper.net.DNSToSwitchMapping;
import org.apache.bookkeeper.net.NetworkTopology;
import org.apache.bookkeeper.net.NetworkTopologyImpl;
import org.apache.bookkeeper.net.Node;
import org.apache.bookkeeper.net.NodeBase;
import org.apache.bookkeeper.net.ScriptBasedMapping;
import org.apache.bookkeeper.net.StabilizeNetworkTopology;
import org.apache.bookkeeper.proto.BookieAddressResolver;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.Gauge;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.stats.annotations.StatsDoc;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Simple rackware ensemble placement policy.
 *
 * &lt;p&gt;Make most of the class and methods as protected, so it could be extended to implement other algorithms.
 */
@StatsDoc(
    name = CLIENT_SCOPE,
    help = &quot;BookKeeper client stats&quot;
)
public class RackawareEnsemblePlacementPolicyImpl extends TopologyAwareEnsemblePlacementPolicy {

<span class="nc" id="L87">    static final Logger LOG = LoggerFactory.getLogger(RackawareEnsemblePlacementPolicyImpl.class);</span>
    int maxWeightMultiple;

    protected int minNumRacksPerWriteQuorum;
    protected boolean enforceMinNumRacksPerWriteQuorum;
    protected boolean ignoreLocalNodeInPlacementPolicy;
    protected boolean useHostnameResolveLocalNodePlacementPolicy;

    public static final String REPP_RANDOM_READ_REORDERING = &quot;ensembleRandomReadReordering&quot;;

    static final int RACKNAME_DISTANCE_FROM_LEAVES = 1;

    // masks for reordering
    static final int LOCAL_MASK       = 0x01 &lt;&lt; 24;
    static final int LOCAL_FAIL_MASK  = 0x02 &lt;&lt; 24;
    static final int REMOTE_MASK      = 0x04 &lt;&lt; 24;
    static final int REMOTE_FAIL_MASK = 0x08 &lt;&lt; 24;
    static final int READ_ONLY_MASK   = 0x10 &lt;&lt; 24;
    static final int SLOW_MASK        = 0x20 &lt;&lt; 24;
    static final int UNAVAIL_MASK     = 0x40 &lt;&lt; 24;
    static final int MASK_BITS        = 0xFFF &lt;&lt; 20;

    protected HashedWheelTimer timer;
    // Use a loading cache so slow bookies are expired. Use entryId as values.
    protected Cache&lt;BookieId, Long&gt; slowBookies;
    protected BookieNode localNode;
<span class="nc" id="L113">    protected boolean reorderReadsRandom = false;</span>
<span class="nc" id="L114">    protected boolean enforceDurability = false;</span>
<span class="nc" id="L115">    protected int stabilizePeriodSeconds = 0;</span>
<span class="nc" id="L116">    protected int reorderThresholdPendingRequests = 0;</span>
    // looks like these only assigned in the same thread as constructor, immediately after constructor;
    // no need to make volatile
<span class="nc" id="L119">    protected StatsLogger statsLogger = null;</span>

<span class="nc" id="L121">    @StatsDoc(</span>
            name = READ_REQUESTS_REORDERED,
            help = &quot;The distribution of number of bookies reordered on each read request&quot;
    )
    protected OpStatsLogger readReorderedCounter = null;
<span class="nc" id="L126">    @StatsDoc(</span>
            name = FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNT,
            help = &quot;Counter for number of times DNSResolverDecorator failed to resolve Network Location&quot;
    )
    protected Counter failedToResolveNetworkLocationCounter = null;
    @StatsDoc(
            name = NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK,
            help = &quot;Gauge for the number of writable Bookies in default rack&quot;
    )
    protected Gauge&lt;Integer&gt; numWritableBookiesInDefaultRack;

<span class="nc" id="L137">    private String defaultRack = NetworkTopology.DEFAULT_RACK;</span>

    RackawareEnsemblePlacementPolicyImpl() {
<span class="nc" id="L140">        this(false);</span>
<span class="nc" id="L141">    }</span>

<span class="nc" id="L143">    RackawareEnsemblePlacementPolicyImpl(boolean enforceDurability) {</span>
<span class="nc" id="L144">        this.enforceDurability = enforceDurability;</span>
<span class="nc" id="L145">        topology = new NetworkTopologyImpl();</span>
<span class="nc" id="L146">    }</span>

    /**
     * Initialize the policy.
     *
     * @param dnsResolver
     * @param timer
     * @param reorderReadsRandom
     * @param stabilizePeriodSeconds
     * @param reorderThresholdPendingRequests
     * @param isWeighted
     * @param maxWeightMultiple
     * @param minNumRacksPerWriteQuorum
     * @param enforceMinNumRacksPerWriteQuorum
     * @param ignoreLocalNodeInPlacementPolicy
     * @param statsLogger
     * @param bookieAddressResolver
     * @return initialized ensemble placement policy
     */
    protected RackawareEnsemblePlacementPolicyImpl initialize(DNSToSwitchMapping dnsResolver,
                                                              HashedWheelTimer timer,
                                                              boolean reorderReadsRandom,
                                                              int stabilizePeriodSeconds,
                                                              int reorderThresholdPendingRequests,
                                                              boolean isWeighted,
                                                              int maxWeightMultiple,
                                                              int minNumRacksPerWriteQuorum,
                                                              boolean enforceMinNumRacksPerWriteQuorum,
                                                              boolean ignoreLocalNodeInPlacementPolicy,
                                                              StatsLogger statsLogger,
                                                              BookieAddressResolver bookieAddressResolver) {
<span class="nc" id="L177">        return initialize(dnsResolver, timer, reorderReadsRandom, stabilizePeriodSeconds,</span>
            reorderThresholdPendingRequests, isWeighted, maxWeightMultiple, minNumRacksPerWriteQuorum,
            enforceMinNumRacksPerWriteQuorum, ignoreLocalNodeInPlacementPolicy,
            false, statsLogger, bookieAddressResolver);
    }

    /**
     * Initialize the policy.
     *
     * @param dnsResolver the object used to resolve addresses to their network address
     * @return initialized ensemble placement policy
     */
    protected RackawareEnsemblePlacementPolicyImpl initialize(DNSToSwitchMapping dnsResolver,
                                                              HashedWheelTimer timer,
                                                              boolean reorderReadsRandom,
                                                              int stabilizePeriodSeconds,
                                                              int reorderThresholdPendingRequests,
                                                              boolean isWeighted,
                                                              int maxWeightMultiple,
                                                              int minNumRacksPerWriteQuorum,
                                                              boolean enforceMinNumRacksPerWriteQuorum,
                                                              boolean ignoreLocalNodeInPlacementPolicy,
                                                              boolean useHostnameResolveLocalNodePlacementPolicy,
                                                              StatsLogger statsLogger,
                                                              BookieAddressResolver bookieAddressResolver) {
<span class="nc" id="L202">        checkNotNull(statsLogger, &quot;statsLogger should not be null, use NullStatsLogger instead.&quot;);</span>
<span class="nc" id="L203">        this.statsLogger = statsLogger;</span>
<span class="nc" id="L204">        this.bookieAddressResolver = bookieAddressResolver;</span>
<span class="nc" id="L205">        this.bookiesJoinedCounter = statsLogger.getOpStatsLogger(BOOKIES_JOINED);</span>
<span class="nc" id="L206">        this.bookiesLeftCounter = statsLogger.getOpStatsLogger(BOOKIES_LEFT);</span>
<span class="nc" id="L207">        this.readReorderedCounter = statsLogger.getOpStatsLogger(READ_REQUESTS_REORDERED);</span>
<span class="nc" id="L208">        this.failedToResolveNetworkLocationCounter = statsLogger.getCounter(FAILED_TO_RESOLVE_NETWORK_LOCATION_COUNT);</span>
<span class="nc" id="L209">        this.numWritableBookiesInDefaultRack = new Gauge&lt;Integer&gt;() {</span>
            @Override
            public Integer getDefaultValue() {
<span class="nc" id="L212">                return 0;</span>
            }

            @Override
            public Integer getSample() {
<span class="nc" id="L217">                rwLock.readLock().lock();</span>
                try {
<span class="nc" id="L219">                    return topology.countNumOfAvailableNodes(getDefaultRack(), Collections.emptySet());</span>
                } finally {
<span class="nc" id="L221">                    rwLock.readLock().unlock();</span>
                }
            }
        };
<span class="nc" id="L225">        this.statsLogger.registerGauge(NUM_WRITABLE_BOOKIES_IN_DEFAULT_RACK, numWritableBookiesInDefaultRack);</span>
<span class="nc" id="L226">        this.reorderReadsRandom = reorderReadsRandom;</span>
<span class="nc" id="L227">        this.stabilizePeriodSeconds = stabilizePeriodSeconds;</span>
<span class="nc" id="L228">        this.reorderThresholdPendingRequests = reorderThresholdPendingRequests;</span>
<span class="nc" id="L229">        this.dnsResolver = new DNSResolverDecorator(dnsResolver, () -&gt; this.getDefaultRack(),</span>
                failedToResolveNetworkLocationCounter);
<span class="nc" id="L231">        this.timer = timer;</span>
<span class="nc" id="L232">        this.minNumRacksPerWriteQuorum = minNumRacksPerWriteQuorum;</span>
<span class="nc" id="L233">        this.enforceMinNumRacksPerWriteQuorum = enforceMinNumRacksPerWriteQuorum;</span>
<span class="nc" id="L234">        this.ignoreLocalNodeInPlacementPolicy = ignoreLocalNodeInPlacementPolicy;</span>
<span class="nc" id="L235">        this.useHostnameResolveLocalNodePlacementPolicy = useHostnameResolveLocalNodePlacementPolicy;</span>

        // create the network topology
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (stabilizePeriodSeconds &gt; 0) {</span>
<span class="nc" id="L239">            this.topology = new StabilizeNetworkTopology(timer, stabilizePeriodSeconds);</span>
        } else {
<span class="nc" id="L241">            this.topology = new NetworkTopologyImpl();</span>
        }

<span class="nc" id="L244">        BookieNode bn = null;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (!ignoreLocalNodeInPlacementPolicy) {</span>
            try {
<span class="nc bnc" id="L247" title="All 2 branches missed.">                String hostname = useHostnameResolveLocalNodePlacementPolicy</span>
<span class="nc" id="L248">                    ? InetAddress.getLocalHost().getCanonicalHostName() : InetAddress.getLocalHost().getHostAddress();</span>
<span class="nc" id="L249">                bn = createDummyLocalBookieNode(hostname);</span>
<span class="nc" id="L250">            } catch (IOException e) {</span>
<span class="nc" id="L251">                LOG.error(&quot;Failed to get local host address : &quot;, e);</span>
<span class="nc" id="L252">            }</span>
        } else {
<span class="nc" id="L254">            LOG.info(&quot;Ignoring LocalNode in Placementpolicy&quot;);</span>
        }
<span class="nc" id="L256">        localNode = bn;</span>
<span class="nc" id="L257">        LOG.info(&quot;Initialize rackaware ensemble placement policy @ {} @ {} : {}.&quot;,</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">                localNode, null == localNode ? &quot;Unknown&quot; : localNode.getNetworkLocation(),</span>
<span class="nc" id="L259">                dnsResolver.getClass().getName());</span>

<span class="nc" id="L261">        this.isWeighted = isWeighted;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (this.isWeighted) {</span>
<span class="nc" id="L263">            this.maxWeightMultiple = maxWeightMultiple;</span>
<span class="nc" id="L264">            this.weightedSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(this.maxWeightMultiple);</span>
<span class="nc" id="L265">            LOG.info(&quot;Weight based placement with max multiple of &quot; + this.maxWeightMultiple);</span>
        } else {
<span class="nc" id="L267">            LOG.info(&quot;Not weighted&quot;);</span>
        }
<span class="nc" id="L269">        return this;</span>
    }

    /*
     * sets default rack for the policy.
     * i.e. region-aware policy may want to have /region/rack while regular
     * rack-aware policy needs /rack only since we cannot mix both styles
     */
    public RackawareEnsemblePlacementPolicyImpl withDefaultRack(String rack) {
<span class="nc" id="L278">        checkNotNull(rack, &quot;Default rack cannot be null&quot;);</span>

<span class="nc" id="L280">        this.defaultRack = rack;</span>
<span class="nc" id="L281">        return this;</span>
    }

    @Override
    public String getDefaultRack() {
<span class="nc" id="L286">        return defaultRack;</span>
    }

    @Override
    public RackawareEnsemblePlacementPolicyImpl initialize(ClientConfiguration conf,
                                                           Optional&lt;DNSToSwitchMapping&gt; optionalDnsResolver,
                                                           HashedWheelTimer timer,
                                                           FeatureProvider featureProvider,
                                                           StatsLogger statsLogger,
                                                           BookieAddressResolver bookieAddressResolver) {
<span class="nc" id="L296">        this.bookieAddressResolver = bookieAddressResolver;</span>
        DNSToSwitchMapping dnsResolver;
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (optionalDnsResolver.isPresent()) {</span>
<span class="nc" id="L299">            dnsResolver = optionalDnsResolver.get();</span>
        } else {
<span class="nc" id="L301">            String dnsResolverName = conf.getString(REPP_DNS_RESOLVER_CLASS, ScriptBasedMapping.class.getName());</span>
            try {
<span class="nc" id="L303">                dnsResolver = ReflectionUtils.newInstance(dnsResolverName, DNSToSwitchMapping.class);</span>
<span class="nc" id="L304">                dnsResolver.setBookieAddressResolver(bookieAddressResolver);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                if (dnsResolver instanceof Configurable) {</span>
<span class="nc" id="L306">                    ((Configurable) dnsResolver).setConf(conf);</span>
                }

<span class="nc bnc" id="L309" title="All 2 branches missed.">                if (dnsResolver instanceof RackChangeNotifier) {</span>
<span class="nc" id="L310">                    ((RackChangeNotifier) dnsResolver).registerRackChangeListener(this);</span>
                }
<span class="nc" id="L312">            } catch (RuntimeException re) {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">                if (!conf.getEnforceMinNumRacksPerWriteQuorum()) {</span>
<span class="nc" id="L314">                    LOG.warn(&quot;Failed to initialize DNS Resolver {}, used default subnet resolver because {}&quot;,</span>
<span class="nc" id="L315">                            dnsResolverName, re.getMessage());</span>
<span class="nc" id="L316">                    dnsResolver = new DefaultResolver(this::getDefaultRack);</span>
<span class="nc" id="L317">                    dnsResolver.setBookieAddressResolver(bookieAddressResolver);</span>
                } else {
                    /*
                     * if minNumRacksPerWriteQuorum is enforced, then it
                     * shouldn't continue in the case of failure to create
                     * dnsResolver.
                     */
<span class="nc" id="L324">                    throw re;</span>
                }
<span class="nc" id="L326">            }</span>
        }
<span class="nc" id="L328">        slowBookies = CacheBuilder.newBuilder()</span>
<span class="nc" id="L329">            .expireAfterWrite(conf.getBookieFailureHistoryExpirationMSec(), TimeUnit.MILLISECONDS)</span>
<span class="nc" id="L330">            .build(new CacheLoader&lt;BookieId, Long&gt;() {</span>
                @Override
                public Long load(BookieId key) throws Exception {
<span class="nc" id="L333">                    return -1L;</span>
                }
            });
<span class="nc" id="L336">        return initialize(</span>
                dnsResolver,
                timer,
<span class="nc" id="L339">                conf.getBoolean(REPP_RANDOM_READ_REORDERING, false),</span>
<span class="nc" id="L340">                conf.getNetworkTopologyStabilizePeriodSeconds(),</span>
<span class="nc" id="L341">                conf.getReorderThresholdPendingRequests(),</span>
<span class="nc" id="L342">                conf.getDiskWeightBasedPlacementEnabled(),</span>
<span class="nc" id="L343">                conf.getBookieMaxWeightMultipleForWeightBasedPlacement(),</span>
<span class="nc" id="L344">                conf.getMinNumRacksPerWriteQuorum(),</span>
<span class="nc" id="L345">                conf.getEnforceMinNumRacksPerWriteQuorum(),</span>
<span class="nc" id="L346">                conf.getIgnoreLocalNodeInPlacementPolicy(),</span>
<span class="nc" id="L347">                conf.getUseHostnameResolveLocalNodePlacementPolicy(),</span>
                statsLogger,
                bookieAddressResolver);
    }

    @Override
    public void uninitalize() {
        // do nothing
<span class="nc" id="L355">    }</span>

    /*
     * this method should be called in readlock scope of 'rwLock'
     */
    protected Set&lt;BookieId&gt; addDefaultRackBookiesIfMinNumRacksIsEnforced(
            Set&lt;BookieId&gt; excludeBookies) {
        Set&lt;BookieId&gt; comprehensiveExclusionBookiesSet;
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (enforceMinNumRacksPerWriteQuorum) {</span>
<span class="nc" id="L364">            Set&lt;BookieId&gt; bookiesInDefaultRack = null;</span>
<span class="nc" id="L365">            Set&lt;Node&gt; defaultRackLeaves = topology.getLeaves(getDefaultRack());</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">            for (Node node : defaultRackLeaves) {</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                if (node instanceof BookieNode) {</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                    if (bookiesInDefaultRack == null) {</span>
<span class="nc" id="L369">                        bookiesInDefaultRack = new HashSet&lt;BookieId&gt;(excludeBookies);</span>
                    }
<span class="nc" id="L371">                    bookiesInDefaultRack.add(((BookieNode) node).getAddr());</span>
                } else {
<span class="nc" id="L373">                    LOG.error(&quot;found non-BookieNode: {} as leaf of defaultrack: {}&quot;, node, getDefaultRack());</span>
                }
<span class="nc" id="L375">            }</span>
<span class="nc bnc" id="L376" title="All 4 branches missed.">            if ((bookiesInDefaultRack == null) || bookiesInDefaultRack.isEmpty()) {</span>
<span class="nc" id="L377">                comprehensiveExclusionBookiesSet = excludeBookies;</span>
            } else {
<span class="nc" id="L379">                comprehensiveExclusionBookiesSet = new HashSet&lt;BookieId&gt;(excludeBookies);</span>
<span class="nc" id="L380">                comprehensiveExclusionBookiesSet.addAll(bookiesInDefaultRack);</span>
<span class="nc" id="L381">                LOG.info(&quot;enforceMinNumRacksPerWriteQuorum is enabled, so Excluding bookies of defaultRack: {}&quot;,</span>
                        bookiesInDefaultRack);
            }
<span class="nc" id="L384">        } else {</span>
<span class="nc" id="L385">            comprehensiveExclusionBookiesSet = excludeBookies;</span>
        }
<span class="nc" id="L387">        return comprehensiveExclusionBookiesSet;</span>
    }

    @Override
    public PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsemble(int ensembleSize, int writeQuorumSize,
            int ackQuorumSize, Map&lt;String, byte[]&gt; customMetadata, Set&lt;BookieId&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L394">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L396">            Set&lt;BookieId&gt; comprehensiveExclusionBookiesSet = addDefaultRackBookiesIfMinNumRacksIsEnforced(</span>
                    excludeBookies);
<span class="nc" id="L398">            PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsembleResult = newEnsembleInternal(ensembleSize,</span>
                    writeQuorumSize, ackQuorumSize, comprehensiveExclusionBookiesSet, null, null);
<span class="nc" id="L400">            return newEnsembleResult;</span>
        } finally {
<span class="nc" id="L402">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsemble(int ensembleSize,
                                                                  int writeQuorumSize,
                                                                  int ackQuorumSize,
                                                                  Set&lt;BookieId&gt; excludeBookies,
                                                                  Ensemble&lt;BookieNode&gt; parentEnsemble,
                                                                  Predicate&lt;BookieNode&gt; parentPredicate)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L414">        return newEnsembleInternal(</span>
                ensembleSize,
                writeQuorumSize,
                ackQuorumSize,
                excludeBookies,
                parentEnsemble,
                parentPredicate);
    }

    protected PlacementResult&lt;List&lt;BookieId&gt;&gt; newEnsembleInternal(
            int ensembleSize,
            int writeQuorumSize,
            int ackQuorumSize,
            Set&lt;BookieId&gt; excludeBookies,
            Ensemble&lt;BookieNode&gt; parentEnsemble,
            Predicate&lt;BookieNode&gt; parentPredicate) throws BKNotEnoughBookiesException {
<span class="nc" id="L430">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L432">            Set&lt;Node&gt; excludeNodes = convertBookiesToNodes(excludeBookies);</span>
<span class="nc" id="L433">            int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L434">            RRTopologyAwareCoverageEnsemble ensemble =</span>
                    new RRTopologyAwareCoverageEnsemble(
                            ensembleSize,
                            writeQuorumSize,
                            ackQuorumSize,
                            RACKNAME_DISTANCE_FROM_LEAVES,
                            parentEnsemble,
                            parentPredicate,
                            minNumRacksPerWriteQuorumForThisEnsemble);
<span class="nc" id="L443">            BookieNode prevNode = null;</span>
<span class="nc" id="L444">            int numRacks = topology.getNumOfRacks();</span>
            // only one rack, use the random algorithm.
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (numRacks &lt; 2) {</span>
<span class="nc bnc" id="L447" title="All 4 branches missed.">                if (enforceMinNumRacksPerWriteQuorum &amp;&amp; (minNumRacksPerWriteQuorumForThisEnsemble &gt; 1)) {</span>
<span class="nc" id="L448">                    LOG.error(&quot;Only one rack available and minNumRacksPerWriteQuorum is enforced, so giving up&quot;);</span>
<span class="nc" id="L449">                    throw new BKNotEnoughBookiesException();</span>
                }
<span class="nc" id="L451">                List&lt;BookieNode&gt; bns = selectRandom(ensembleSize, excludeNodes, TruePredicate.INSTANCE,</span>
                        ensemble);
<span class="nc" id="L453">                ArrayList&lt;BookieId&gt; addrs = new ArrayList&lt;BookieId&gt;(ensembleSize);</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">                for (BookieNode bn : bns) {</span>
<span class="nc" id="L455">                    addrs.add(bn.getAddr());</span>
<span class="nc" id="L456">                }</span>
<span class="nc" id="L457">                return PlacementResult.of(addrs, PlacementPolicyAdherence.FAIL);</span>
            }
            //Choose different rack nodes.
<span class="nc" id="L460">            String curRack = null;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            for (int i = 0; i &lt; ensembleSize; i++) {</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                if (null == prevNode) {</span>
<span class="nc bnc" id="L463" title="All 4 branches missed.">                    if ((null == localNode) || defaultRack.equals(localNode.getNetworkLocation())) {</span>
<span class="nc" id="L464">                        curRack = NodeBase.ROOT;</span>
                    } else {
<span class="nc" id="L466">                        curRack = localNode.getNetworkLocation();</span>
                    }
                } else {
<span class="nc bnc" id="L469" title="All 2 branches missed.">                    if (!curRack.startsWith(&quot;~&quot;)) {</span>
<span class="nc" id="L470">                        curRack = &quot;~&quot; + prevNode.getNetworkLocation();</span>
                    } else {
<span class="nc" id="L472">                        curRack = curRack + NetworkTopologyImpl.NODE_SEPARATOR + prevNode.getNetworkLocation();</span>
                    }
                }
<span class="nc bnc" id="L475" title="All 2 branches missed.">                boolean firstBookieInTheEnsemble = (null == prevNode);</span>
                try {
<span class="nc" id="L477">                    prevNode = selectRandomFromRack(curRack, excludeNodes, ensemble, ensemble);</span>
<span class="nc" id="L478">                } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">                    if (!curRack.equals(NodeBase.ROOT)) {</span>
<span class="nc" id="L480">                        curRack = NodeBase.ROOT;</span>
<span class="nc bnc" id="L481" title="All 4 branches missed.">                        prevNode = selectFromNetworkLocation(curRack, excludeNodes, ensemble, ensemble,</span>
                                !enforceMinNumRacksPerWriteQuorum || firstBookieInTheEnsemble);
                    } else {
<span class="nc" id="L484">                        throw e;</span>
                    }
<span class="nc" id="L486">                }</span>
            }
<span class="nc" id="L488">            List&lt;BookieId&gt; bookieList = ensemble.toList();</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">            if (ensembleSize != bookieList.size()) {</span>
<span class="nc" id="L490">                LOG.error(&quot;Not enough {} bookies are available to form an ensemble : {}.&quot;,</span>
<span class="nc" id="L491">                          ensembleSize, bookieList);</span>
<span class="nc" id="L492">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc" id="L494">            return PlacementResult.of(bookieList,</span>
<span class="nc" id="L495">                                      isEnsembleAdheringToPlacementPolicy(</span>
                                              bookieList, writeQuorumSize, ackQuorumSize));
        } finally {
<span class="nc" id="L498">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public PlacementResult&lt;BookieId&gt; replaceBookie(int ensembleSize, int writeQuorumSize, int ackQuorumSize,
            Map&lt;String, byte[]&gt; customMetadata, List&lt;BookieId&gt; currentEnsemble,
            BookieId bookieToReplace, Set&lt;BookieId&gt; excludeBookies)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L507">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L509">            excludeBookies = addDefaultRackBookiesIfMinNumRacksIsEnforced(excludeBookies);</span>
<span class="nc" id="L510">            excludeBookies.addAll(currentEnsemble);</span>

<span class="nc" id="L512">            Set&lt;Node&gt; ensembleNodes = new HashSet&lt;&gt;();</span>
<span class="nc" id="L513">            Set&lt;Node&gt; excludeNodes = new HashSet&lt;&gt;();</span>
<span class="nc" id="L514">            BookieNode bn = knownBookies.get(bookieToReplace);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            if (null == bn) {</span>
<span class="nc" id="L516">                bn = createBookieNode(bookieToReplace);</span>
            }
<span class="nc bnc" id="L518" title="All 2 branches missed.">            for (BookieId bookieId : currentEnsemble) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">                if (bookieId.equals(bookieToReplace)) {</span>
<span class="nc" id="L520">                    continue;</span>
                }
<span class="nc" id="L522">                ensembleNodes.add(convertBookieToNode(bookieId));</span>
<span class="nc" id="L523">            }</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">            for (BookieId bookieId : excludeBookies) {</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                if (bookieId.equals(bookieToReplace)) {</span>
<span class="nc" id="L526">                    excludeNodes.add(bn);</span>
<span class="nc" id="L527">                    continue;</span>
                }
<span class="nc" id="L529">                excludeNodes.add(convertBookieToNode(bookieId));</span>
<span class="nc" id="L530">            }</span>

<span class="nc" id="L532">            excludeNodes.addAll(ensembleNodes);</span>
<span class="nc" id="L533">            excludeNodes.add(bn);</span>
<span class="nc" id="L534">            ensembleNodes.remove(bn);</span>

<span class="nc" id="L536">            Set&lt;String&gt; networkLocationsToBeExcluded = getNetworkLocations(ensembleNodes);</span>

<span class="nc bnc" id="L538" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L539">                LOG.debug(&quot;Try to choose a new bookie to replace {} from ensemble {}, excluding {}.&quot;,</span>
                    bookieToReplace, ensembleNodes, excludeNodes);
            }
            // pick a candidate from same rack to replace
<span class="nc" id="L543">            BookieNode candidate = selectFromNetworkLocation(</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">                    bn.getNetworkLocation(),</span>
                    networkLocationsToBeExcluded,
                    excludeNodes,
                    TruePredicate.INSTANCE,
                    EnsembleForReplacementWithNoConstraints.INSTANCE,
                    !enforceMinNumRacksPerWriteQuorum);
<span class="nc bnc" id="L550" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L551">                LOG.debug(&quot;Bookie {} is chosen to replace bookie {}.&quot;, candidate, bn);</span>
            }
<span class="nc" id="L553">            BookieId candidateAddr = candidate.getAddr();</span>
<span class="nc" id="L554">            List&lt;BookieId&gt; newEnsemble = new ArrayList&lt;BookieId&gt;(currentEnsemble);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (currentEnsemble.isEmpty()) {</span>
                /*
                 * in testing code there are test cases which would pass empty
                 * currentEnsemble
                 */
<span class="nc" id="L560">                newEnsemble.add(candidateAddr);</span>
            } else {
<span class="nc" id="L562">                newEnsemble.set(currentEnsemble.indexOf(bookieToReplace), candidateAddr);</span>
            }
<span class="nc" id="L564">            return PlacementResult.of(candidateAddr,</span>
<span class="nc" id="L565">                    isEnsembleAdheringToPlacementPolicy(newEnsemble, writeQuorumSize, ackQuorumSize));</span>
        } finally {
<span class="nc" id="L567">            rwLock.readLock().unlock();</span>
        }
    }

    @Override
    public BookieNode selectFromNetworkLocation(
            String networkLoc,
            Set&lt;Node&gt; excludeBookies,
            Predicate&lt;BookieNode&gt; predicate,
            Ensemble&lt;BookieNode&gt; ensemble,
            boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {
        // select one from local rack
        try {
<span class="nc" id="L581">            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);</span>
<span class="nc" id="L582">        } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (!fallbackToRandom) {</span>
<span class="nc" id="L584">                LOG.error(</span>
                        &quot;Failed to choose a bookie from {} : &quot;
                                + &quot;excluded {}, enforceMinNumRacksPerWriteQuorum is enabled so giving up.&quot;,
                        networkLoc, excludeBookies);
<span class="nc" id="L588">                throw e;</span>
            }
<span class="nc" id="L590">            LOG.warn(&quot;Failed to choose a bookie from network location {}, &quot;</span>
                    + &quot;the bookies in the network location are {}, excluded bookies {}, &quot;
                    + &quot;current ensemble {}, fallback to choose bookie randomly from the cluster.&quot;,
<span class="nc" id="L593">                     networkLoc, topology.getLeaves(networkLoc), excludeBookies, ensemble.toList());</span>
            // randomly choose one from whole cluster, ignore the provided predicate.
<span class="nc" id="L595">            return selectRandom(1, excludeBookies, predicate, ensemble).get(0);</span>
        }
    }

    @Override
    public BookieNode selectFromNetworkLocation(String networkLoc,
                                                   Set&lt;String&gt; excludeRacks,
                                                   Set&lt;Node&gt; excludeBookies,
                                                   Predicate&lt;BookieNode&gt; predicate,
                                                   Ensemble&lt;BookieNode&gt; ensemble,
                                                   boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {
        // first attempt to select one from local rack
        try {
<span class="nc" id="L609">            return selectRandomFromRack(networkLoc, excludeBookies, predicate, ensemble);</span>
<span class="nc" id="L610">        } catch (BKNotEnoughBookiesException e) {</span>
            /*
             * there is no enough bookie from local rack, select bookies from
             * the whole cluster and exclude the racks specified at
             * &lt;tt&gt;excludeRacks&lt;/tt&gt;.
             */
<span class="nc" id="L616">            LOG.warn(&quot;Failed to choose a bookie node from network location {}, &quot;</span>
                    + &quot;the bookies in the network location are {}, excluded bookies {}, &quot;
                    + &quot;current ensemble {}, fallback to choose bookie randomly from the cluster.&quot;,
<span class="nc" id="L619">                networkLoc, topology.getLeaves(networkLoc), excludeBookies, ensemble.toList());</span>
<span class="nc" id="L620">            return selectFromNetworkLocation(excludeRacks, excludeBookies, predicate, ensemble, fallbackToRandom);</span>
        }
    }


    /**
     * It randomly selects a {@link BookieNode} that is not on the &lt;i&gt;excludeRacks&lt;/i&gt; set, excluding the nodes in
     * &lt;i&gt;excludeBookies&lt;/i&gt; set. If it fails to find one, it selects a random {@link BookieNode} from the whole
     * cluster.
     */
    @Override
    public BookieNode selectFromNetworkLocation(Set&lt;String&gt; excludeRacks,
                                                   Set&lt;Node&gt; excludeBookies,
                                                   Predicate&lt;BookieNode&gt; predicate,
                                                   Ensemble&lt;BookieNode&gt; ensemble,
                                                   boolean fallbackToRandom)
            throws BKNotEnoughBookiesException {

<span class="nc" id="L638">        List&lt;BookieNode&gt; knownNodes = new ArrayList&lt;&gt;(knownBookies.values());</span>
<span class="nc" id="L639">        Set&lt;Node&gt; fullExclusionBookiesList = new HashSet&lt;Node&gt;(excludeBookies);</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        for (BookieNode knownNode : knownNodes) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (excludeRacks.contains(knownNode.getNetworkLocation())) {</span>
<span class="nc" id="L642">                fullExclusionBookiesList.add(knownNode);</span>
            }
<span class="nc" id="L644">        }</span>

        try {
<span class="nc" id="L647">            return selectRandomInternal(knownNodes, 1, fullExclusionBookiesList, predicate, ensemble).get(0);</span>
<span class="nc" id="L648">        } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (!fallbackToRandom) {</span>
<span class="nc" id="L650">                LOG.error(</span>
                        &quot;Failed to choose a bookie excluding Racks: {} &quot;
                                + &quot;Nodes: {}, enforceMinNumRacksPerWriteQuorum is enabled so giving up.&quot;,
                        excludeRacks, excludeBookies);
<span class="nc" id="L654">                throw e;</span>
            }

<span class="nc" id="L657">            LOG.warn(&quot;Failed to choose a bookie: excluded {}, fallback to choose bookie randomly from the cluster.&quot;,</span>
                    excludeBookies);
            // randomly choose one from whole cluster
<span class="nc" id="L660">            return selectRandom(1, excludeBookies, predicate, ensemble).get(0);</span>
        }
    }

    private WeightedRandomSelection&lt;BookieNode&gt; prepareForWeightedSelection(List&lt;Node&gt; leaves) {
        // create a map of bookieNode-&gt;freeDiskSpace for this rack. The assumption is that
        // the number of nodes in a rack is of the order of 40, so it shouldn't be too bad
        // to build it every time during a ledger creation
<span class="nc" id="L668">        Map&lt;BookieNode, WeightedObject&gt; rackMap = new HashMap&lt;BookieNode, WeightedObject&gt;();</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">        for (Node n : leaves) {</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            if (!(n instanceof BookieNode)) {</span>
<span class="nc" id="L671">                continue;</span>
            }
<span class="nc" id="L673">            BookieNode bookie = (BookieNode) n;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">            if (this.bookieInfoMap.containsKey(bookie)) {</span>
<span class="nc" id="L675">                rackMap.put(bookie, this.bookieInfoMap.get(bookie));</span>
            } else {
<span class="nc" id="L677">                rackMap.put(bookie, new BookieInfo());</span>
            }
<span class="nc" id="L679">        }</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">        if (rackMap.size() == 0) {</span>
<span class="nc" id="L681">            return null;</span>
        }

<span class="nc" id="L684">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(</span>
                maxWeightMultiple);
<span class="nc" id="L686">        wRSelection.updateMap(rackMap);</span>
<span class="nc" id="L687">        return wRSelection;</span>
    }

    /**
     * Choose random node under a given network path.
     *
     * @param netPath
     *          network path
     * @param excludeBookies
     *          exclude bookies
     * @param predicate
     *          predicate to check whether the target is a good target.
     * @param ensemble
     *          ensemble structure
     * @return chosen bookie.
     */
    protected BookieNode selectRandomFromRack(String netPath, Set&lt;Node&gt; excludeBookies, Predicate&lt;BookieNode&gt; predicate,
            Ensemble&lt;BookieNode&gt; ensemble) throws BKNotEnoughBookiesException {
<span class="nc" id="L705">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = null;</span>
<span class="nc" id="L706">        List&lt;Node&gt; leaves = new ArrayList&lt;Node&gt;(topology.getLeaves(netPath));</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (!this.isWeighted) {</span>
<span class="nc" id="L708">            Collections.shuffle(leaves);</span>
        } else {
<span class="nc bnc" id="L710" title="All 2 branches missed.">            if (CollectionUtils.subtract(leaves, excludeBookies).size() &lt; 1) {</span>
<span class="nc" id="L711">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc" id="L713">            wRSelection = prepareForWeightedSelection(leaves);</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">            if (wRSelection == null) {</span>
<span class="nc" id="L715">                throw new BKNotEnoughBookiesException();</span>
            }
        }

<span class="nc" id="L719">        Iterator&lt;Node&gt; it = leaves.iterator();</span>
<span class="nc" id="L720">        Set&lt;Node&gt; bookiesSeenSoFar = new HashSet&lt;Node&gt;();</span>
        while (true) {
            Node n;
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (isWeighted) {</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if (bookiesSeenSoFar.size() == leaves.size()) {</span>
                    // Don't loop infinitely.
<span class="nc" id="L726">                    break;</span>
                }
<span class="nc" id="L728">                n = wRSelection.getNextRandom();</span>
<span class="nc" id="L729">                bookiesSeenSoFar.add(n);</span>
            } else {
<span class="nc bnc" id="L731" title="All 2 branches missed.">                if (it.hasNext()) {</span>
<span class="nc" id="L732">                    n = it.next();</span>
                } else {
                    break;
                }
            }
<span class="nc bnc" id="L737" title="All 2 branches missed.">            if (excludeBookies.contains(n)) {</span>
<span class="nc" id="L738">                continue;</span>
            }
<span class="nc bnc" id="L740" title="All 4 branches missed.">            if (!(n instanceof BookieNode) || !predicate.apply((BookieNode) n, ensemble)) {</span>
<span class="nc" id="L741">                continue;</span>
            }
<span class="nc" id="L743">            BookieNode bn = (BookieNode) n;</span>
            // got a good candidate
<span class="nc bnc" id="L745" title="All 2 branches missed.">            if (ensemble.addNode(bn)) {</span>
                // add the candidate to exclude set
<span class="nc" id="L747">                excludeBookies.add(bn);</span>
            }
<span class="nc" id="L749">            return bn;</span>
        }
<span class="nc" id="L751">        throw new BKNotEnoughBookiesException();</span>
    }

    /**
     * Choose a random node from whole cluster.
     *
     * @param numBookies
     *          number bookies to choose
     * @param excludeBookies
     *          bookies set to exclude.
     * @param ensemble
     *          ensemble to hold the bookie chosen.
     * @return the bookie node chosen.
     * @throws BKNotEnoughBookiesException
     */
    protected List&lt;BookieNode&gt; selectRandom(int numBookies,
                                            Set&lt;Node&gt; excludeBookies,
                                            Predicate&lt;BookieNode&gt; predicate,
                                            Ensemble&lt;BookieNode&gt; ensemble)
            throws BKNotEnoughBookiesException {
<span class="nc" id="L771">        return selectRandomInternal(null,  numBookies, excludeBookies, predicate, ensemble);</span>
    }

    protected List&lt;BookieNode&gt; selectRandomInternal(List&lt;BookieNode&gt; bookiesToSelectFrom,
                                                    int numBookies,
                                                    Set&lt;Node&gt; excludeBookies,
                                                    Predicate&lt;BookieNode&gt; predicate,
                                                    Ensemble&lt;BookieNode&gt; ensemble)
        throws BKNotEnoughBookiesException {
<span class="nc" id="L780">        WeightedRandomSelection&lt;BookieNode&gt; wRSelection = null;</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">        if (bookiesToSelectFrom == null) {</span>
            // If the list is null, we need to select from the entire knownBookies set
<span class="nc" id="L783">            wRSelection = this.weightedSelection;</span>
<span class="nc" id="L784">            bookiesToSelectFrom = new ArrayList&lt;BookieNode&gt;(knownBookies.values());</span>
        }
<span class="nc bnc" id="L786" title="All 2 branches missed.">        if (isWeighted) {</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (CollectionUtils.subtract(bookiesToSelectFrom, excludeBookies).size() &lt; numBookies) {</span>
<span class="nc" id="L788">                throw new BKNotEnoughBookiesException();</span>
            }
<span class="nc bnc" id="L790" title="All 2 branches missed.">            if (wRSelection == null) {</span>
<span class="nc" id="L791">                wRSelection = new WeightedRandomSelectionImpl&lt;BookieNode&gt;(this.maxWeightMultiple);</span>
            }

<span class="nc" id="L794">            Map&lt;BookieNode, WeightedObject&gt; rackMap = new HashMap&lt;BookieNode, WeightedObject&gt;();</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            for (BookieNode n : bookiesToSelectFrom) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">                if (this.bookieInfoMap.containsKey(n)) {</span>
<span class="nc" id="L797">                    rackMap.put(n, this.bookieInfoMap.get(n));</span>
                } else {
<span class="nc" id="L799">                    rackMap.put(n, new BookieInfo());</span>
                }
<span class="nc" id="L801">            }</span>
<span class="nc" id="L802">            wRSelection.updateMap(rackMap);</span>
<span class="nc" id="L803">        } else {</span>
<span class="nc" id="L804">            Collections.shuffle(bookiesToSelectFrom);</span>
        }

        BookieNode bookie;
<span class="nc" id="L808">        List&lt;BookieNode&gt; newBookies = new ArrayList&lt;BookieNode&gt;(numBookies);</span>
<span class="nc" id="L809">        Iterator&lt;BookieNode&gt; it = bookiesToSelectFrom.iterator();</span>
<span class="nc" id="L810">        Set&lt;BookieNode&gt; bookiesSeenSoFar = new HashSet&lt;BookieNode&gt;();</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">        while (numBookies &gt; 0) {</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">            if (isWeighted) {</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">                if (bookiesSeenSoFar.size() == bookiesToSelectFrom.size()) {</span>
                    // If we have gone through the whole available list of bookies,
                    // and yet haven't been able to satisfy the ensemble request, bail out.
                    // We don't want to loop infinitely.
<span class="nc" id="L817">                    break;</span>
                }
<span class="nc" id="L819">                bookie = wRSelection.getNextRandom();</span>
<span class="nc" id="L820">                bookiesSeenSoFar.add(bookie);</span>
            } else {
<span class="nc bnc" id="L822" title="All 2 branches missed.">                if (it.hasNext()) {</span>
<span class="nc" id="L823">                    bookie = it.next();</span>
                } else {
                    break;
                }
            }
<span class="nc bnc" id="L828" title="All 2 branches missed.">            if (excludeBookies.contains(bookie)) {</span>
<span class="nc" id="L829">                continue;</span>
            }

            // When durability is being enforced; we must not violate the
            // predicate even when selecting a random bookie; as durability
            // guarantee is not best effort; correctness is implied by it
<span class="nc bnc" id="L835" title="All 4 branches missed.">            if (enforceDurability &amp;&amp; !predicate.apply(bookie, ensemble)) {</span>
<span class="nc" id="L836">                continue;</span>
            }

<span class="nc bnc" id="L839" title="All 2 branches missed.">            if (ensemble.addNode(bookie)) {</span>
<span class="nc" id="L840">                excludeBookies.add(bookie);</span>
<span class="nc" id="L841">                newBookies.add(bookie);</span>
<span class="nc" id="L842">                --numBookies;</span>
            }
        }
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (numBookies == 0) {</span>
<span class="nc" id="L846">            return newBookies;</span>
        }
<span class="nc" id="L848">        LOG.warn(&quot;Failed to find {} bookies : excludeBookies {}, allBookies {}.&quot;,</span>
<span class="nc" id="L849">            numBookies, excludeBookies, bookiesToSelectFrom);</span>

<span class="nc" id="L851">        throw new BKNotEnoughBookiesException();</span>
    }

    @Override
    public void registerSlowBookie(BookieId bookieSocketAddress, long entryId) {
<span class="nc bnc" id="L856" title="All 2 branches missed.">        if (reorderThresholdPendingRequests &lt;= 0) {</span>
            // only put bookies on slowBookies list if reorderThresholdPendingRequests is *not* set (0);
            // otherwise, rely on reordering of reads based on reorderThresholdPendingRequests
<span class="nc" id="L859">            slowBookies.put(bookieSocketAddress, entryId);</span>
        }
<span class="nc" id="L861">    }</span>

    @Override
    public DistributionSchedule.WriteSet reorderReadSequence(
            List&lt;BookieId&gt; ensemble,
            BookiesHealthInfo bookiesHealthInfo,
            DistributionSchedule.WriteSet writeSet) {
<span class="nc" id="L868">        Map&lt;Integer, String&gt; writeSetWithRegion = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L870">            writeSetWithRegion.put(writeSet.get(i), &quot;&quot;);</span>
        }
<span class="nc" id="L872">        return reorderReadSequenceWithRegion(</span>
<span class="nc" id="L873">            ensemble, writeSet, writeSetWithRegion, bookiesHealthInfo, false, &quot;&quot;, writeSet.size());</span>
    }

    /**
     * This function orders the read sequence with a given region. For region-unaware policies (e.g.
     * RackAware), we pass in false for regionAware and an empty myRegion. When this happens, any
     * remote list will stay empty. The ordering is as follows (the R* at the beginning of each list item
     * is only present for region aware policies).
     *      1. available (local) bookies
     *      2. R* a remote bookie (based on remoteNodeInReorderSequence
     *      3. R* remaining (local) bookies
     *      4. R* remaining remote bookies
     *      5. read only bookies
     *      6. slow bookies
     *      7. unavailable bookies
     *
     * @param ensemble
     *          ensemble of bookies
     * @param writeSet
     *          write set
     * @param writeSetWithRegion
     *          write set with region information
     * @param bookiesHealthInfo
     *          heuristics about health of boookies
     * @param regionAware
     *          whether or not a region-aware policy is used
     * @param myRegion
     *          current region of policy
     * @param remoteNodeInReorderSequence
     *          number of local bookies to try before trying a remote bookie
     * @return ordering of bookies to send read to
     */
    DistributionSchedule.WriteSet reorderReadSequenceWithRegion(
        List&lt;BookieId&gt; ensemble,
        DistributionSchedule.WriteSet writeSet,
        Map&lt;Integer, String&gt; writeSetWithRegion,
        BookiesHealthInfo bookiesHealthInfo,
        boolean regionAware,
        String myRegion,
        int remoteNodeInReorderSequence) {
<span class="nc bnc" id="L913" title="All 4 branches missed.">        boolean useRegionAware = regionAware &amp;&amp; (!myRegion.equals(UNKNOWN_REGION));</span>
<span class="nc" id="L914">        int ensembleSize = ensemble.size();</span>

        // For rack aware, If all the bookies in the write set are available, simply return the original write set,
        // to avoid creating more lists
<span class="nc" id="L918">        boolean isAnyBookieUnavailable = false;</span>

<span class="nc bnc" id="L920" title="All 4 branches missed.">        if (useRegionAware || reorderReadsRandom) {</span>
<span class="nc" id="L921">            isAnyBookieUnavailable = true;</span>
        } else {
<span class="nc bnc" id="L923" title="All 2 branches missed.">            for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L924">                int idx = writeSet.get(i);</span>
<span class="nc" id="L925">                BookieId bookieAddr = ensemble.get(idx);</span>
<span class="nc bnc" id="L926" title="All 4 branches missed.">                if ((!knownBookies.containsKey(bookieAddr) &amp;&amp; !readOnlyBookies.contains(bookieAddr))</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">                    || slowBookies.getIfPresent(bookieAddr) != null) {</span>
                    // Found at least one bookie not available in the ensemble, or in slowBookies
<span class="nc" id="L929">                    isAnyBookieUnavailable = true;</span>
<span class="nc" id="L930">                    break;</span>
                }
            }
        }

<span class="nc" id="L935">        boolean reordered = false;</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">        if (reorderThresholdPendingRequests &gt; 0) {</span>
            // if there are no slow or unavailable bookies, capture each bookie's number of
            // pending request to reorder requests based on a threshold of pending requests

            // number of pending requests per bookie (same index as writeSet)
<span class="nc" id="L941">            long[] pendingReqs = new long[writeSet.size()];</span>
<span class="nc" id="L942">            int bestBookieIdx = -1;</span>

<span class="nc bnc" id="L944" title="All 2 branches missed.">            for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L945">                pendingReqs[i] = bookiesHealthInfo.getBookiePendingRequests(ensemble.get(writeSet.get(i)));</span>
<span class="nc bnc" id="L946" title="All 4 branches missed.">                if (bestBookieIdx &lt; 0 || pendingReqs[i] &lt; pendingReqs[bestBookieIdx]) {</span>
<span class="nc" id="L947">                    bestBookieIdx = i;</span>
                }
            }

            // reorder the writeSet if the currently first bookie in our writeSet has at
            // least
            // reorderThresholdPendingRequests more outstanding request than the best bookie
<span class="nc bnc" id="L954" title="All 4 branches missed.">            if (bestBookieIdx &gt; 0 &amp;&amp; pendingReqs[0] &gt;= pendingReqs[bestBookieIdx] + reorderThresholdPendingRequests) {</span>
                // We're not reordering the entire write set, but only move the best bookie
                // to the first place. Chances are good that this bookie will be fast enough
                // to not trigger the speculativeReadTimeout. But even if it hits that timeout,
                // things may have changed by then so much that whichever bookie we put second
                // may actually not be the second-best choice any more.
<span class="nc bnc" id="L960" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L961">                    LOG.debug(&quot;read set reordered from {} ({} pending) to {} ({} pending)&quot;,</span>
<span class="nc" id="L962">                            ensemble.get(writeSet.get(0)), pendingReqs[0], ensemble.get(writeSet.get(bestBookieIdx)),</span>
<span class="nc" id="L963">                            pendingReqs[bestBookieIdx]);</span>
                }
<span class="nc" id="L965">                writeSet.moveAndShift(bestBookieIdx, 0);</span>
<span class="nc" id="L966">                reordered = true;</span>
            }
        }

<span class="nc bnc" id="L970" title="All 2 branches missed.">        if (!isAnyBookieUnavailable) {</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">            if (reordered) {</span>
<span class="nc" id="L972">                readReorderedCounter.registerSuccessfulValue(1);</span>
            }
<span class="nc" id="L974">            return writeSet;</span>
        }

<span class="nc bnc" id="L977" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L978">            int idx = writeSet.get(i);</span>
<span class="nc" id="L979">            BookieId address = ensemble.get(idx);</span>
<span class="nc" id="L980">            String region = writeSetWithRegion.get(idx);</span>
<span class="nc" id="L981">            Long lastFailedEntryOnBookie = bookiesHealthInfo.getBookieFailureHistory(address);</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">            if (null == knownBookies.get(address)) {</span>
                // there isn't too much differences between readonly bookies
                // from unavailable bookies. since there
                // is no write requests to them, so we shouldn't try reading
                // from readonly bookie prior to writable bookies.
<span class="nc bnc" id="L987" title="All 2 branches missed.">                if ((null == readOnlyBookies)</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">                    || !readOnlyBookies.contains(address)) {</span>
<span class="nc" id="L989">                    writeSet.set(i, idx | UNAVAIL_MASK);</span>
                } else {
<span class="nc bnc" id="L991" title="All 2 branches missed.">                    if (slowBookies.getIfPresent(address) != null) {</span>
<span class="nc" id="L992">                        long numPendingReqs = bookiesHealthInfo.getBookiePendingRequests(address);</span>
                        // use slow bookies with less pending requests first
<span class="nc" id="L994">                        long slowIdx = numPendingReqs * ensembleSize + idx;</span>
<span class="nc" id="L995">                        writeSet.set(i, (int) (slowIdx &amp; ~MASK_BITS) | SLOW_MASK);</span>
<span class="nc" id="L996">                    } else {</span>
<span class="nc" id="L997">                        writeSet.set(i, idx | READ_ONLY_MASK);</span>
                    }
                }
<span class="nc bnc" id="L1000" title="All 2 branches missed.">            } else if (lastFailedEntryOnBookie &lt; 0) {</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                if (slowBookies.getIfPresent(address) != null) {</span>
<span class="nc" id="L1002">                    long numPendingReqs = bookiesHealthInfo.getBookiePendingRequests(address);</span>
<span class="nc" id="L1003">                    long slowIdx = numPendingReqs * ensembleSize + idx;</span>
<span class="nc" id="L1004">                    writeSet.set(i, (int) (slowIdx &amp; ~MASK_BITS) | SLOW_MASK);</span>
<span class="nc" id="L1005">                } else {</span>
<span class="nc bnc" id="L1006" title="All 4 branches missed.">                    if (useRegionAware &amp;&amp; !myRegion.equals(region)) {</span>
<span class="nc" id="L1007">                        writeSet.set(i, idx | REMOTE_MASK);</span>
                    } else {
<span class="nc" id="L1009">                        writeSet.set(i, idx | LOCAL_MASK);</span>
                    }
                }
            } else {
                // use bookies with earlier failed entryIds first
<span class="nc" id="L1014">                long failIdx = lastFailedEntryOnBookie * ensembleSize + idx;</span>
<span class="nc bnc" id="L1015" title="All 4 branches missed.">                if (useRegionAware &amp;&amp; !myRegion.equals(region)) {</span>
<span class="nc" id="L1016">                    writeSet.set(i, (int) (failIdx &amp; ~MASK_BITS) | REMOTE_FAIL_MASK);</span>
                } else {
<span class="nc" id="L1018">                    writeSet.set(i, (int) (failIdx &amp; ~MASK_BITS) | LOCAL_FAIL_MASK);</span>
                }
            }
        }

        // Add a mask to ensure the sort is stable, sort,
        // and then remove mask. This maintains stability as
        // long as there are fewer than 16 bookies in the write set.
<span class="nc bnc" id="L1026" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L1027">            writeSet.set(i, writeSet.get(i) | ((i &amp; 0xF) &lt;&lt; 20));</span>
        }
<span class="nc" id="L1029">        writeSet.sort();</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L1031">            writeSet.set(i, writeSet.get(i) &amp; ~((0xF) &lt;&lt; 20));</span>
        }

<span class="nc bnc" id="L1034" title="All 2 branches missed.">        if (reorderReadsRandom) {</span>
<span class="nc" id="L1035">            shuffleWithMask(writeSet, LOCAL_MASK, MASK_BITS);</span>
<span class="nc" id="L1036">            shuffleWithMask(writeSet, REMOTE_MASK, MASK_BITS);</span>
<span class="nc" id="L1037">            shuffleWithMask(writeSet, READ_ONLY_MASK, MASK_BITS);</span>
<span class="nc" id="L1038">            shuffleWithMask(writeSet, UNAVAIL_MASK, MASK_BITS);</span>
        }

        // nodes within a region are ordered as follows
        // (Random?) list of nodes that have no history of failure
        // Nodes with Failure history are ordered in the reverse
        // order of the most recent entry that generated an error
        // The sort will have put them in correct order,
        // so remove the bits that sort by age.
<span class="nc bnc" id="L1047" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L1048">            int mask = writeSet.get(i) &amp; MASK_BITS;</span>
<span class="nc" id="L1049">            int idx = (writeSet.get(i) &amp; ~MASK_BITS) % ensembleSize;</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            if (mask == LOCAL_FAIL_MASK) {</span>
<span class="nc" id="L1051">                writeSet.set(i, LOCAL_MASK | idx);</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">            } else if (mask == REMOTE_FAIL_MASK) {</span>
<span class="nc" id="L1053">                writeSet.set(i, REMOTE_MASK | idx);</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">            } else if (mask == SLOW_MASK) {</span>
<span class="nc" id="L1055">                writeSet.set(i, SLOW_MASK | idx);</span>
            }
        }

        // Insert a node from the remote region at the specified location so
        // we try more than one region within the max allowed latency
<span class="nc" id="L1061">        int firstRemote = -1;</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">            if ((writeSet.get(i) &amp; MASK_BITS) == REMOTE_MASK) {</span>
<span class="nc" id="L1064">                firstRemote = i;</span>
<span class="nc" id="L1065">                break;</span>
            }
        }
<span class="nc bnc" id="L1068" title="All 2 branches missed.">        if (firstRemote != -1) {</span>
<span class="nc" id="L1069">            int i = 0;</span>
            for (; i &lt; remoteNodeInReorderSequence
<span class="nc bnc" id="L1071" title="All 4 branches missed.">                &amp;&amp; i &lt; writeSet.size(); i++) {</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                if ((writeSet.get(i) &amp; MASK_BITS) != LOCAL_MASK) {</span>
<span class="nc" id="L1073">                    break;</span>
                }
            }
<span class="nc" id="L1076">            writeSet.moveAndShift(firstRemote, i);</span>
        }


        // remove all masks
<span class="nc bnc" id="L1081" title="All 2 branches missed.">        for (int i = 0; i &lt; writeSet.size(); i++) {</span>
<span class="nc" id="L1082">            writeSet.set(i, writeSet.get(i) &amp; ~MASK_BITS);</span>
        }
<span class="nc" id="L1084">        readReorderedCounter.registerSuccessfulValue(1);</span>
<span class="nc" id="L1085">        return writeSet;</span>
    }

    // this method should be called in readlock scope of 'rwlock'
    @Override
    public PlacementPolicyAdherence isEnsembleAdheringToPlacementPolicy(List&lt;BookieId&gt; ensembleList,
            int writeQuorumSize, int ackQuorumSize) {
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        if (CollectionUtils.isEmpty(ensembleList)) {</span>
<span class="nc" id="L1093">            return PlacementPolicyAdherence.FAIL;</span>
        }
<span class="nc" id="L1095">        int ensembleSize = ensembleList.size();</span>
<span class="nc" id="L1096">        int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L1097">        HashSet&lt;String&gt; racksInQuorum = new HashSet&lt;String&gt;();</span>
        BookieId bookie;
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        for (int i = 0; i &lt; ensembleList.size(); i++) {</span>
<span class="nc" id="L1100">            racksInQuorum.clear();</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">            for (int j = 0; j &lt; writeQuorumSize; j++) {</span>
<span class="nc" id="L1102">                bookie = ensembleList.get((i + j) % ensembleSize);</span>
                try {
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                    if (knownBookies.containsKey(bookie)) {</span>
<span class="nc" id="L1105">                        racksInQuorum.add(knownBookies.get(bookie).getNetworkLocation());</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                    } else if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1107">                        LOG.debug(&quot;bookie {} is not in the list of knownBookies&quot;, bookie);</span>
                    }
<span class="nc" id="L1109">                } catch (Exception e) {</span>
                    /*
                     * any issue/exception in analyzing whether ensemble is
                     * strictly adhering to placement policy should be
                     * swallowed.
                     */
<span class="nc" id="L1115">                    LOG.warn(&quot;Received exception while trying to get network location of bookie: {}&quot;, bookie, e);</span>
<span class="nc" id="L1116">                }</span>
            }
<span class="nc bnc" id="L1118" title="All 4 branches missed.">            if ((racksInQuorum.size() &lt; minNumRacksPerWriteQuorumForThisEnsemble)</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">                    || (enforceMinNumRacksPerWriteQuorum &amp;&amp; racksInQuorum.contains(getDefaultRack()))) {</span>
<span class="nc" id="L1120">                return PlacementPolicyAdherence.FAIL;</span>
            }
        }
<span class="nc" id="L1123">        return PlacementPolicyAdherence.MEETS_STRICT;</span>
    }

    @Override
    public boolean areAckedBookiesAdheringToPlacementPolicy(Set&lt;BookieId&gt; ackedBookies,
                                                            int writeQuorumSize,
                                                            int ackQuorumSize) {
<span class="nc" id="L1130">        HashSet&lt;String&gt; rackCounter = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1131">        int minWriteQuorumNumRacksPerWriteQuorum = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>

<span class="nc" id="L1133">        ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();</span>
<span class="nc" id="L1134">        readLock.lock();</span>
        try {
<span class="nc bnc" id="L1136" title="All 2 branches missed.">            for (BookieId bookie : ackedBookies) {</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">                if (knownBookies.containsKey(bookie)) {</span>
<span class="nc" id="L1138">                    rackCounter.add(knownBookies.get(bookie).getNetworkLocation());</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">                } else if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1140">                    LOG.debug(&quot;bookie {} is not in the list of knownBookies&quot;, bookie);</span>
                }
<span class="nc" id="L1142">            }</span>

            // Check to make sure that ensemble is writing to `minNumberOfRacks`'s number of racks at least.
<span class="nc bnc" id="L1145" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1146">                LOG.debug(&quot;areAckedBookiesAdheringToPlacementPolicy returning {} because number of racks = {} and &quot;</span>
                          + &quot;minNumRacksPerWriteQuorum = {}&quot;,
<span class="nc bnc" id="L1148" title="All 2 branches missed.">                          rackCounter.size() &gt;= minNumRacksPerWriteQuorum,</span>
<span class="nc" id="L1149">                          rackCounter.size(),</span>
<span class="nc" id="L1150">                          minNumRacksPerWriteQuorum);</span>
            }
        } finally {
<span class="nc" id="L1153">            readLock.unlock();</span>
        }
<span class="nc bnc" id="L1155" title="All 2 branches missed.">        return rackCounter.size() &gt;= minWriteQuorumNumRacksPerWriteQuorum;</span>
    }

    @Override
    public PlacementResult&lt;List&lt;BookieId&gt;&gt; replaceToAdherePlacementPolicy(
            int ensembleSize,
            int writeQuorumSize,
            int ackQuorumSize,
            Set&lt;BookieId&gt; excludeBookies,
            List&lt;BookieId&gt; currentEnsemble) {
<span class="nc" id="L1165">        rwLock.readLock().lock();</span>
        try {
<span class="nc" id="L1167">            PlacementPolicyAdherence currentPlacementAdherence = isEnsembleAdheringToPlacementPolicy(</span>
                    currentEnsemble, writeQuorumSize, ackQuorumSize);
<span class="nc bnc" id="L1169" title="All 2 branches missed.">            if (PlacementPolicyAdherence.FAIL != currentPlacementAdherence) {</span>
<span class="nc" id="L1170">                return PlacementResult.of(new ArrayList&lt;&gt;(currentEnsemble), currentPlacementAdherence);</span>
            }
<span class="nc bnc" id="L1172" title="All 2 branches missed.">            for (BookieId bookieId : currentEnsemble) {</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                if (!knownBookies.containsKey(bookieId)) {</span>
<span class="nc" id="L1174">                    excludeBookies.add(bookieId);</span>
                }
<span class="nc" id="L1176">            }</span>
<span class="nc" id="L1177">            int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L1178">            int numRacks = topology.getNumOfRacks();</span>
            // only one rack or less than minNumRacksPerWriteQuorumForThisEnsemble, stop calculation to skip relocation
<span class="nc bnc" id="L1180" title="All 4 branches missed.">            if (numRacks &lt; 2 || numRacks &lt; minNumRacksPerWriteQuorumForThisEnsemble) {</span>
<span class="nc" id="L1181">                LOG.warn(&quot;Skip ensemble relocation because the cluster has only {} rack.&quot;, numRacks);</span>
<span class="nc" id="L1182">                return PlacementResult.of(Collections.emptyList(), PlacementPolicyAdherence.FAIL);</span>
            }
<span class="nc" id="L1184">            PlacementResult&lt;List&lt;BookieId&gt;&gt; placementResult = PlacementResult.of(Collections.emptyList(),</span>
                    PlacementPolicyAdherence.FAIL);
<span class="nc" id="L1186">            int minDiffer = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            for (int i = 0; i &lt; currentEnsemble.size(); i++) {</span>
<span class="nc" id="L1188">                PlacementResult&lt;List&lt;BookieId&gt;&gt; result = doReplaceToAdherePlacementPolicy(ensembleSize,</span>
                        writeQuorumSize, ackQuorumSize, excludeBookies, currentEnsemble, i);
<span class="nc bnc" id="L1190" title="All 2 branches missed.">                if (PlacementPolicyAdherence.FAIL == result.getAdheringToPolicy()) {</span>
<span class="nc" id="L1191">                    continue;</span>
                }
<span class="nc" id="L1193">                int differ = differBetweenBookies(currentEnsemble, result.getResult());</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">                if (differ &lt; minDiffer) {</span>
<span class="nc" id="L1195">                    minDiffer = differ;</span>
<span class="nc" id="L1196">                    placementResult = result;</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">                    if (minDiffer == 1) {</span>
<span class="nc" id="L1198">                        break;</span>
                    }
                }
            }
<span class="nc" id="L1202">            return placementResult;</span>
        } finally {
<span class="nc" id="L1204">            rwLock.readLock().unlock();</span>
        }
    }

    private PlacementResult&lt;List&lt;BookieId&gt;&gt; doReplaceToAdherePlacementPolicy(
            int ensembleSize,
            int writeQuorumSize,
            int ackQuorumSize,
            Set&lt;BookieId&gt; excludeBookies,
            List&lt;BookieId&gt; currentEnsemble,
            int startIndex) {
<span class="nc" id="L1215">        final List&lt;BookieNode&gt; provisionalEnsembleNodes = currentEnsemble.stream()</span>
<span class="nc" id="L1216">                .map(this::convertBookieToNode).collect(Collectors.toList());</span>
<span class="nc" id="L1217">        final Set&lt;Node&gt; excludeNodes = convertBookiesToNodes(</span>
<span class="nc" id="L1218">                addDefaultRackBookiesIfMinNumRacksIsEnforced(excludeBookies));</span>
<span class="nc" id="L1219">        int minNumRacksPerWriteQuorumForThisEnsemble = Math.min(writeQuorumSize, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L1220">        final RRTopologyAwareCoverageEnsemble ensemble =</span>
                new RRTopologyAwareCoverageEnsemble(
                        ensembleSize,
                        writeQuorumSize,
                        ackQuorumSize,
                        RACKNAME_DISTANCE_FROM_LEAVES,
                        null,
                        null,
                        minNumRacksPerWriteQuorumForThisEnsemble);
<span class="nc" id="L1229">        BookieNode prevNode = null;</span>
<span class="nc" id="L1230">        final BookieNode firstNode = provisionalEnsembleNodes.get(startIndex);</span>
        // use same bookie at first to reduce ledger replication
<span class="nc bnc" id="L1232" title="All 4 branches missed.">        if (!excludeNodes.contains(firstNode) &amp;&amp; ensemble.apply(firstNode, ensemble)</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">                &amp;&amp; ensemble.addNode(firstNode)) {</span>
<span class="nc" id="L1234">            excludeNodes.add(firstNode);</span>
<span class="nc" id="L1235">            prevNode = firstNode;</span>
        }
<span class="nc bnc" id="L1237" title="All 4 branches missed.">        for (int i = prevNode == null ? 0 : 1; i &lt; ensembleSize; i++) {</span>
<span class="nc" id="L1238">            int index = (startIndex + i) % ensembleSize;</span>
            final String curRack;
<span class="nc bnc" id="L1240" title="All 2 branches missed.">            if (null == prevNode) {</span>
<span class="nc bnc" id="L1241" title="All 4 branches missed.">                if ((null == localNode) || defaultRack.equals(localNode.getNetworkLocation())) {</span>
<span class="nc" id="L1242">                    curRack = NodeBase.ROOT;</span>
                } else {
<span class="nc" id="L1244">                    curRack = localNode.getNetworkLocation();</span>
                }
            } else {
<span class="nc" id="L1247">                curRack = NetworkTopologyImpl.INVERSE + prevNode.getNetworkLocation();</span>
            }
            try {
<span class="nc" id="L1250">                prevNode = replaceToAdherePlacementPolicyInternal(</span>
                        curRack, excludeNodes, ensemble, ensemble,
                        provisionalEnsembleNodes, index, ensembleSize, minNumRacksPerWriteQuorumForThisEnsemble);
                // got a good candidate
<span class="nc bnc" id="L1254" title="All 2 branches missed.">                if (ensemble.addNode(prevNode)) {</span>
                    // add the candidate to exclude set
<span class="nc" id="L1256">                    excludeNodes.add(prevNode);</span>
                } else {
<span class="nc" id="L1258">                    throw new BKNotEnoughBookiesException();</span>
                }
                // replace to newer node
<span class="nc" id="L1261">                provisionalEnsembleNodes.set(index, prevNode);</span>
<span class="nc" id="L1262">            } catch (BKNotEnoughBookiesException e) {</span>
<span class="nc" id="L1263">                LOG.warn(&quot;Skip ensemble relocation because the cluster has not enough bookies.&quot;);</span>
<span class="nc" id="L1264">                return PlacementResult.of(Collections.emptyList(), PlacementPolicyAdherence.FAIL);</span>
<span class="nc" id="L1265">            }</span>
        }
<span class="nc" id="L1267">        List&lt;BookieId&gt; bookieList = ensemble.toList();</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">        if (ensembleSize != bookieList.size()) {</span>
<span class="nc" id="L1269">            LOG.warn(&quot;Not enough {} bookies are available to form an ensemble : {}.&quot;,</span>
<span class="nc" id="L1270">                    ensembleSize, bookieList);</span>
<span class="nc" id="L1271">            return PlacementResult.of(Collections.emptyList(), PlacementPolicyAdherence.FAIL);</span>
        }
<span class="nc" id="L1273">        PlacementPolicyAdherence placementPolicyAdherence = isEnsembleAdheringToPlacementPolicy(bookieList,</span>
                writeQuorumSize, ackQuorumSize);
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        if (PlacementPolicyAdherence.FAIL == placementPolicyAdherence) {</span>
<span class="nc" id="L1276">            return PlacementResult.of(Collections.emptyList(), PlacementPolicyAdherence.FAIL);</span>
        }
<span class="nc" id="L1278">        return PlacementResult.of(revertBookieListByIndex(bookieList, startIndex), placementPolicyAdherence);</span>
    }

    private List&lt;BookieId&gt; revertBookieListByIndex(List&lt;BookieId&gt; bookies, int startIndex) {
<span class="nc" id="L1282">        BookieId[] bookieIds = new BookieId[bookies.size()];</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">        for (int i = 0; i &lt; bookies.size(); i++) {</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">            if (startIndex == bookies.size()) {</span>
<span class="nc" id="L1285">                startIndex = 0;</span>
            }
<span class="nc" id="L1287">            bookieIds[startIndex++] = bookies.get(i);</span>
        }
<span class="nc" id="L1289">        return Lists.newArrayList(bookieIds);</span>
    }

    private BookieNode replaceToAdherePlacementPolicyInternal(
            String netPath, Set&lt;Node&gt; excludeBookies, Predicate&lt;BookieNode&gt; predicate,
            Ensemble&lt;BookieNode&gt; ensemble, List&lt;BookieNode&gt; provisionalEnsembleNodes, int ensembleIndex,
            int ensembleSize, int minNumRacksPerWriteQuorumForThisEnsemble) throws BKNotEnoughBookiesException {
<span class="nc" id="L1296">        final BookieNode currentNode = provisionalEnsembleNodes.get(ensembleIndex);</span>
        // if the current bookie could be applied to the ensemble, apply it to minify the number of bookies replaced
<span class="nc bnc" id="L1298" title="All 4 branches missed.">        if (!excludeBookies.contains(currentNode) &amp;&amp; predicate.apply(currentNode, ensemble)) {</span>
<span class="nc" id="L1299">            return currentNode;</span>
        }
<span class="nc" id="L1301">        final List&lt;Pair&lt;String, List&lt;BookieNode&gt;&gt;&gt; conditionList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1302">        final Set&lt;String&gt; preExcludeRacks = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1303">        final Set&lt;String&gt; postExcludeRacks = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        for (int i = 0; i &lt; minNumRacksPerWriteQuorumForThisEnsemble - 1; i++) {</span>
<span class="nc" id="L1305">            preExcludeRacks.add(provisionalEnsembleNodes.get(Math.floorMod((ensembleIndex - i - 1), ensembleSize))</span>
<span class="nc" id="L1306">                    .getNetworkLocation());</span>
<span class="nc" id="L1307">            postExcludeRacks.add(provisionalEnsembleNodes.get(Math.floorMod((ensembleIndex + i + 1), ensembleSize))</span>
<span class="nc" id="L1308">                    .getNetworkLocation());</span>
        }
        // adhere minNumRacksPerWriteQuorum by preExcludeRacks
        // avoid additional replace from write quorum candidates by preExcludeRacks and postExcludeRacks
        // avoid to use first candidate bookies for election by provisionalEnsembleNodes
<span class="nc" id="L1313">        conditionList.add(Pair.of(</span>
<span class="nc" id="L1314">                NetworkTopologyImpl.INVERSE + String.join(&quot;,&quot;,</span>
<span class="nc" id="L1315">                        Stream.concat(preExcludeRacks.stream(), postExcludeRacks.stream()).collect(Collectors.toSet())),</span>
                provisionalEnsembleNodes
        ));
        // avoid to use same rack between previous index by netPath
        // avoid to use first candidate bookies for election by provisionalEnsembleNodes
<span class="nc" id="L1320">        conditionList.add(Pair.of(netPath, provisionalEnsembleNodes));</span>
        // avoid to use same rack between previous index by netPath
<span class="nc" id="L1322">        conditionList.add(Pair.of(netPath, Collections.emptyList()));</span>

<span class="nc bnc" id="L1324" title="All 2 branches missed.">        for (Pair&lt;String, List&lt;BookieNode&gt;&gt; condition : conditionList) {</span>
<span class="nc" id="L1325">            WeightedRandomSelection&lt;BookieNode&gt; wRSelection = null;</span>

<span class="nc" id="L1327">            final List&lt;Node&gt; leaves = new ArrayList&lt;&gt;(topology.getLeaves(condition.getLeft()));</span>
<span class="nc bnc" id="L1328" title="All 2 branches missed.">            if (!isWeighted) {</span>
<span class="nc" id="L1329">                Collections.shuffle(leaves);</span>
            } else {
<span class="nc bnc" id="L1331" title="All 2 branches missed.">                if (CollectionUtils.subtract(leaves, excludeBookies).size() &lt; 1) {</span>
<span class="nc" id="L1332">                    throw new BKNotEnoughBookiesException();</span>
                }
<span class="nc" id="L1334">                wRSelection = prepareForWeightedSelection(leaves);</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">                if (wRSelection == null) {</span>
<span class="nc" id="L1336">                    throw new BKNotEnoughBookiesException();</span>
                }
            }

<span class="nc" id="L1340">            final Iterator&lt;Node&gt; it = leaves.iterator();</span>
<span class="nc" id="L1341">            final Set&lt;Node&gt; bookiesSeenSoFar = new HashSet&lt;&gt;();</span>
            while (true) {
                Node n;
<span class="nc bnc" id="L1344" title="All 2 branches missed.">                if (isWeighted) {</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">                    if (bookiesSeenSoFar.size() == leaves.size()) {</span>
                        // Don't loop infinitely.
<span class="nc" id="L1347">                        break;</span>
                    }
<span class="nc" id="L1349">                    n = wRSelection.getNextRandom();</span>
<span class="nc" id="L1350">                    bookiesSeenSoFar.add(n);</span>
                } else {
<span class="nc bnc" id="L1352" title="All 2 branches missed.">                    if (it.hasNext()) {</span>
<span class="nc" id="L1353">                        n = it.next();</span>
                    } else {
                        break;
                    }
                }
<span class="nc bnc" id="L1358" title="All 2 branches missed.">                if (excludeBookies.contains(n)) {</span>
<span class="nc" id="L1359">                    continue;</span>
                }
<span class="nc bnc" id="L1361" title="All 4 branches missed.">                if (!(n instanceof BookieNode) || !predicate.apply((BookieNode) n, ensemble)) {</span>
<span class="nc" id="L1362">                    continue;</span>
                }
                // additional excludeBookies
<span class="nc bnc" id="L1365" title="All 2 branches missed.">                if (condition.getRight().contains(n)) {</span>
<span class="nc" id="L1366">                    continue;</span>
                }
<span class="nc" id="L1368">                BookieNode bn = (BookieNode) n;</span>
<span class="nc" id="L1369">                return bn;</span>
            }
<span class="nc" id="L1371">        }</span>
<span class="nc" id="L1372">        throw new BKNotEnoughBookiesException();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>