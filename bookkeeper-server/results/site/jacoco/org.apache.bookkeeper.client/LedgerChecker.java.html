<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LedgerChecker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">LedgerChecker.java</span></div><h1>LedgerChecker.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.client;

import io.netty.buffer.ByteBuf;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Semaphore;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import org.apache.bookkeeper.client.BKException.Code;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.proto.BookieClient;
import org.apache.bookkeeper.proto.BookieProtocol;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.GenericCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.ReadEntryCallback;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A utility class to check the complete ledger and finds the UnderReplicated fragments if any.
 *
 * &lt;p&gt;NOTE: This class is tended to be used by this project only. External users should not rely on it directly.
 */
public class LedgerChecker {
<span class="nc" id="L51">    private static final Logger LOG = LoggerFactory.getLogger(LedgerChecker.class);</span>

    public final BookieClient bookieClient;
    public final BookieWatcher bookieWatcher;

    final Semaphore semaphore;

<span class="nc" id="L58">    static class InvalidFragmentException extends Exception {</span>
        private static final long serialVersionUID = 1467201276417062353L;
    }

    /**
     * This will collect all the entry read call backs and finally it will give
     * call back to previous call back API which is waiting for it once it meets
     * the expected call backs from down.
     */
    private class ReadManyEntriesCallback implements ReadEntryCallback {
<span class="nc" id="L68">        AtomicBoolean completed = new AtomicBoolean(false);</span>
        final AtomicLong numEntries;
        final LedgerFragment fragment;
        final GenericCallback&lt;LedgerFragment&gt; cb;

        ReadManyEntriesCallback(long numEntries, LedgerFragment fragment,
<span class="nc" id="L74">                GenericCallback&lt;LedgerFragment&gt; cb) {</span>
<span class="nc" id="L75">            this.numEntries = new AtomicLong(numEntries);</span>
<span class="nc" id="L76">            this.fragment = fragment;</span>
<span class="nc" id="L77">            this.cb = cb;</span>
<span class="nc" id="L78">        }</span>

        @Override
        public void readEntryComplete(int rc, long ledgerId, long entryId,
                ByteBuf buffer, Object ctx) {
<span class="nc" id="L83">            releasePermit();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">            if (rc == Code.OK) {</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">                if (numEntries.decrementAndGet() == 0</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">                        &amp;&amp; !completed.getAndSet(true)) {</span>
<span class="nc" id="L87">                    cb.operationComplete(rc, fragment);</span>
                }
<span class="nc bnc" id="L89" title="All 2 branches missed.">            } else if (!completed.getAndSet(true)) {</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">                if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L91">                    LOG.debug(&quot;Read {}:{} from {} failed, the error code: {}&quot;, ledgerId, entryId, ctx, rc);</span>
                }
<span class="nc" id="L93">                cb.operationComplete(rc, fragment);</span>
            }
<span class="nc" id="L95">        }</span>
    }

    /**
     * This will collect the bad bookies inside a ledger fragment.
     */
    private static class LedgerFragmentCallback implements GenericCallback&lt;LedgerFragment&gt; {

        private final LedgerFragment fragment;
        private final int bookieIndex;
        // bookie index -&gt; return code
        private final Map&lt;Integer, Integer&gt; badBookies;
        private final AtomicInteger numBookies;
        private final GenericCallback&lt;LedgerFragment&gt; cb;

        LedgerFragmentCallback(LedgerFragment lf,
                               int bookieIndex,
                               GenericCallback&lt;LedgerFragment&gt; cb,
                               Map&lt;Integer, Integer&gt; badBookies,
<span class="nc" id="L114">                               AtomicInteger numBookies) {</span>
<span class="nc" id="L115">            this.fragment = lf;</span>
<span class="nc" id="L116">            this.bookieIndex = bookieIndex;</span>
<span class="nc" id="L117">            this.cb = cb;</span>
<span class="nc" id="L118">            this.badBookies = badBookies;</span>
<span class="nc" id="L119">            this.numBookies = numBookies;</span>
<span class="nc" id="L120">        }</span>

        @Override
        public void operationComplete(int rc, LedgerFragment lf) {
<span class="nc bnc" id="L124" title="All 2 branches missed.">            if (Code.OK != rc) {</span>
<span class="nc" id="L125">                synchronized (badBookies) {</span>
<span class="nc" id="L126">                    badBookies.put(bookieIndex, rc);</span>
<span class="nc" id="L127">                }</span>
            }
<span class="nc bnc" id="L129" title="All 2 branches missed.">            if (numBookies.decrementAndGet() == 0) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">                if (badBookies.isEmpty()) {</span>
<span class="nc" id="L131">                    cb.operationComplete(Code.OK, fragment);</span>
                } else {
<span class="nc" id="L133">                    int rcToReturn = Code.NoBookieAvailableException;</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">                    for (Map.Entry&lt;Integer, Integer&gt; entry : badBookies.entrySet()) {</span>
<span class="nc" id="L135">                        rcToReturn = entry.getValue();</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">                        if (entry.getValue() == Code.ClientClosedException) {</span>
<span class="nc" id="L137">                            break;</span>
                        }
<span class="nc" id="L139">                    }</span>
<span class="nc" id="L140">                    cb.operationComplete(rcToReturn,</span>
<span class="nc" id="L141">                            fragment.subset(badBookies.keySet()));</span>
                }
            }
<span class="nc" id="L144">        }</span>
    }

    public LedgerChecker(BookKeeper bkc) {
<span class="nc" id="L148">        this(bkc.getBookieClient(), bkc.getBookieWatcher());</span>
<span class="nc" id="L149">    }</span>

    public LedgerChecker(BookieClient client, BookieWatcher watcher) {
<span class="nc" id="L152">        this(client, watcher, -1);</span>
<span class="nc" id="L153">    }</span>

    public LedgerChecker(BookKeeper bkc, int inFlightReadEntryNum) {
<span class="nc" id="L156">        this(bkc.getBookieClient(), bkc.getBookieWatcher(), inFlightReadEntryNum);</span>
<span class="nc" id="L157">    }</span>

<span class="nc" id="L159">    public LedgerChecker(BookieClient client, BookieWatcher watcher, int inFlightReadEntryNum) {</span>
<span class="nc" id="L160">        bookieClient = client;</span>
<span class="nc" id="L161">        bookieWatcher = watcher;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (inFlightReadEntryNum &gt; 0) {</span>
<span class="nc" id="L163">            semaphore = new Semaphore(inFlightReadEntryNum);</span>
        } else {
<span class="nc" id="L165">            semaphore = null;</span>
        }
<span class="nc" id="L167">    }</span>

    /**
     * Acquires a permit from permit manager,
     * blocking until all are available.
     */
    public void acquirePermit() throws InterruptedException {
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (null != semaphore) {</span>
<span class="nc" id="L175">            semaphore.acquire(1);</span>
        }
<span class="nc" id="L177">    }</span>

    /**
     * Release a given permit.
     */
    public void releasePermit() {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (null != semaphore) {</span>
<span class="nc" id="L184">            semaphore.release();</span>
        }
<span class="nc" id="L186">    }</span>

    /**
     * Verify a ledger fragment to collect bad bookies.
     *
     * @param fragment
     *          fragment to verify
     * @param cb
     *          callback
     * @throws InvalidFragmentException
     */
    private void verifyLedgerFragment(LedgerFragment fragment,
                                      GenericCallback&lt;LedgerFragment&gt; cb,
                                      Long percentageOfLedgerFragmentToBeVerified)
            throws InvalidFragmentException, BKException, InterruptedException {
<span class="nc" id="L201">        Set&lt;Integer&gt; bookiesToCheck = fragment.getBookiesIndexes();</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (bookiesToCheck.isEmpty()) {</span>
<span class="nc" id="L203">            cb.operationComplete(Code.OK, fragment);</span>
<span class="nc" id="L204">            return;</span>
        }

<span class="nc" id="L207">        AtomicInteger numBookies = new AtomicInteger(bookiesToCheck.size());</span>
<span class="nc" id="L208">        Map&lt;Integer, Integer&gt; badBookies = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        for (Integer bookieIndex : bookiesToCheck) {</span>
<span class="nc" id="L210">            LedgerFragmentCallback lfCb = new LedgerFragmentCallback(</span>
<span class="nc" id="L211">                    fragment, bookieIndex, cb, badBookies, numBookies);</span>
<span class="nc" id="L212">            verifyLedgerFragment(fragment, bookieIndex, lfCb, percentageOfLedgerFragmentToBeVerified);</span>
<span class="nc" id="L213">        }</span>
<span class="nc" id="L214">    }</span>

    /**
     * Verify a bookie inside a ledger fragment.
     *
     * @param fragment
     *          ledger fragment
     * @param bookieIndex
     *          bookie index in the fragment
     * @param cb
     *          callback
     * @throws InvalidFragmentException
     */
    private void verifyLedgerFragment(LedgerFragment fragment,
                                      int bookieIndex,
                                      GenericCallback&lt;LedgerFragment&gt; cb,
                                      long percentageOfLedgerFragmentToBeVerified)
            throws InvalidFragmentException, InterruptedException {
<span class="nc" id="L232">        long firstStored = fragment.getFirstStoredEntryId(bookieIndex);</span>
<span class="nc" id="L233">        long lastStored = fragment.getLastStoredEntryId(bookieIndex);</span>

<span class="nc" id="L235">        BookieId bookie = fragment.getAddress(bookieIndex);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (null == bookie) {</span>
<span class="nc" id="L237">            throw new InvalidFragmentException();</span>
        }

<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (firstStored == LedgerHandle.INVALID_ENTRY_ID) {</span>
            // this fragment is not on this bookie
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (lastStored != LedgerHandle.INVALID_ENTRY_ID) {</span>
<span class="nc" id="L243">                throw new InvalidFragmentException();</span>
            }

<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (bookieWatcher.isBookieUnavailable(fragment.getAddress(bookieIndex))) {</span>
                // fragment is on this bookie, but already know it's unavailable, so skip the call
<span class="nc" id="L248">                cb.operationComplete(Code.BookieHandleNotAvailableException, fragment);</span>
            } else {
<span class="nc" id="L250">                cb.operationComplete(Code.OK, fragment);</span>
            }
<span class="nc bnc" id="L252" title="All 2 branches missed.">        } else if (bookieWatcher.isBookieUnavailable(fragment.getAddress(bookieIndex))) {</span>
            // fragment is on this bookie, but already know it's unavailable, so skip the call
<span class="nc" id="L254">            cb.operationComplete(Code.BookieHandleNotAvailableException, fragment);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">        } else if (firstStored == lastStored) {</span>
<span class="nc" id="L256">            acquirePermit();</span>
<span class="nc" id="L257">            ReadManyEntriesCallback manycb = new ReadManyEntriesCallback(1,</span>
                    fragment, cb);
<span class="nc" id="L259">            bookieClient.readEntry(bookie, fragment.getLedgerId(), firstStored,</span>
                                   manycb, bookie, BookieProtocol.FLAG_NONE);
<span class="nc" id="L261">        } else {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (lastStored &lt;= firstStored) {</span>
<span class="nc" id="L263">                cb.operationComplete(Code.IncorrectParameterException, null);</span>
<span class="nc" id="L264">                return;</span>
            }

<span class="nc" id="L267">            long lengthOfLedgerFragment = lastStored - firstStored + 1;</span>

<span class="nc" id="L269">            int numberOfEntriesToBeVerified =</span>
                (int) (lengthOfLedgerFragment * (percentageOfLedgerFragmentToBeVerified / 100.0));

<span class="nc" id="L272">            TreeSet&lt;Long&gt; entriesToBeVerified = new TreeSet&lt;Long&gt;();</span>

<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (numberOfEntriesToBeVerified &lt; lengthOfLedgerFragment) {</span>
                // Evenly pick random entries over the length of the fragment
<span class="nc bnc" id="L276" title="All 2 branches missed.">                if (numberOfEntriesToBeVerified &gt; 0) {</span>
<span class="nc" id="L277">                    int lengthOfBucket = (int) (lengthOfLedgerFragment / numberOfEntriesToBeVerified);</span>
<span class="nc" id="L278">                    for (long index = firstStored;</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                         index &lt; (lastStored - lengthOfBucket - 1);</span>
<span class="nc" id="L280">                         index += lengthOfBucket) {</span>
<span class="nc" id="L281">                        long potentialEntryId = ThreadLocalRandom.current().nextInt((lengthOfBucket)) + index;</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                        if (fragment.isStoredEntryId(potentialEntryId, bookieIndex)) {</span>
<span class="nc" id="L283">                            entriesToBeVerified.add(potentialEntryId);</span>
                        }
                    }
                }
<span class="nc" id="L287">                entriesToBeVerified.add(firstStored);</span>
<span class="nc" id="L288">                entriesToBeVerified.add(lastStored);</span>
            } else {
                // Verify the entire fragment
<span class="nc bnc" id="L291" title="All 2 branches missed.">                while (firstStored &lt;= lastStored) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                    if (fragment.isStoredEntryId(firstStored, bookieIndex)) {</span>
<span class="nc" id="L293">                        entriesToBeVerified.add(firstStored);</span>
                    }
<span class="nc" id="L295">                    firstStored++;</span>
                }
            }
<span class="nc" id="L298">            ReadManyEntriesCallback manycb = new ReadManyEntriesCallback(entriesToBeVerified.size(),</span>
                    fragment, cb);
<span class="nc bnc" id="L300" title="All 2 branches missed.">            for (Long entryID: entriesToBeVerified) {</span>
<span class="nc" id="L301">                acquirePermit();</span>
<span class="nc" id="L302">                bookieClient.readEntry(bookie, fragment.getLedgerId(), entryID, manycb, bookie,</span>
                        BookieProtocol.FLAG_NONE);
<span class="nc" id="L304">            }</span>
        }
<span class="nc" id="L306">    }</span>

    /**
     * Callback for checking whether an entry exists or not.
     * It is used to differentiate the cases where it has been written
     * but now cannot be read, and where it never has been written.
     */
    private class EntryExistsCallback implements ReadEntryCallback {
<span class="nc" id="L314">        AtomicBoolean entryMayExist = new AtomicBoolean(false);</span>
        final AtomicInteger numReads;
        final GenericCallback&lt;Boolean&gt; cb;

        EntryExistsCallback(int numReads,
<span class="nc" id="L319">                            GenericCallback&lt;Boolean&gt; cb) {</span>
<span class="nc" id="L320">            this.numReads = new AtomicInteger(numReads);</span>
<span class="nc" id="L321">            this.cb = cb;</span>
<span class="nc" id="L322">        }</span>

        @Override
        public void readEntryComplete(int rc, long ledgerId, long entryId,
                                      ByteBuf buffer, Object ctx) {
<span class="nc" id="L327">            releasePermit();</span>
<span class="nc bnc" id="L328" title="All 6 branches missed.">            if (Code.NoSuchEntryException != rc &amp;&amp; Code.NoSuchLedgerExistsException != rc</span>
                    &amp;&amp; Code.NoSuchLedgerExistsOnMetadataServerException != rc) {
<span class="nc" id="L330">                entryMayExist.set(true);</span>
            }

<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (numReads.decrementAndGet() == 0) {</span>
<span class="nc" id="L334">                cb.operationComplete(rc, entryMayExist.get());</span>
            }
<span class="nc" id="L336">        }</span>
    }

    /**
     * This will collect all the fragment read call backs and finally it will
     * give call back to above call back API which is waiting for it once it
     * meets the expected call backs from down.
     */
    private static class FullLedgerCallback implements
            GenericCallback&lt;LedgerFragment&gt; {
        final Set&lt;LedgerFragment&gt; badFragments;
        final AtomicLong numFragments;
        final GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb;

        FullLedgerCallback(long numFragments,
<span class="nc" id="L351">                GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb) {</span>
<span class="nc" id="L352">            badFragments = new LinkedHashSet&lt;&gt;();</span>
<span class="nc" id="L353">            this.numFragments = new AtomicLong(numFragments);</span>
<span class="nc" id="L354">            this.cb = cb;</span>
<span class="nc" id="L355">        }</span>

        @Override
        public void operationComplete(int rc, LedgerFragment result) {
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (rc == Code.ClientClosedException) {</span>
<span class="nc" id="L360">                cb.operationComplete(Code.ClientClosedException, badFragments);</span>
<span class="nc" id="L361">                return;</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">            } else if (rc != Code.OK) {</span>
<span class="nc" id="L363">                badFragments.add(result);</span>
            }
<span class="nc bnc" id="L365" title="All 2 branches missed.">            if (numFragments.decrementAndGet() == 0) {</span>
<span class="nc" id="L366">                cb.operationComplete(Code.OK, badFragments);</span>
            }
<span class="nc" id="L368">        }</span>
    }

    /**
     * Check that all the fragments in the passed in ledger, and report those
     * which are missing.
     */
    public void checkLedger(final LedgerHandle lh,
                            final GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb) {
<span class="nc" id="L377">        checkLedger(lh, cb, 0L);</span>
<span class="nc" id="L378">    }</span>

    public void checkLedger(final LedgerHandle lh,
                            final GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb,
                            long percentageOfLedgerFragmentToBeVerified) {
        // build a set of all fragment replicas
<span class="nc" id="L384">        final Set&lt;LedgerFragment&gt; fragments = new LinkedHashSet&lt;&gt;();</span>

<span class="nc" id="L386">        Long curEntryId = null;</span>
<span class="nc" id="L387">        List&lt;BookieId&gt; curEnsemble = null;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        for (Map.Entry&lt;Long, ? extends List&lt;BookieId&gt;&gt; e : lh</span>
<span class="nc" id="L389">                .getLedgerMetadata().getAllEnsembles().entrySet()) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (curEntryId != null) {</span>
<span class="nc" id="L391">                Set&lt;Integer&gt; bookieIndexes = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                for (int i = 0; i &lt; curEnsemble.size(); i++) {</span>
<span class="nc" id="L393">                    bookieIndexes.add(i);</span>
                }
<span class="nc" id="L395">                fragments.add(new LedgerFragment(lh, curEntryId,</span>
<span class="nc" id="L396">                        e.getKey() - 1, bookieIndexes));</span>
            }
<span class="nc" id="L398">            curEntryId = e.getKey();</span>
<span class="nc" id="L399">            curEnsemble = e.getValue();</span>
<span class="nc" id="L400">        }</span>

        /* Checking the last segment of the ledger can be complicated in some cases.
         * In the case that the ledger is closed, we can just check the fragments of
         * the segment as normal even if no data has ever been written to.
         * In the case that the ledger is open, but enough entries have been written,
         * for lastAddConfirmed to be set above the start entry of the segment, we
         * can also check as normal.
         * However, if ledger is open, sometimes lastAddConfirmed cannot be trusted,
         * such as when it's lower than the first entry id, or not set at all,
         * we cannot be sure if there has been data written to the segment.
         * For this reason, we have to send a read request
         * to the bookies which should have the first entry. If they respond with
         * NoSuchEntry we can assume it was never written. If they respond with anything
         * else, we must assume the entry has been written, so we run the check.
         */
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (curEntryId != null) {</span>
<span class="nc" id="L417">            long lastEntry = lh.getLastAddConfirmed();</span>

<span class="nc bnc" id="L419" title="All 4 branches missed.">            if (!lh.isClosed() &amp;&amp; lastEntry &lt; curEntryId) {</span>
<span class="nc" id="L420">                lastEntry = curEntryId;</span>
            }

<span class="nc" id="L423">            Set&lt;Integer&gt; bookieIndexes = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">            for (int i = 0; i &lt; curEnsemble.size(); i++) {</span>
<span class="nc" id="L425">                bookieIndexes.add(i);</span>
            }
<span class="nc" id="L427">            final LedgerFragment lastLedgerFragment = new LedgerFragment(lh, curEntryId,</span>
                    lastEntry, bookieIndexes);

            // Check for the case that no last confirmed entry has been set
<span class="nc bnc" id="L431" title="All 2 branches missed.">            if (curEntryId == lastEntry) {</span>
<span class="nc" id="L432">                final long entryToRead = curEntryId;</span>

<span class="nc" id="L434">                final CompletableFuture&lt;Void&gt; future = new CompletableFuture&lt;&gt;();</span>
<span class="nc" id="L435">                future.whenCompleteAsync((re, ex) -&gt; {</span>
<span class="nc" id="L436">                    checkFragments(fragments, cb, percentageOfLedgerFragmentToBeVerified);</span>
<span class="nc" id="L437">                });</span>

<span class="nc" id="L439">                final EntryExistsCallback eecb = new EntryExistsCallback(lh.getLedgerMetadata().getWriteQuorumSize(),</span>
<span class="nc" id="L440">                                              new GenericCallback&lt;Boolean&gt;() {</span>
                                                  @Override
                                                  public void operationComplete(int rc, Boolean result) {
<span class="nc bnc" id="L443" title="All 2 branches missed.">                                                      if (result) {</span>
<span class="nc" id="L444">                                                          fragments.add(lastLedgerFragment);</span>
                                                      }
<span class="nc" id="L446">                                                      future.complete(null);</span>
<span class="nc" id="L447">                                                  }</span>
                                              });

<span class="nc" id="L450">                DistributionSchedule ds = lh.getDistributionSchedule();</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                for (int i = 0; i &lt; ds.getWriteQuorumSize(); i++) {</span>
                    try {
<span class="nc" id="L453">                        acquirePermit();</span>
<span class="nc" id="L454">                        BookieId addr = curEnsemble.get(ds.getWriteSetBookieIndex(entryToRead, i));</span>
<span class="nc" id="L455">                        bookieClient.readEntry(addr, lh.getId(), entryToRead,</span>
                                eecb, null, BookieProtocol.FLAG_NONE);
<span class="nc" id="L457">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L458">                        LOG.error(&quot;InterruptedException when checking entry : {}&quot;, entryToRead, e);</span>
<span class="nc" id="L459">                    }</span>
                }
<span class="nc" id="L461">                return;</span>
            } else {
<span class="nc" id="L463">                fragments.add(lastLedgerFragment);</span>
            }
        }
<span class="nc" id="L466">        checkFragments(fragments, cb, percentageOfLedgerFragmentToBeVerified);</span>
<span class="nc" id="L467">    }</span>

    private void checkFragments(Set&lt;LedgerFragment&gt; fragments,
                                GenericCallback&lt;Set&lt;LedgerFragment&gt;&gt; cb,
                                long percentageOfLedgerFragmentToBeVerified) {
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (fragments.size() == 0) { // no fragments to verify</span>
<span class="nc" id="L473">            cb.operationComplete(Code.OK, fragments);</span>
<span class="nc" id="L474">            return;</span>
        }

        // verify all the collected fragment replicas
<span class="nc" id="L478">        FullLedgerCallback allFragmentsCb = new FullLedgerCallback(fragments</span>
<span class="nc" id="L479">                .size(), cb);</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        for (LedgerFragment r : fragments) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L482">                LOG.debug(&quot;Checking fragment {}&quot;, r);</span>
            }
            try {
<span class="nc" id="L485">                verifyLedgerFragment(r, allFragmentsCb, percentageOfLedgerFragmentToBeVerified);</span>
<span class="nc" id="L486">            } catch (InvalidFragmentException ife) {</span>
<span class="nc" id="L487">                LOG.error(&quot;Invalid fragment found : {}&quot;, r);</span>
<span class="nc" id="L488">                allFragmentsCb.operationComplete(</span>
                        Code.IncorrectParameterException, r);
<span class="nc" id="L490">            } catch (BKException e) {</span>
<span class="nc" id="L491">                LOG.error(&quot;BKException when checking fragment : {}&quot;, r, e);</span>
<span class="nc" id="L492">            } catch (InterruptedException e) {</span>
<span class="nc" id="L493">                LOG.error(&quot;InterruptedException when checking fragment : {}&quot;, r, e);</span>
<span class="nc" id="L494">            }</span>
<span class="nc" id="L495">        }</span>
<span class="nc" id="L496">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>