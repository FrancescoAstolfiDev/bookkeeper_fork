<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LedgerFragmentReplicator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.client</a> &gt; <span class="el_source">LedgerFragmentReplicator.java</span></div><h1>LedgerFragmentReplicator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
package org.apache.bookkeeper.client;

import static org.apache.bookkeeper.client.LedgerHandle.INVALID_ENTRY_ID;
import static org.apache.bookkeeper.replication.ReplicationStats.NUM_BYTES_READ;
import static org.apache.bookkeeper.replication.ReplicationStats.NUM_BYTES_WRITTEN;
import static org.apache.bookkeeper.replication.ReplicationStats.NUM_ENTRIES_READ;
import static org.apache.bookkeeper.replication.ReplicationStats.NUM_ENTRIES_WRITTEN;
import static org.apache.bookkeeper.replication.ReplicationStats.READ_DATA_LATENCY;
import static org.apache.bookkeeper.replication.ReplicationStats.REPLICATION_WORKER_SCOPE;
import static org.apache.bookkeeper.replication.ReplicationStats.WRITE_DATA_LATENCY;

import com.google.common.util.concurrent.RateLimiter;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.util.ReferenceCounted;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.stream.Collectors;
import org.apache.bookkeeper.client.AsyncCallback.ReadCallback;
import org.apache.bookkeeper.client.api.WriteFlag;
import org.apache.bookkeeper.common.util.MathUtils;
import org.apache.bookkeeper.conf.ClientConfiguration;
import org.apache.bookkeeper.meta.LedgerManager;
import org.apache.bookkeeper.net.BookieId;
import org.apache.bookkeeper.proto.BookieProtocol;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.MultiCallback;
import org.apache.bookkeeper.proto.BookkeeperInternalCallbacks.WriteCallback;
import org.apache.bookkeeper.stats.Counter;
import org.apache.bookkeeper.stats.NullStatsLogger;
import org.apache.bookkeeper.stats.OpStatsLogger;
import org.apache.bookkeeper.stats.StatsLogger;
import org.apache.bookkeeper.stats.annotations.StatsDoc;
import org.apache.bookkeeper.util.ByteBufList;
import org.apache.zookeeper.AsyncCallback;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This is the helper class for replicating the fragments from one bookie to
 * another.
 */
@StatsDoc(
    name = REPLICATION_WORKER_SCOPE,
    help = &quot;Ledger fragment replicator related stats&quot;
)
public class LedgerFragmentReplicator {

    // BookKeeper instance
    private BookKeeper bkc;
    private StatsLogger statsLogger;
    @StatsDoc(
        name = NUM_ENTRIES_READ,
        help = &quot;Number of entries read by the replicator&quot;
    )
    private final Counter numEntriesRead;
    @StatsDoc(
        name = NUM_BYTES_READ,
        help = &quot;The distribution of size of entries read by the replicator&quot;
    )
    private final OpStatsLogger numBytesRead;
    @StatsDoc(
        name = NUM_ENTRIES_WRITTEN,
        help = &quot;Number of entries written by the replicator&quot;
    )
    private final Counter numEntriesWritten;
    @StatsDoc(
        name = NUM_BYTES_WRITTEN,
        help = &quot;The distribution of size of entries written by the replicator&quot;
    )
    private final OpStatsLogger numBytesWritten;
    @StatsDoc(
            name = READ_DATA_LATENCY,
            help = &quot;The distribution of latency of read entries by the replicator&quot;
    )
    private final OpStatsLogger readDataLatency;
    @StatsDoc(
            name = WRITE_DATA_LATENCY,
            help = &quot;The distribution of latency of write entries by the replicator&quot;
    )
    private final OpStatsLogger writeDataLatency;

<span class="nc" id="L110">    protected Throttler replicationThrottle = null;</span>

    private AtomicInteger averageEntrySize;

    private static final int INITIAL_AVERAGE_ENTRY_SIZE = 1024;
    private static final double AVERAGE_ENTRY_SIZE_RATIO = 0.8;
    private ClientConfiguration conf;

<span class="nc" id="L118">    public LedgerFragmentReplicator(BookKeeper bkc, StatsLogger statsLogger, ClientConfiguration conf) {</span>
<span class="nc" id="L119">        this.bkc = bkc;</span>
<span class="nc" id="L120">        this.statsLogger = statsLogger;</span>
<span class="nc" id="L121">        numEntriesRead = this.statsLogger.getCounter(NUM_ENTRIES_READ);</span>
<span class="nc" id="L122">        numBytesRead = this.statsLogger.getOpStatsLogger(NUM_BYTES_READ);</span>
<span class="nc" id="L123">        numEntriesWritten = this.statsLogger.getCounter(NUM_ENTRIES_WRITTEN);</span>
<span class="nc" id="L124">        numBytesWritten = this.statsLogger.getOpStatsLogger(NUM_BYTES_WRITTEN);</span>
<span class="nc" id="L125">        readDataLatency = this.statsLogger.getOpStatsLogger(READ_DATA_LATENCY);</span>
<span class="nc" id="L126">        writeDataLatency = this.statsLogger.getOpStatsLogger(WRITE_DATA_LATENCY);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (conf.getReplicationRateByBytes() &gt; 0) {</span>
<span class="nc" id="L128">            this.replicationThrottle = new Throttler(conf.getReplicationRateByBytes());</span>
        }
<span class="nc" id="L130">        averageEntrySize = new AtomicInteger(INITIAL_AVERAGE_ENTRY_SIZE);</span>
<span class="nc" id="L131">        this.conf = conf;</span>
<span class="nc" id="L132">    }</span>

    public LedgerFragmentReplicator(BookKeeper bkc, ClientConfiguration conf) {
<span class="nc" id="L135">        this(bkc, NullStatsLogger.INSTANCE, conf);</span>
<span class="nc" id="L136">    }</span>

<span class="nc" id="L138">    private static final Logger LOG = LoggerFactory</span>
<span class="nc" id="L139">            .getLogger(LedgerFragmentReplicator.class);</span>

    private void replicateFragmentInternal(final LedgerHandle lh,
            final LedgerFragment lf,
            final AsyncCallback.VoidCallback ledgerFragmentMcb,
            final Set&lt;BookieId&gt; newBookies,
            final BiConsumer&lt;Long, Long&gt; onReadEntryFailureCallback) throws InterruptedException {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (!lf.isClosed()) {</span>
<span class="nc" id="L147">            LOG.error(&quot;Trying to replicate an unclosed fragment;&quot;</span>
                      + &quot; This is not safe {}&quot;, lf);
<span class="nc" id="L149">            ledgerFragmentMcb.processResult(BKException.Code.UnclosedFragmentException,</span>
                                            null, null);
<span class="nc" id="L151">            return;</span>
        }
<span class="nc" id="L153">        Long startEntryId = lf.getFirstStoredEntryId();</span>
<span class="nc" id="L154">        Long endEntryId = lf.getLastStoredEntryId();</span>

        /*
         * if startEntryId is INVALID_ENTRY_ID then endEntryId should be
         * INVALID_ENTRY_ID and viceversa.
         */
<span class="nc bnc" id="L160" title="All 6 branches missed.">        if (startEntryId == INVALID_ENTRY_ID ^ endEntryId == INVALID_ENTRY_ID) {</span>
<span class="nc" id="L161">            LOG.error(&quot;For LedgerFragment: {}, seeing inconsistent firstStoredEntryId: {} and lastStoredEntryId: {}&quot;,</span>
                    lf, startEntryId, endEntryId);
<span class="nc" id="L163">            assert false;</span>
        }

<span class="nc bnc" id="L166" title="All 4 branches missed.">        if (startEntryId &gt; endEntryId || endEntryId &lt;= INVALID_ENTRY_ID) {</span>
            // for open ledger which there is no entry, the start entry id is 0,
            // the end entry id is -1.
            // we can return immediately to trigger forward read
<span class="nc" id="L170">            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);</span>
<span class="nc" id="L171">            return;</span>
        }

        /*
         * Now asynchronously replicate all of the entries for the ledger
         * fragment that were on the dead bookie.
         */
<span class="nc" id="L178">        int entriesToReplicateCnt = (int) (endEntryId - startEntryId + 1);</span>
<span class="nc" id="L179">        MultiCallback ledgerFragmentEntryMcb = new MultiCallback(</span>
                entriesToReplicateCnt, ledgerFragmentMcb, null, BKException.Code.OK,
                BKException.Code.LedgerRecoveryException);
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (this.replicationThrottle != null) {</span>
<span class="nc" id="L183">            this.replicationThrottle.resetRate(this.conf.getReplicationRateByBytes());</span>
        }

<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (conf.isRecoveryBatchReadEnabled()</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">                &amp;&amp; conf.getUseV2WireProtocol()</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                &amp;&amp; conf.isBatchReadEnabled()</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                &amp;&amp; lh.getLedgerMetadata().getEnsembleSize() == lh.getLedgerMetadata().getWriteQuorumSize()) {</span>
<span class="nc" id="L190">            batchRecoverLedgerFragmentEntry(startEntryId, endEntryId, lh, ledgerFragmentEntryMcb,</span>
                    newBookies, onReadEntryFailureCallback);

        } else {
            /*
             * Add all the entries to entriesToReplicate list from
             * firstStoredEntryId to lastStoredEntryID.
             */
<span class="nc" id="L198">            List&lt;Long&gt; entriesToReplicate = new LinkedList&lt;Long&gt;();</span>
<span class="nc" id="L199">            long lastStoredEntryId = lf.getLastStoredEntryId();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            for (long i = lf.getFirstStoredEntryId(); i &lt;= lastStoredEntryId; i++) {</span>
<span class="nc" id="L201">                entriesToReplicate.add(i);</span>
            }
<span class="nc bnc" id="L203" title="All 2 branches missed.">            for (final Long entryId : entriesToReplicate) {</span>
<span class="nc" id="L204">                recoverLedgerFragmentEntry(entryId, lh, ledgerFragmentEntryMcb,</span>
                        newBookies, onReadEntryFailureCallback);
<span class="nc" id="L206">            }</span>
        }

<span class="nc" id="L209">    }</span>

    /**
     * This method replicate a ledger fragment which is a contiguous portion of
     * a ledger that was stored in an ensemble that included the failed bookie.
     * It will Splits the fragment into multiple sub fragments by keeping the
     * max entries up to the configured value of rereplicationEntryBatchSize and
     * then it re-replicates that batched entry fragments one by one. After
     * re-replication of all batched entry fragments, it will update the
     * ensemble info with new Bookie once
     *
     * @param lh
     *            LedgerHandle for the ledger
     * @param lf
     *            LedgerFragment to replicate
     * @param ledgerFragmentMcb
     *            MultiCallback to invoke once we've recovered the current
     *            ledger fragment.
     * @param targetBookieAddresses
     *            New bookies we want to use to recover and replicate the ledger
     *            entries that were stored on the failed bookie.
     */
    void replicate(final LedgerHandle lh, final LedgerFragment lf,
            final AsyncCallback.VoidCallback ledgerFragmentMcb,
            final Set&lt;BookieId&gt; targetBookieAddresses,
            final BiConsumer&lt;Long, Long&gt; onReadEntryFailureCallback)
            throws InterruptedException {
<span class="nc" id="L236">        Set&lt;LedgerFragment&gt; partitionedFragments = splitIntoSubFragments(lh, lf,</span>
<span class="nc" id="L237">                bkc.getConf().getRereplicationEntryBatchSize());</span>
<span class="nc" id="L238">        LOG.info(&quot;Replicating fragment {} in {} sub fragments.&quot;,</span>
<span class="nc" id="L239">                lf, partitionedFragments.size());</span>
<span class="nc" id="L240">        replicateNextBatch(lh, partitionedFragments.iterator(),</span>
                ledgerFragmentMcb, targetBookieAddresses, onReadEntryFailureCallback);
<span class="nc" id="L242">    }</span>

    /**
     * Replicate the batched entry fragments one after other.
     */
    private void replicateNextBatch(final LedgerHandle lh,
            final Iterator&lt;LedgerFragment&gt; fragments,
            final AsyncCallback.VoidCallback ledgerFragmentMcb,
            final Set&lt;BookieId&gt; targetBookieAddresses,
            final BiConsumer&lt;Long, Long&gt; onReadEntryFailureCallback) {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (fragments.hasNext()) {</span>
            try {
<span class="nc" id="L254">                replicateFragmentInternal(lh, fragments.next(),</span>
<span class="nc" id="L255">                        new AsyncCallback.VoidCallback() {</span>
                            @Override
                            public void processResult(int rc, String v, Object ctx) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">                                if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L259">                                    ledgerFragmentMcb.processResult(rc, null,</span>
                                            null);
                                } else {
<span class="nc" id="L262">                                    replicateNextBatch(lh, fragments,</span>
                                            ledgerFragmentMcb,
                                            targetBookieAddresses,
                                            onReadEntryFailureCallback);
                                }
<span class="nc" id="L267">                            }</span>

                        }, targetBookieAddresses, onReadEntryFailureCallback);
<span class="nc" id="L270">            } catch (InterruptedException e) {</span>
<span class="nc" id="L271">                ledgerFragmentMcb.processResult(</span>
                        BKException.Code.InterruptedException, null, null);
<span class="nc" id="L273">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L274">            }</span>
        } else {
<span class="nc" id="L276">            ledgerFragmentMcb.processResult(BKException.Code.OK, null, null);</span>
        }
<span class="nc" id="L278">    }</span>

    /**
     * Split the full fragment into batched entry fragments by keeping
     * rereplicationEntryBatchSize of entries in each one and can treat them as
     * sub fragments.
     */
    static Set&lt;LedgerFragment&gt; splitIntoSubFragments(LedgerHandle lh,
            LedgerFragment ledgerFragment, long rereplicationEntryBatchSize) {
<span class="nc" id="L287">        Set&lt;LedgerFragment&gt; fragments = new HashSet&lt;LedgerFragment&gt;();</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (rereplicationEntryBatchSize &lt;= 0) {</span>
            // rereplicationEntryBatchSize can not be 0 or less than 0,
            // returning with the current fragment
<span class="nc" id="L291">            fragments.add(ledgerFragment);</span>
<span class="nc" id="L292">            return fragments;</span>
        }

<span class="nc" id="L295">        long firstEntryId = ledgerFragment.getFirstStoredEntryId();</span>
<span class="nc" id="L296">        long lastEntryId = ledgerFragment.getLastStoredEntryId();</span>

        /*
         * if firstEntryId is INVALID_ENTRY_ID then lastEntryId should be
         * INVALID_ENTRY_ID and viceversa.
         */
<span class="nc bnc" id="L302" title="All 6 branches missed.">        if (firstEntryId == INVALID_ENTRY_ID ^ lastEntryId == INVALID_ENTRY_ID) {</span>
<span class="nc" id="L303">            LOG.error(&quot;For LedgerFragment: {}, seeing inconsistent firstStoredEntryId: {} and lastStoredEntryId: {}&quot;,</span>
<span class="nc" id="L304">                    ledgerFragment, firstEntryId, lastEntryId);</span>
<span class="nc" id="L305">            assert false;</span>
        }

<span class="nc bnc" id="L308" title="All 2 branches missed.">        long numberOfEntriesToReplicate = firstEntryId == INVALID_ENTRY_ID ? 0 : (lastEntryId - firstEntryId) + 1;</span>
<span class="nc" id="L309">        long splitsWithFullEntries = numberOfEntriesToReplicate</span>
                / rereplicationEntryBatchSize;

<span class="nc bnc" id="L312" title="All 2 branches missed.">        if (splitsWithFullEntries == 0) {// only one fragment</span>
<span class="nc" id="L313">            fragments.add(ledgerFragment);</span>
<span class="nc" id="L314">            return fragments;</span>
        }

<span class="nc" id="L317">        long fragmentSplitLastEntry = 0;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        for (int i = 0; i &lt; splitsWithFullEntries; i++) {</span>
<span class="nc" id="L319">            fragmentSplitLastEntry = (firstEntryId + rereplicationEntryBatchSize) - 1;</span>
<span class="nc" id="L320">            fragments.add(new LedgerFragment(lh, firstEntryId,</span>
<span class="nc" id="L321">                    fragmentSplitLastEntry, ledgerFragment.getBookiesIndexes()));</span>
<span class="nc" id="L322">            firstEntryId = fragmentSplitLastEntry + 1;</span>
        }

<span class="nc" id="L325">        long lastSplitWithPartialEntries = numberOfEntriesToReplicate</span>
                % rereplicationEntryBatchSize;
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (lastSplitWithPartialEntries &gt; 0) {</span>
<span class="nc" id="L328">            fragments.add(new LedgerFragment(lh, firstEntryId, firstEntryId</span>
                    + lastSplitWithPartialEntries - 1, ledgerFragment
<span class="nc" id="L330">                    .getBookiesIndexes()));</span>
        }
<span class="nc" id="L332">        return fragments;</span>
    }

    /**
     * This method asynchronously recovers a specific ledger entry by reading
     * the values via the BookKeeper Client (which would read it from the other
     * replicas) and then writing it to the chosen new bookie.
     *
     * @param entryId
     *            Ledger Entry ID to recover.
     * @param lh
     *            LedgerHandle for the ledger
     * @param ledgerFragmentEntryMcb
     *            MultiCallback to invoke once we've recovered the current
     *            ledger entry.
     * @param newBookies
     *            New bookies we want to use to recover and replicate the ledger
     *            entries that were stored on the failed bookie.
     */
    void recoverLedgerFragmentEntry(final Long entryId,
            final LedgerHandle lh,
            final AsyncCallback.VoidCallback ledgerFragmentEntryMcb,
            final Set&lt;BookieId&gt; newBookies,
            final BiConsumer&lt;Long, Long&gt; onReadEntryFailureCallback) throws InterruptedException {
<span class="nc" id="L356">        final long ledgerId = lh.getId();</span>
<span class="nc" id="L357">        final AtomicInteger numCompleted = new AtomicInteger(0);</span>
<span class="nc" id="L358">        final AtomicBoolean completed = new AtomicBoolean(false);</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (replicationThrottle != null) {</span>
<span class="nc" id="L361">            replicationThrottle.acquire(averageEntrySize.get());</span>
        }

<span class="nc" id="L364">        final WriteCallback multiWriteCallback = new WriteCallback() {</span>
            @Override
            public void writeComplete(int rc, long ledgerId, long entryId, BookieId addr, Object ctx) {
<span class="nc bnc" id="L367" title="All 2 branches missed.">                if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L368">                    LOG.error(&quot;BK error writing entry for ledgerId: {}, entryId: {}, bookie: {}&quot;,</span>
<span class="nc" id="L369">                            ledgerId, entryId, addr, BKException.create(rc));</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                    if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L371">                        ledgerFragmentEntryMcb.processResult(rc, null, null);</span>
                    }
                } else {
<span class="nc" id="L374">                    numEntriesWritten.inc();</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                    if (ctx instanceof Long) {</span>
<span class="nc" id="L376">                        numBytesWritten.registerSuccessfulValue((Long) ctx);</span>
                    }
<span class="nc bnc" id="L378" title="All 2 branches missed.">                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L379">                        LOG.debug(&quot;Success writing ledger id {}, entry id {} to a new bookie {}!&quot;,</span>
<span class="nc" id="L380">                                ledgerId, entryId, addr);</span>
                    }
<span class="nc bnc" id="L382" title="All 4 branches missed.">                    if (numCompleted.incrementAndGet() == newBookies.size() &amp;&amp; completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L383">                        ledgerFragmentEntryMcb.processResult(rc, null, null);</span>
                    }
                }
<span class="nc" id="L386">            }</span>
        };

<span class="nc" id="L389">        long startReadEntryTime = MathUtils.nowInNano();</span>
        /*
         * Read the ledger entry using the LedgerHandle. This will allow us to
         * read the entry from one of the other replicated bookies other than
         * the dead one.
         */
<span class="nc" id="L395">        lh.asyncReadEntries(entryId, entryId, new ReadCallback() {</span>
            @Override
            public void readComplete(int rc, LedgerHandle lh,
                    Enumeration&lt;LedgerEntry&gt; seq, Object ctx) {
<span class="nc bnc" id="L399" title="All 2 branches missed.">                if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L400">                    LOG.error(&quot;BK error reading ledger entry: &quot; + entryId,</span>
<span class="nc" id="L401">                            BKException.create(rc));</span>
<span class="nc" id="L402">                    onReadEntryFailureCallback.accept(ledgerId, entryId);</span>
<span class="nc" id="L403">                    ledgerFragmentEntryMcb.processResult(rc, null, null);</span>
<span class="nc" id="L404">                    return;</span>
                }

<span class="nc" id="L407">                readDataLatency.registerSuccessfulEvent(MathUtils.elapsedNanos(startReadEntryTime),</span>
                        TimeUnit.NANOSECONDS);

                /*
                 * Now that we've read the ledger entry, write it to the new
                 * bookie we've selected.
                 */
<span class="nc" id="L414">                LedgerEntry entry = seq.nextElement();</span>
<span class="nc" id="L415">                byte[] data = entry.getEntry();</span>
<span class="nc" id="L416">                final long dataLength = data.length;</span>
<span class="nc" id="L417">                numEntriesRead.inc();</span>
<span class="nc" id="L418">                numBytesRead.registerSuccessfulValue(dataLength);</span>

<span class="nc" id="L420">                ReferenceCounted toSend = lh.getDigestManager()</span>
<span class="nc" id="L421">                        .computeDigestAndPackageForSending(entryId,</span>
<span class="nc" id="L422">                                lh.getLastAddConfirmed(), entry.getLength(),</span>
<span class="nc" id="L423">                                Unpooled.wrappedBuffer(data, 0, data.length),</span>
<span class="nc" id="L424">                                lh.getLedgerKey(),</span>
                                BookieProtocol.FLAG_RECOVERY_ADD
                                );
<span class="nc bnc" id="L427" title="All 2 branches missed.">                if (replicationThrottle != null) {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                    if (toSend instanceof ByteBuf) {</span>
<span class="nc" id="L429">                        updateAverageEntrySize(((ByteBuf) toSend).readableBytes());</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">                    } else if (toSend instanceof ByteBufList) {</span>
<span class="nc" id="L431">                        updateAverageEntrySize(((ByteBufList) toSend).readableBytes());</span>
                    }
                }
<span class="nc bnc" id="L434" title="All 2 branches missed.">                for (BookieId newBookie : newBookies) {</span>
<span class="nc" id="L435">                    long startWriteEntryTime = MathUtils.nowInNano();</span>
<span class="nc" id="L436">                    bkc.getBookieClient().addEntry(newBookie, lh.getId(),</span>
<span class="nc" id="L437">                            lh.getLedgerKey(), entryId, toSend,</span>
<span class="nc" id="L438">                            multiWriteCallback, dataLength, BookieProtocol.FLAG_RECOVERY_ADD,</span>
                            false, WriteFlag.NONE);
<span class="nc" id="L440">                    writeDataLatency.registerSuccessfulEvent(</span>
<span class="nc" id="L441">                           MathUtils.elapsedNanos(startWriteEntryTime), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L442">                }</span>
<span class="nc" id="L443">                toSend.release();</span>
<span class="nc" id="L444">            }</span>
        }, null);
<span class="nc" id="L446">    }</span>

    void batchRecoverLedgerFragmentEntry(final long startEntryId,
                                         final long endEntryId,
                                         final LedgerHandle lh,
                                         final AsyncCallback.VoidCallback ledgerFragmentMcb,
                                         final Set&lt;BookieId&gt; newBookies,
                                         final BiConsumer&lt;Long, Long&gt; onReadEntryFailureCallback)
            throws InterruptedException {
<span class="nc" id="L455">        int entriesToReplicateCnt = (int) (endEntryId - startEntryId + 1);</span>
<span class="nc" id="L456">        int maxBytesToReplicate = conf.getReplicationRateByBytes();</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (replicationThrottle != null) {</span>
<span class="nc bnc" id="L458" title="All 4 branches missed.">            if (maxBytesToReplicate != -1 &amp;&amp; maxBytesToReplicate &gt; averageEntrySize.get() * entriesToReplicateCnt) {</span>
<span class="nc" id="L459">                maxBytesToReplicate = averageEntrySize.get() * entriesToReplicateCnt;</span>
            }
<span class="nc" id="L461">            replicationThrottle.acquire(maxBytesToReplicate);</span>
        }

<span class="nc" id="L464">        lh.asyncBatchReadEntries(startEntryId, entriesToReplicateCnt, maxBytesToReplicate,</span>
<span class="nc" id="L465">            new ReadCallback() {</span>
                @Override
                public void readComplete(int rc, LedgerHandle lh, Enumeration&lt;LedgerEntry&gt; seq, Object ctx) {
<span class="nc bnc" id="L468" title="All 2 branches missed.">                    if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L469">                        LOG.error(&quot;BK error reading ledger entries: {} - {}&quot;,</span>
<span class="nc" id="L470">                                startEntryId, endEntryId, BKException.create(rc));</span>
<span class="nc" id="L471">                        onReadEntryFailureCallback.accept(lh.getId(), startEntryId);</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                        for (int i = 0; i &lt; entriesToReplicateCnt; i++) {</span>
<span class="nc" id="L473">                            ledgerFragmentMcb.processResult(rc, null, null);</span>
                        }
<span class="nc" id="L475">                        return;</span>
                    }
<span class="nc" id="L477">                    long lastEntryId = startEntryId;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">                    while (seq.hasMoreElements()) {</span>
<span class="nc" id="L479">                        LedgerEntry entry = seq.nextElement();</span>
<span class="nc" id="L480">                        lastEntryId = entry.getEntryId();</span>
<span class="nc" id="L481">                        byte[] data = entry.getEntry();</span>
<span class="nc" id="L482">                        final long dataLength = data.length;</span>
<span class="nc" id="L483">                        numEntriesRead.inc();</span>
<span class="nc" id="L484">                        numBytesRead.registerSuccessfulValue(dataLength);</span>

<span class="nc" id="L486">                        ReferenceCounted toSend = lh.getDigestManager()</span>
<span class="nc" id="L487">                                .computeDigestAndPackageForSending(entry.getEntryId(),</span>
<span class="nc" id="L488">                                        lh.getLastAddConfirmed(), entry.getLength(),</span>
<span class="nc" id="L489">                                        Unpooled.wrappedBuffer(data, 0, data.length),</span>
<span class="nc" id="L490">                                        lh.getLedgerKey(),</span>
                                        BookieProtocol.FLAG_RECOVERY_ADD);
<span class="nc bnc" id="L492" title="All 2 branches missed.">                        if (replicationThrottle != null) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                            if (toSend instanceof ByteBuf) {</span>
<span class="nc" id="L494">                                updateAverageEntrySize(((ByteBuf) toSend).readableBytes());</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">                            } else if (toSend instanceof ByteBufList) {</span>
<span class="nc" id="L496">                                updateAverageEntrySize(((ByteBufList) toSend).readableBytes());</span>
                            }
                        }
<span class="nc" id="L499">                        AtomicInteger numCompleted = new AtomicInteger(0);</span>
<span class="nc" id="L500">                        AtomicBoolean completed = new AtomicBoolean(false);</span>

<span class="nc" id="L502">                        WriteCallback multiWriteCallback = new WriteCallback() {</span>
                            @Override
                            public void writeComplete(int rc, long ledgerId, long entryId, BookieId addr, Object ctx) {
<span class="nc bnc" id="L505" title="All 2 branches missed.">                                if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L506">                                    LOG.error(&quot;BK error writing entry for ledgerId: {}, entryId: {}, bookie: {}&quot;,</span>
<span class="nc" id="L507">                                            ledgerId, entryId, addr, BKException.create(rc));</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                                    if (completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L509">                                        ledgerFragmentMcb.processResult(rc, null, null);</span>
                                    }
                                } else {
<span class="nc" id="L512">                                    numEntriesWritten.inc();</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                                    if (ctx instanceof Long) {</span>
<span class="nc" id="L514">                                        numBytesWritten.registerSuccessfulValue((Long) ctx);</span>
                                    }
<span class="nc bnc" id="L516" title="All 2 branches missed.">                                    if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L517">                                        LOG.debug(&quot;Success writing ledger id {}, entry id {} to a new bookie {}!&quot;,</span>
<span class="nc" id="L518">                                                ledgerId, entryId, addr);</span>
                                    }
<span class="nc bnc" id="L520" title="All 2 branches missed.">                                    if (numCompleted.incrementAndGet() == newBookies.size()</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                                            &amp;&amp; completed.compareAndSet(false, true)) {</span>
<span class="nc" id="L522">                                        ledgerFragmentMcb.processResult(rc, null, null);</span>
                                    }
                                }
<span class="nc" id="L525">                            }</span>
                        };

<span class="nc bnc" id="L528" title="All 2 branches missed.">                        for (BookieId newBookie : newBookies) {</span>
<span class="nc" id="L529">                            long startWriteEntryTime = MathUtils.nowInNano();</span>
<span class="nc" id="L530">                            bkc.getBookieClient().addEntry(newBookie, lh.getId(),</span>
<span class="nc" id="L531">                                    lh.getLedgerKey(), entry.getEntryId(), toSend,</span>
<span class="nc" id="L532">                                    multiWriteCallback, dataLength, BookieProtocol.FLAG_RECOVERY_ADD,</span>
                                    false, WriteFlag.NONE);
<span class="nc" id="L534">                            writeDataLatency.registerSuccessfulEvent(</span>
<span class="nc" id="L535">                                    MathUtils.elapsedNanos(startWriteEntryTime), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L536">                        }</span>
<span class="nc" id="L537">                        toSend.release();</span>
<span class="nc" id="L538">                    }</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                    if (lastEntryId != endEntryId) {</span>
                        try {
<span class="nc" id="L541">                            batchRecoverLedgerFragmentEntry(lastEntryId + 1, endEntryId, lh,</span>
                                    ledgerFragmentMcb, newBookies, onReadEntryFailureCallback);
<span class="nc" id="L543">                        } catch (InterruptedException e) {</span>
<span class="nc" id="L544">                            int remainingEntries = (int) (endEntryId - lastEntryId);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">                            for (int i = 0; i &lt; remainingEntries; i++) {</span>
<span class="nc" id="L546">                                ledgerFragmentMcb.processResult(BKException.Code.InterruptedException, null, null);</span>
                            }
<span class="nc" id="L548">                        }</span>
                    }
<span class="nc" id="L550">                }</span>
            }, null);
<span class="nc" id="L552">    }</span>

    private void updateAverageEntrySize(int toSendSize) {
<span class="nc" id="L555">        averageEntrySize.updateAndGet(value -&gt; (int) (value * AVERAGE_ENTRY_SIZE_RATIO</span>
                + (1 - AVERAGE_ENTRY_SIZE_RATIO) * toSendSize));
<span class="nc" id="L557">    }</span>

    /**
     * Callback for recovery of a single ledger fragment. Once the fragment has
     * had all entries replicated, update the ensemble in zookeeper. Once
     * finished propagate callback up to ledgerFragmentsMcb which should be a
     * multicallback responsible for all fragments in a single ledger
     */
    static class SingleFragmentCallback implements AsyncCallback.VoidCallback {
        final VoidCallback ledgerFragmentsMcb;
        final LedgerHandle lh;
        final LedgerManager ledgerManager;
        final long fragmentStartId;
        final Map&lt;BookieId, BookieId&gt; oldBookie2NewBookie;

        SingleFragmentCallback(VoidCallback ledgerFragmentsMcb,
                               LedgerHandle lh, LedgerManager ledgerManager, long fragmentStartId,
<span class="nc" id="L574">                               Map&lt;BookieId, BookieId&gt; oldBookie2NewBookie) {</span>
<span class="nc" id="L575">            this.ledgerFragmentsMcb = ledgerFragmentsMcb;</span>
<span class="nc" id="L576">            this.lh = lh;</span>
<span class="nc" id="L577">            this.ledgerManager = ledgerManager;</span>
<span class="nc" id="L578">            this.fragmentStartId = fragmentStartId;</span>
<span class="nc" id="L579">            this.oldBookie2NewBookie = oldBookie2NewBookie;</span>
<span class="nc" id="L580">        }</span>

        @Override
        public void processResult(int rc, String path, Object ctx) {
<span class="nc bnc" id="L584" title="All 2 branches missed.">            if (rc != BKException.Code.OK) {</span>
<span class="nc" id="L585">                LOG.error(&quot;BK error replicating ledger fragments for ledger: &quot;</span>
<span class="nc" id="L586">                        + lh.getId(), BKException.create(rc));</span>
<span class="nc" id="L587">                ledgerFragmentsMcb.processResult(rc, null, null);</span>
<span class="nc" id="L588">                return;</span>
            }
<span class="nc" id="L590">            updateEnsembleInfo(ledgerManager, ledgerFragmentsMcb, fragmentStartId, lh, oldBookie2NewBookie);</span>
<span class="nc" id="L591">        }</span>
    }

    /**
     * Updates the ensemble with newBookie and notify the ensembleUpdatedCb.
     */
    private static void updateEnsembleInfo(
            LedgerManager ledgerManager, AsyncCallback.VoidCallback ensembleUpdatedCb, long fragmentStartId,
            LedgerHandle lh, Map&lt;BookieId, BookieId&gt; oldBookie2NewBookie) {

<span class="nc" id="L601">        MetadataUpdateLoop updateLoop = new MetadataUpdateLoop(</span>
                ledgerManager,
<span class="nc" id="L603">                lh.getId(),</span>
<span class="nc" id="L604">                lh::getVersionedLedgerMetadata,</span>
                (metadata) -&gt; {
                    // returns true if any of old bookies exist in ensemble
<span class="nc" id="L607">                    List&lt;BookieId&gt; ensemble = metadata.getAllEnsembles().get(fragmentStartId);</span>
<span class="nc" id="L608">                    return oldBookie2NewBookie.keySet().stream().anyMatch(ensemble::contains);</span>
                },
                (currentMetadata) -&gt; {
                    // replace all old bookies with new bookies in ensemble
<span class="nc" id="L612">                    List&lt;BookieId&gt; newEnsemble = currentMetadata.getAllEnsembles().get(fragmentStartId)</span>
<span class="nc" id="L613">                        .stream().map((bookie) -&gt; oldBookie2NewBookie.getOrDefault(bookie, bookie))</span>
<span class="nc" id="L614">                        .collect(Collectors.toList());</span>
<span class="nc" id="L615">                    return LedgerMetadataBuilder.from(currentMetadata)</span>
<span class="nc" id="L616">                        .replaceEnsembleEntry(fragmentStartId, newEnsemble).build();</span>
                },
<span class="nc" id="L618">                lh::setLedgerMetadata);</span>

<span class="nc" id="L620">        updateLoop.run().whenComplete((result, ex) -&gt; {</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                if (ex == null) {</span>
<span class="nc" id="L622">                    LOG.info(&quot;Updated ZK to point ledger fragments&quot;</span>
                             + &quot; from old bookies to new bookies: {}&quot;, oldBookie2NewBookie);

<span class="nc" id="L625">                    ensembleUpdatedCb.processResult(BKException.Code.OK, null, null);</span>
                } else {
<span class="nc" id="L627">                    LOG.error(&quot;Error updating ledger config metadata for ledgerId {}&quot;, lh.getId(), ex);</span>

<span class="nc" id="L629">                    ensembleUpdatedCb.processResult(</span>
<span class="nc" id="L630">                            BKException.getExceptionCode(ex, BKException.Code.UnexpectedConditionException),</span>
                            null, null);
                }
<span class="nc" id="L633">            });</span>
<span class="nc" id="L634">    }</span>

    static class Throttler {
        private final RateLimiter rateLimiter;

<span class="nc" id="L639">        Throttler(int throttleBytes) {</span>
<span class="nc" id="L640">            this.rateLimiter = RateLimiter.create(throttleBytes);</span>
<span class="nc" id="L641">        }</span>

        // reset rate of limiter before compact one entry log file
        void resetRate(int throttleBytes) {
<span class="nc" id="L645">            this.rateLimiter.setRate(throttleBytes);</span>
<span class="nc" id="L646">        }</span>

        // get rate of limiter for unit test
        double getRate() {
<span class="nc" id="L650">            return this.rateLimiter.getRate();</span>
        }

        // acquire. if bybytes: bytes of this entry; if byentries: 1.
        void acquire(int permits) {
<span class="nc" id="L655">            rateLimiter.acquire(permits);</span>
<span class="nc" id="L656">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>