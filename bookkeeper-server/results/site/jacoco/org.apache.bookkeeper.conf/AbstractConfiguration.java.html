<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache BookKeeper :: Server</a> &gt; <a href="index.source.html" class="el_package">org.apache.bookkeeper.conf</a> &gt; <span class="el_source">AbstractConfiguration.java</span></div><h1>AbstractConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.bookkeeper.conf;

import static org.apache.bookkeeper.conf.ClientConfiguration.CLIENT_AUTH_PROVIDER_FACTORY_CLASS;

import io.netty.buffer.PooledByteBufAllocator;
import java.net.URL;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import javax.net.ssl.SSLEngine;
import lombok.extern.slf4j.Slf4j;
import org.apache.bookkeeper.common.allocator.LeakDetectionPolicy;
import org.apache.bookkeeper.common.allocator.OutOfMemoryPolicy;
import org.apache.bookkeeper.common.allocator.PoolingPolicy;
import org.apache.bookkeeper.common.conf.ConfigurationUtil;
import org.apache.bookkeeper.common.util.JsonUtil;
import org.apache.bookkeeper.common.util.JsonUtil.ParseJsonException;
import org.apache.bookkeeper.common.util.ReflectionUtils;
import org.apache.bookkeeper.feature.Feature;
import org.apache.bookkeeper.meta.AbstractZkLedgerManagerFactory;
import org.apache.bookkeeper.meta.HierarchicalLedgerManagerFactory;
import org.apache.bookkeeper.meta.LedgerManagerFactory;
import org.apache.bookkeeper.meta.LongHierarchicalLedgerManagerFactory;
import org.apache.bookkeeper.util.EntryFormatter;
import org.apache.bookkeeper.util.LedgerIdFormatter;
import org.apache.bookkeeper.util.StringEntryFormatter;
import org.apache.commons.configuration2.CompositeConfiguration;
import org.apache.commons.configuration2.PropertiesConfiguration;
import org.apache.commons.configuration2.convert.DefaultListDelimiterHandler;
import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.lang3.StringUtils;

/**
 * Abstract configuration.
 */
<span class="nc" id="L54">@Slf4j</span>
public abstract class AbstractConfiguration&lt;T extends AbstractConfiguration&gt;
    extends CompositeConfiguration {

    public static final String READ_SYSTEM_PROPERTIES_PROPERTY = &quot;org.apache.bookkeeper.conf.readsystemproperties&quot;;

    /**
     * Enable the use of System Properties, which was the default behaviour till 4.4.0.
     */
<span class="nc" id="L63">    private static final boolean READ_SYSTEM_PROPERTIES = Boolean.getBoolean(READ_SYSTEM_PROPERTIES_PROPERTY);</span>

    protected static final ClassLoader DEFAULT_LOADER;
    static {
<span class="nc" id="L67">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        if (null == loader) {</span>
<span class="nc" id="L69">            loader = AbstractConfiguration.class.getClassLoader();</span>
        }
<span class="nc" id="L71">        DEFAULT_LOADER = loader;</span>
    }

    // Zookeeper Parameters
    protected static final String ZK_TIMEOUT = &quot;zkTimeout&quot;;
    protected static final String ZK_SERVERS = &quot;zkServers&quot;;
    protected static final String ZK_RETRY_BACKOFF_MAX_RETRIES = &quot;zkRetryBackoffMaxRetries&quot;;

    // Ledger Manager
    protected static final String LEDGER_MANAGER_TYPE = &quot;ledgerManagerType&quot;;
    protected static final String LEDGER_MANAGER_FACTORY_CLASS = &quot;ledgerManagerFactoryClass&quot;;
    protected static final String LEDGER_METADATA_FORMAT_VERSION = &quot;ledgerMetadataVersion&quot;;
    protected static final String ALLOW_SHADED_LEDGER_MANAGER_FACTORY_CLASS = &quot;allowShadedLedgerManagerFactoryClass&quot;;
    protected static final String SHADED_LEDGER_MANAGER_FACTORY_CLASS_PREFIX = &quot;shadedLedgerManagerFactoryClassPrefix&quot;;
    protected static final String METADATA_SERVICE_URI = &quot;metadataServiceUri&quot;;
    protected static final String ZK_LEDGERS_ROOT_PATH = &quot;zkLedgersRootPath&quot;;
    protected static final String ZK_REQUEST_RATE_LIMIT = &quot;zkRequestRateLimit&quot;;
    protected static final String ZK_REPLICATION_TASK_RATE_LIMIT = &quot;zkReplicationTaskRateLimit&quot;;
    protected static final String AVAILABLE_NODE = &quot;available&quot;;
    protected static final String REREPLICATION_ENTRY_BATCH_SIZE = &quot;rereplicationEntryBatchSize&quot;;
    protected static final String STORE_SYSTEMTIME_AS_LEDGER_UNDERREPLICATED_MARK_TIME =
            &quot;storeSystemTimeAsLedgerUnderreplicatedMarkTime&quot;;
    protected static final String STORE_SYSTEMTIME_AS_LEDGER_CREATION_TIME = &quot;storeSystemTimeAsLedgerCreationTime&quot;;

    protected static final String ENABLE_BUSY_WAIT = &quot;enableBusyWait&quot;;
    protected static final String ENABLE_HEALTH_CHECK = &quot;enableHealthCheck&quot;;

    // Metastore settings, only being used when LEDGER_MANAGER_FACTORY_CLASS is MSLedgerManagerFactory
    protected static final String METASTORE_IMPL_CLASS = &quot;metastoreImplClass&quot;;
    protected static final String METASTORE_MAX_ENTRIES_PER_SCAN = &quot;metastoreMaxEntriesPerScan&quot;;

    // Common TLS configuration
    // TLS Provider (JDK or OpenSSL)
    protected static final String TLS_PROVIDER = &quot;tlsProvider&quot;;

    // TLS provider factory class name
    protected static final String TLS_PROVIDER_FACTORY_CLASS = &quot;tlsProviderFactoryClass&quot;;

    protected static final String LEDGERID_FORMATTER_CLASS = &quot;ledgerIdFormatterClass&quot;;
    protected static final String ENTRY_FORMATTER_CLASS = &quot;entryFormatterClass&quot;;

    // Enable authentication of the other connection end point (mutual authentication)
    protected static final String TLS_CLIENT_AUTHENTICATION = &quot;tlsClientAuthentication&quot;;

    // Preserve MDC or not for tasks in executor
    protected static final String PRESERVE_MDC_FOR_TASK_EXECUTION = &quot;preserveMdcForTaskExecution&quot;;

    // Default formatter classes
<span class="nc" id="L119">    protected static final Class&lt;? extends EntryFormatter&gt; DEFAULT_ENTRY_FORMATTER = StringEntryFormatter.class;</span>
<span class="nc" id="L120">    protected static final Class&lt;? extends LedgerIdFormatter&gt; DEFAULT_LEDGERID_FORMATTER =</span>
            LedgerIdFormatter.LongLedgerIdFormatter.class;

    protected static final String TLS_CERT_FILES_REFRESH_DURATION_SECONDS = &quot;tlsCertFilesRefreshDurationSeconds&quot;;
    /**
     * This list will be passed to {@link SSLEngine#setEnabledCipherSuites(String[]) }.
     * Please refer to official JDK JavaDocs
    */
    protected static final String TLS_ENABLED_CIPHER_SUITES = &quot;tlsEnabledCipherSuites&quot;;

    /**
     * This list will be passed to {@link SSLEngine#setEnabledProtocols(String[]) }.
     * Please refer to official JDK JavaDocs
    */
    protected static final String TLS_ENABLED_PROTOCOLS = &quot;tlsEnabledProtocols&quot;;

    /**
     * TLS KeyStore, TrustStore, Password files and Certificate Paths.
     */
    protected static final String TLS_KEYSTORE_TYPE = &quot;tlsKeyStoreType&quot;;
    protected static final String TLS_KEYSTORE = &quot;tlsKeyStore&quot;;
    protected static final String TLS_KEYSTORE_PASSWORD_PATH = &quot;tlsKeyStorePasswordPath&quot;;
    protected static final String TLS_TRUSTSTORE_TYPE = &quot;tlsTrustStoreType&quot;;
    protected static final String TLS_TRUSTSTORE = &quot;tlsTrustStore&quot;;
    protected static final String TLS_TRUSTSTORE_PASSWORD_PATH = &quot;tlsTrustStorePasswordPath&quot;;
    protected static final String TLS_CERTIFICATE_PATH = &quot;tlsCertificatePath&quot;;

    //Netty configuration
    protected static final String NETTY_MAX_FRAME_SIZE = &quot;nettyMaxFrameSizeBytes&quot;;
    protected static final int DEFAULT_NETTY_MAX_FRAME_SIZE = 5 * 1024 * 1024; // 5MB

    // Zookeeper ACL settings
    protected static final String ZK_ENABLE_SECURITY = &quot;zkEnableSecurity&quot;;

    // Kluge for compatibility testing. Never set this outside tests.
    public static final String LEDGER_MANAGER_FACTORY_DISABLE_CLASS_CHECK = &quot;ledgerManagerFactoryDisableClassCheck&quot;;

    // Validate bookie process user
    public static final String PERMITTED_STARTUP_USERS = &quot;permittedStartupUsers&quot;;

    // minimum number of racks per write quorum
    public static final String MIN_NUM_RACKS_PER_WRITE_QUORUM = &quot;minNumRacksPerWriteQuorum&quot;;

    // enforce minimum number of racks per write quorum
    public static final String ENFORCE_MIN_NUM_RACKS_PER_WRITE_QUORUM = &quot;enforceMinNumRacksPerWriteQuorum&quot;;

    // enforce minimum number of fault domains for write
    public static final String ENFORCE_MIN_NUM_FAULT_DOMAINS_FOR_WRITE = &quot;enforceMinNumFaultDomainsForWrite&quot;;

    // ignore usage of local node in the internal logic of placement policy
    public static final String IGNORE_LOCAL_NODE_IN_PLACEMENT_POLICY = &quot;ignoreLocalNodeInPlacementPolicy&quot;;

    // minimum number of zones per write quorum in ZoneAwarePlacementPolicy
    public static final String MIN_NUM_ZONES_PER_WRITE_QUORUM = &quot;minNumZonesPerWriteQuorum&quot;;

    // desired number of zones per write quorum in ZoneAwarePlacementPolicy
    public static final String DESIRED_NUM_ZONES_PER_WRITE_QUORUM = &quot;desiredNumZonesPerWriteQuorum&quot;;

    // in ZoneawareEnsemblePlacementPolicy if strict placement is enabled then
    // minZones/desiredZones in writeQuorum would be maintained otherwise it
    // will pick nodes randomly.
    public static final String ENFORCE_STRICT_ZONEAWARE_PLACEMENT = &quot;enforceStrictZoneawarePlacement&quot;;

    // Allocator configuration
    protected static final String ALLOCATOR_POOLING_POLICY = &quot;allocatorPoolingPolicy&quot;;
    protected static final String ALLOCATOR_POOLING_CONCURRENCY = &quot;allocatorPoolingConcurrency&quot;;
    protected static final String ALLOCATOR_OOM_POLICY = &quot;allocatorOutOfMemoryPolicy&quot;;
    protected static final String ALLOCATOR_LEAK_DETECTION_POLICY = &quot;allocatorLeakDetectionPolicy&quot;;
    protected static final String ALLOCATOR_EXIT_ON_OUT_OF_MEMORY = &quot;allocatorExitOnOutOfMemory&quot;;

    // option to limit stats logging
    public static final String LIMIT_STATS_LOGGING = &quot;limitStatsLogging&quot;;

    protected static final String REPLICATION_RATE_BY_BYTES = &quot;replicationRateByBytes&quot;;

    protected AbstractConfiguration() {
<span class="nc" id="L196">        super();</span>
        // configure list handling to behave in the same way as in commons-configuration 1.x
<span class="nc" id="L198">        setListDelimiterHandler(new DefaultListDelimiterHandler(','));</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (READ_SYSTEM_PROPERTIES) {</span>
            // add configuration for system properties
<span class="nc" id="L201">            addConfiguration(ConfigurationUtil.readSystemPropertiesAsConfiguration());</span>
        }
<span class="nc" id="L203">    }</span>

    /**
     * Limit who can start the application to prevent future permission errors.
     */
    public void setPermittedStartupUsers(String s) {
<span class="nc" id="L209">        setProperty(PERMITTED_STARTUP_USERS, s);</span>
<span class="nc" id="L210">    }</span>

    /**
     * Get array of users specified in this property.
     */
    public String[] getPermittedStartupUsers() {
<span class="nc" id="L216">        return getStringArray(PERMITTED_STARTUP_USERS);</span>
    }

    /**
     * You can load configurations in precedence order. The first one takes
     * precedence over any loaded later.
     *
     * @param confURL
     *          Configuration URL
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void loadConf(URL confURL) throws ConfigurationException {
<span class="nc" id="L228">        PropertiesConfiguration loadedConf =</span>
<span class="nc" id="L229">                ConfigurationUtil.newConfiguration(conf -&gt; conf.propertiesBuilder(confURL));</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        for (Iterator&lt;String&gt; iter = loadedConf.getKeys(); iter.hasNext(); ) {</span>
<span class="nc" id="L231">            String key = iter.next();</span>
<span class="nc" id="L232">            setProperty(key, loadedConf.getProperty(key));</span>
<span class="nc" id="L233">        }</span>
<span class="nc" id="L234">    }</span>

    /**
     * You can load configuration from other configuration.
     *
     * @param baseConf
     *          Other Configuration
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void loadConf(CompositeConfiguration baseConf) {
<span class="nc bnc" id="L244" title="All 2 branches missed.">        for (Iterator&lt;String&gt; iter = baseConf.getKeys(); iter.hasNext(); ) {</span>
<span class="nc" id="L245">            String key = iter.next();</span>
<span class="nc" id="L246">            setProperty(key, baseConf.getProperty(key));</span>
<span class="nc" id="L247">        }</span>
<span class="nc" id="L248">    }</span>

    /**
     * Get metadata service uri.
     *
     * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; this method silently converts checked exceptions to unchecked exceptions.
     * It is useful to use this method in lambda expressions. However it should not be used with places
     * which have logics to handle checked exceptions. In such cases use {@link #getMetadataServiceUri()} instead.
     *
     * @return metadata service uri
     * @throws UncheckedConfigurationException if the metadata service uri is invalid.
     */
    public String getMetadataServiceUriUnchecked() throws UncheckedConfigurationException {
        try {
<span class="nc" id="L262">            return getMetadataServiceUri();</span>
<span class="nc" id="L263">        } catch (ConfigurationException e) {</span>
<span class="nc" id="L264">            throw new UncheckedConfigurationException(e);</span>
        }
    }

    /**
     * Get metadata service uri.
     *
     * @return metadata service uri.
     * @throws ConfigurationException if the metadata service uri is invalid.
     */
    public String getMetadataServiceUri() throws ConfigurationException {
<span class="nc" id="L275">        String serviceUri = getString(METADATA_SERVICE_URI);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (StringUtils.isBlank(serviceUri)) {</span>
            // no service uri is defined, fallback to old settings
            String ledgerManagerType;
<span class="nc" id="L279">            ledgerManagerType = getLedgerManagerLayoutStringFromFactoryClass();</span>
<span class="nc" id="L280">            String zkServers = getZkServers();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            if (null != zkServers) {</span>
                // URI doesn't accept ','
<span class="nc" id="L283">                serviceUri = String.format(</span>
                    &quot;zk+%s://%s%s&quot;,
                    ledgerManagerType,
<span class="nc" id="L286">                    zkServers.replace(&quot;,&quot;, &quot;;&quot;),</span>
<span class="nc" id="L287">                    getZkLedgersRootPath());</span>
            }
        }
<span class="nc" id="L290">        return serviceUri;</span>
    }

    /**
     * Set the metadata service uri.
     *
     * @param serviceUri the metadata service uri.
     * @return the configuration object.
     */
    public T setMetadataServiceUri(String serviceUri) {
<span class="nc" id="L300">        setProperty(METADATA_SERVICE_URI, serviceUri);</span>
<span class="nc" id="L301">        return getThis();</span>
    }

    /**
     * Get zookeeper servers to connect.
     *
     * &lt;p&gt;`zkServers` is deprecating, in favor of using `metadataServiceUri`
     *
     * @return zookeeper servers
     * @deprecated since 4.7.0
     */
    @Deprecated
    public String getZkServers() {
<span class="nc" id="L314">        List servers = getList(ZK_SERVERS, null);</span>
<span class="nc bnc" id="L315" title="All 4 branches missed.">        if (null == servers || 0 == servers.size()) {</span>
<span class="nc" id="L316">            return null;</span>
        }
<span class="nc" id="L318">        return StringUtils.join(servers, &quot;,&quot;);</span>
    }

    /**
     * Set zookeeper servers to connect.
     *
     * &lt;p&gt;`zkServers` is deprecating, in favor of using `metadataServiceUri`
     *
     * @param zkServers
     *          ZooKeeper servers to connect
     */
    @Deprecated
    public T setZkServers(String zkServers) {
<span class="nc" id="L331">        setProperty(ZK_SERVERS, zkServers);</span>
<span class="nc" id="L332">        return getThis();</span>
    }

    /**
     * Get zookeeper timeout.
     *
     * @return zookeeper server timeout
     */
    public int getZkTimeout() {
<span class="nc" id="L341">        return getInt(ZK_TIMEOUT, 10000);</span>
    }

    /**
     * Set zookeeper timeout.
     *
     * @param zkTimeout
     *          ZooKeeper server timeout
     * @return server configuration
     */
    public T setZkTimeout(int zkTimeout) {
<span class="nc" id="L352">        setProperty(ZK_TIMEOUT, Integer.toString(zkTimeout));</span>
<span class="nc" id="L353">        return getThis();</span>
    }

    /**
     * Get zookeeper client backoff max retry times.
     *
     * @return zk backoff max retry times.
     */
    public int getZkRetryBackoffMaxRetries() {
<span class="nc" id="L362">        return getInt(ZK_RETRY_BACKOFF_MAX_RETRIES, Integer.MAX_VALUE);</span>
    }

    /**
     * Set zookeeper client backoff max retry times.
     *
     * @param maxRetries
     *          backoff max retry times
     * @return server configuration.
     */
    public T setZkRetryBackoffMaxRetries(int maxRetries) {
<span class="nc" id="L373">        setProperty(ZK_RETRY_BACKOFF_MAX_RETRIES, Integer.toString(maxRetries));</span>
<span class="nc" id="L374">        return getThis();</span>
    }

    /**
     * Set Ledger Manager Type.
     *
     * @param lmType
     *          Ledger Manager Type
     * @deprecated replaced by {@link #setLedgerManagerFactoryClass}
     */
    @Deprecated
    public void setLedgerManagerType(String lmType) {
<span class="nc" id="L386">        setProperty(LEDGER_MANAGER_TYPE, lmType);</span>
<span class="nc" id="L387">    }</span>

    /**
     * Get Ledger Manager Type.
     *
     * @return ledger manager type
     *
     * @deprecated replaced by {@link #getLedgerManagerFactoryClass()}
     */
    @Deprecated
    public String getLedgerManagerType() {
<span class="nc" id="L398">        return getString(LEDGER_MANAGER_TYPE);</span>
    }

    /**
     * Set the flag to allow using shaded ledger manager factory class for
     * instantiating a ledger manager factory.
     *
     * @param allowed
     *          the flag to allow/disallow using shaded ledger manager factory class
     * @return configuration instance.
     */
    public T setAllowShadedLedgerManagerFactoryClass(boolean allowed) {
<span class="nc" id="L410">        setProperty(ALLOW_SHADED_LEDGER_MANAGER_FACTORY_CLASS, allowed);</span>
<span class="nc" id="L411">        return getThis();</span>
    }

    /**
     * Is shaded ledger manager factory class name allowed to be used for
     * instantiating ledger manager factory.
     *
     * @return ledger manager factory class name.
     */
    public boolean isShadedLedgerManagerFactoryClassAllowed() {
<span class="nc" id="L421">        return getBoolean(ALLOW_SHADED_LEDGER_MANAGER_FACTORY_CLASS, false);</span>
    }

    /**
     * Set the class prefix of the shaded ledger manager factory class for
     * instantiating a ledger manager factory.
     *
     * &lt;p&gt;This setting only takes effects when {@link #isShadedLedgerManagerFactoryClassAllowed()}
     * returns true.
     *
     * @param classPrefix
     *          the class prefix of shaded ledger manager factory class
     * @return configuration instance.
     */
    public T setShadedLedgerManagerFactoryClassPrefix(String classPrefix) {
<span class="nc" id="L436">        setProperty(SHADED_LEDGER_MANAGER_FACTORY_CLASS_PREFIX, classPrefix);</span>
<span class="nc" id="L437">        return getThis();</span>
    }

    /**
     * Get the class prefix of the shaded ledger manager factory class name allowed to be used for
     * instantiating ledger manager factory.
     *
     * &lt;p&gt;This setting only takes effects when {@link #isShadedLedgerManagerFactoryClassAllowed()}
     * returns true
     *
     * @return ledger manager factory class name.
     * @see #isShadedLedgerManagerFactoryClassAllowed()
     */
    public String getShadedLedgerManagerFactoryClassPrefix() {
<span class="nc" id="L451">        return getString(SHADED_LEDGER_MANAGER_FACTORY_CLASS_PREFIX, &quot;dlshade.&quot;);</span>
    }

    /**
     * Set Ledger Manager Factory Class Name.
     *
     * @param factoryClassName
     *          Ledger Manager Factory Class Name
     */
    public void setLedgerManagerFactoryClassName(String factoryClassName) {
<span class="nc" id="L461">        setProperty(LEDGER_MANAGER_FACTORY_CLASS, factoryClassName);</span>
<span class="nc" id="L462">    }</span>

    /**
     * Get Ledger Manager Factory Class Name.
     *
     * @return ledger manager factory class name.
     */
    public String getLedgerManagerFactoryClassName() {
<span class="nc" id="L470">        return getString(LEDGER_MANAGER_FACTORY_CLASS);</span>
    }

    /**
     * Set Ledger metadata format version.
     *
     * @param metadataFormatVersion
     *          Ledger metadata format version. pass -1 to use default version
     */
    public void setLedgerMetadataFormatVersion(int metadataFormatVersion) {
<span class="nc" id="L480">        setProperty(LEDGER_METADATA_FORMAT_VERSION, metadataFormatVersion);</span>
<span class="nc" id="L481">    }</span>

    /**
     * Get Ledger metadata format version.
     *
     * @return ledger metadata format version.
     */
    public int getLedgerMetadataFormatVersion() {
<span class="nc" id="L489">        return getInt(LEDGER_METADATA_FORMAT_VERSION, -1);</span>
    }

    /**
     * Get layout string (&quot;null&quot; if unconfigured).
     *
     * @return null, hierarchical, longhierarchical, or flat based on LEDGER_MANAGER_FACTORY_CLASS
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public String getLedgerManagerLayoutStringFromFactoryClass() throws ConfigurationException {
        String ledgerManagerType;
<span class="nc" id="L500">        Class&lt;? extends LedgerManagerFactory&gt; factoryClass = getLedgerManagerFactoryClass();</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (factoryClass == null) {</span>
            // set the ledger manager type to &quot;null&quot;, so the driver implementation knows that the type is not set.
<span class="nc" id="L503">            ledgerManagerType = &quot;null&quot;;</span>
        } else {
<span class="nc bnc" id="L505" title="All 2 branches missed.">            if (!AbstractZkLedgerManagerFactory.class.isAssignableFrom(factoryClass)) {</span>
                // this is a non-zk implementation
<span class="nc" id="L507">                throw new ConfigurationException(&quot;metadata service uri is not supported for &quot; + factoryClass);</span>
            }
<span class="nc bnc" id="L509" title="All 2 branches missed.">            if (factoryClass == HierarchicalLedgerManagerFactory.class) {</span>
<span class="nc" id="L510">                ledgerManagerType = HierarchicalLedgerManagerFactory.NAME;</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">            } else if (factoryClass == org.apache.bookkeeper.meta.FlatLedgerManagerFactory.class) {</span>
<span class="nc" id="L512">                ledgerManagerType = org.apache.bookkeeper.meta.FlatLedgerManagerFactory.NAME;</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">            } else if (factoryClass == LongHierarchicalLedgerManagerFactory.class) {</span>
<span class="nc" id="L514">                ledgerManagerType = LongHierarchicalLedgerManagerFactory.NAME;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            } else if (factoryClass == org.apache.bookkeeper.meta.MSLedgerManagerFactory.class) {</span>
<span class="nc" id="L516">                ledgerManagerType = org.apache.bookkeeper.meta.MSLedgerManagerFactory.NAME;</span>
            } else {
<span class="nc" id="L518">                throw new IllegalArgumentException(&quot;Unknown zookeeper based ledger manager factory : &quot;</span>
                        + factoryClass);
            }
        }
<span class="nc" id="L522">        return ledgerManagerType;</span>
    }

    /**
     * Set Ledger Manager Factory Class.
     *
     * @param factoryClass
     *          Ledger Manager Factory Class
     */
    public void setLedgerManagerFactoryClass(Class&lt;? extends LedgerManagerFactory&gt; factoryClass) {
<span class="nc" id="L532">        setProperty(LEDGER_MANAGER_FACTORY_CLASS, factoryClass.getName());</span>
<span class="nc" id="L533">    }</span>

    /**
     * Get ledger manager factory class.
     *
     * @return ledger manager factory class
     */
    public Class&lt;? extends LedgerManagerFactory&gt; getLedgerManagerFactoryClass()
        throws ConfigurationException {
<span class="nc" id="L542">        return ReflectionUtils.getClass(this, LEDGER_MANAGER_FACTORY_CLASS,</span>
                                        null, LedgerManagerFactory.class,
                                        DEFAULT_LOADER);
    }

    /**
     * Set Zk Ledgers Root Path.
     *
     * @param zkLedgersPath zk ledgers root path
     */
    @Deprecated
    public void setZkLedgersRootPath(String zkLedgersPath) {
<span class="nc" id="L554">        setProperty(ZK_LEDGERS_ROOT_PATH, zkLedgersPath);</span>
<span class="nc" id="L555">    }</span>

    /**
     * Get Zk Ledgers Root Path.
     *
     * @return zk ledgers root path
     */
    @Deprecated
    public String getZkLedgersRootPath() {
<span class="nc" id="L564">        return getString(ZK_LEDGERS_ROOT_PATH, &quot;/ledgers&quot;);</span>
    }

    /**
     * Get zookeeper access request rate limit.
     *
     * @return zookeeper access request rate limit.
     */
    public double getZkRequestRateLimit() {
<span class="nc" id="L573">        return getDouble(ZK_REQUEST_RATE_LIMIT, 0);</span>
    }

    /**
     * Set zookeeper access request rate limit.
     *
     * @param rateLimit
     *          zookeeper access request rate limit.
     */
    public void setZkRequestRateLimit(double rateLimit) {
<span class="nc" id="L583">        setProperty(ZK_REQUEST_RATE_LIMIT, rateLimit);</span>
<span class="nc" id="L584">    }</span>

    /**
     * Are z-node created with strict ACLs.
     *
     * @return usage of secure ZooKeeper ACLs
     */
    public boolean isZkEnableSecurity() {
<span class="nc" id="L592">        return getBoolean(ZK_ENABLE_SECURITY, false);</span>
    }

    /**
     * Set the usage of ACLs of new z-nodes.
     *
     * @param zkEnableSecurity
     */
    public void setZkEnableSecurity(boolean zkEnableSecurity) {
<span class="nc" id="L601">        setProperty(ZK_ENABLE_SECURITY, zkEnableSecurity);</span>
<span class="nc" id="L602">    }</span>

    /**
     * Get the node under which available bookies are stored.
     *
     * @return Node under which available bookies are stored.
     */
    @Deprecated
    public String getZkAvailableBookiesPath() {
<span class="nc" id="L611">        return getZkLedgersRootPath() + &quot;/&quot; + AVAILABLE_NODE;</span>
    }

    /**
     * Set the max entries to keep in fragment for re-replication. If fragment
     * has more entries than this count, then the original fragment will be
     * split into multiple small logical fragments by keeping max entries count
     * to rereplicationEntryBatchSize. So, re-replication will happen in batches
     * wise.
     */
    public void setRereplicationEntryBatchSize(long rereplicationEntryBatchSize) {
<span class="nc" id="L622">        setProperty(REREPLICATION_ENTRY_BATCH_SIZE, rereplicationEntryBatchSize);</span>
<span class="nc" id="L623">    }</span>

    /**
     * Get the re-replication entry batch size.
     */
    public long getRereplicationEntryBatchSize() {
<span class="nc" id="L629">        return getLong(REREPLICATION_ENTRY_BATCH_SIZE, 10);</span>
    }

    /**
     * Get metastore implementation class.
     *
     * @return metastore implementation class name.
     */
    public String getMetastoreImplClass() {
<span class="nc" id="L638">        return getString(METASTORE_IMPL_CLASS);</span>
    }

    /**
     * Set metastore implementation class.
     *
     * @param metastoreImplClass
     *          Metastore implementation Class name.
     */
    public void setMetastoreImplClass(String metastoreImplClass) {
<span class="nc" id="L648">        setProperty(METASTORE_IMPL_CLASS, metastoreImplClass);</span>
<span class="nc" id="L649">    }</span>

    /**
     * Get max entries per scan in metastore.
     *
     * @return max entries per scan in metastore.
     */
    public int getMetastoreMaxEntriesPerScan() {
<span class="nc" id="L657">        return getInt(METASTORE_MAX_ENTRIES_PER_SCAN, 50);</span>
    }

    /**
     * Set max entries per scan in metastore.
     *
     * @param maxEntries
     *          Max entries per scan in metastore.
     */
    public void setMetastoreMaxEntriesPerScan(int maxEntries) {
<span class="nc" id="L667">        setProperty(METASTORE_MAX_ENTRIES_PER_SCAN, maxEntries);</span>
<span class="nc" id="L668">    }</span>

    public void setFeature(String configProperty, Feature feature) {
<span class="nc" id="L671">        setProperty(configProperty, feature);</span>
<span class="nc" id="L672">    }</span>

    public Feature getFeature(String configProperty, Feature defaultValue) {
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (null == getProperty(configProperty)) {</span>
<span class="nc" id="L676">            return defaultValue;</span>
        } else {
<span class="nc" id="L678">            return (Feature) getProperty(configProperty);</span>
        }
    }

    /**
     * Set Ledger id formatter Class.
     *
     * @param formatterClass
     *          LedgerIdFormatter Class
     */
    public void setLedgerIdFormatterClass(Class&lt;? extends LedgerIdFormatter&gt; formatterClass) {
<span class="nc" id="L689">        setProperty(LEDGERID_FORMATTER_CLASS, formatterClass.getName());</span>
<span class="nc" id="L690">    }</span>

    /**
     * Get ledger id formatter class.
     *
     * @return LedgerIdFormatter class
     */
    public Class&lt;? extends LedgerIdFormatter&gt; getLedgerIdFormatterClass()
        throws ConfigurationException {
<span class="nc" id="L699">        return ReflectionUtils.getClass(this, LEDGERID_FORMATTER_CLASS, DEFAULT_LEDGERID_FORMATTER,</span>
                LedgerIdFormatter.class, DEFAULT_LOADER);
    }

    /**
     * Set entry formatter Class.
     *
     * @param formatterClass
     *          EntryFormatter Class
     */
    public void setEntryFormatterClass(Class&lt;? extends EntryFormatter&gt; formatterClass) {
<span class="nc" id="L710">        setProperty(ENTRY_FORMATTER_CLASS, formatterClass.getName());</span>
<span class="nc" id="L711">    }</span>

    /**
     * Get entry formatter class.
     *
     * @return EntryFormatter class
     */
    public Class&lt;? extends EntryFormatter&gt; getEntryFormatterClass()
        throws ConfigurationException {
<span class="nc" id="L720">        return ReflectionUtils.getClass(this, ENTRY_FORMATTER_CLASS, DEFAULT_ENTRY_FORMATTER, EntryFormatter.class,</span>
                DEFAULT_LOADER);
    }

    /**
     * Set the client authentication provider factory class name.
     * If this is not set, no authentication will be used
     *
     * @param factoryClass
     *          the client authentication provider factory class name
     * @return client configuration
     */
    public T setClientAuthProviderFactoryClass(
            String factoryClass) {
<span class="nc" id="L734">        setProperty(CLIENT_AUTH_PROVIDER_FACTORY_CLASS, factoryClass);</span>
<span class="nc" id="L735">        return getThis();</span>
    }

    /**
     * Get the client authentication provider factory class name.
     * If this returns null, no authentication will take place.
     *
     * @return the client authentication provider factory class name or null.
     */
    public String getClientAuthProviderFactoryClass() {
<span class="nc" id="L745">        return getString(CLIENT_AUTH_PROVIDER_FACTORY_CLASS, null);</span>
    }

    /**
     * Get the maximum netty frame size in bytes.  Any message received larger
     * that this will be rejected.
     *
     * @return the maximum netty frame size in bytes.
     */
    public int getNettyMaxFrameSizeBytes() {
<span class="nc" id="L755">        return getInt(NETTY_MAX_FRAME_SIZE, DEFAULT_NETTY_MAX_FRAME_SIZE);</span>
    }

    /**
     * Set the max number of bytes a single message can be that is read by the bookie.
     * Any message larger than that size will be rejected.
     *
     * @param maxSize
     *          the max size in bytes
     * @return server configuration
     */
    public T setNettyMaxFrameSizeBytes(int maxSize) {
<span class="nc" id="L767">        setProperty(NETTY_MAX_FRAME_SIZE, String.valueOf(maxSize));</span>
<span class="nc" id="L768">        return getThis();</span>
    }

    /**
     * Get the security provider factory class name. If this returns null, no security will be enforced on the channel.
     *
     * @return the security provider factory class name or null.
     */
    public String getTLSProviderFactoryClass() {
<span class="nc" id="L777">        return getString(TLS_PROVIDER_FACTORY_CLASS, null);</span>
    }

    /**
     * Set the client security provider factory class name. If this is not set, no security will be used on the channel.
     *
     * @param factoryClass
     *            the client security provider factory class name
     * @return client configuration
     */
    public T setTLSProviderFactoryClass(String factoryClass) {
<span class="nc" id="L788">        setProperty(TLS_PROVIDER_FACTORY_CLASS, factoryClass);</span>
<span class="nc" id="L789">        return getThis();</span>
    }

    /**
     * Get TLS Provider (JDK or OpenSSL).
     *
     * @return the TLS provider to use in creating TLS Context
     */
    public String getTLSProvider() {
<span class="nc" id="L798">        return getString(TLS_PROVIDER, &quot;OpenSSL&quot;);</span>
    }

    /**
     * Set TLS Provider (JDK or OpenSSL).
     *
     * @param provider
     *            TLS Provider type
     * @return Client Configuration
     */
    public T setTLSProvider(String provider) {
<span class="nc" id="L809">        setProperty(TLS_PROVIDER, provider);</span>
<span class="nc" id="L810">        return getThis();</span>
    }

    /**
     * Whether the client will send an TLS certificate on TLS-handshake.
     *
     * @see #setTLSClientAuthentication(boolean)
     * @return whether TLS is enabled on the bookie or not.
     */
    public boolean getTLSClientAuthentication() {
<span class="nc" id="L820">        return getBoolean(TLS_CLIENT_AUTHENTICATION, false);</span>
    }

    /**
     * Specify whether the client will send an TLS certificate on TLS-handshake.
     *
     * @param enabled
     *            Whether to send a certificate or not
     * @return client configuration
     */
    public T setTLSClientAuthentication(boolean enabled) {
<span class="nc" id="L831">        setProperty(TLS_CLIENT_AUTHENTICATION, enabled);</span>
<span class="nc" id="L832">        return getThis();</span>
    }

    /**
     * Set tls certificate files refresh duration in seconds.
     *
     * @param certFilesRefreshSec
     *            tls certificate files refresh duration in seconds (set 0 to
     *            disable auto refresh)
     * @return current configuration
     */
    public T setTLSCertFilesRefreshDurationSeconds(long certFilesRefreshSec) {
<span class="nc" id="L844">        setProperty(TLS_CERT_FILES_REFRESH_DURATION_SECONDS, certFilesRefreshSec);</span>
<span class="nc" id="L845">        return getThis();</span>
    }

    /**
     * Get tls certificate files refresh duration in seconds.
     *
     * @return tls certificate files refresh duration in seconds. Default 0
     *         to disable auto refresh.
     *
     */
    public long getTLSCertFilesRefreshDurationSeconds() {
<span class="nc" id="L856">        return getLong(TLS_CERT_FILES_REFRESH_DURATION_SECONDS, 0);</span>
    }

    /**
     * Set the list of enabled TLS cipher suites. Leave null not to override default JDK list. This list will be passed
     * to {@link SSLEngine#setEnabledCipherSuites(String[]) }. Please refer to official JDK JavaDocs
     *
     * @param list
     *            comma separated list of enabled TLS cipher suites
     * @return current configuration
     */
    public T setTLSEnabledCipherSuites(
            String list) {
<span class="nc" id="L869">        setProperty(TLS_ENABLED_CIPHER_SUITES, list);</span>
<span class="nc" id="L870">        return getThis();</span>
    }

    /**
     * Get the list of enabled TLS cipher suites.
     *
     * @return this list of enabled TLS cipher suites
     *
     * @see #setTLSEnabledCipherSuites(String)
     */
    public String getTLSEnabledCipherSuites() {
<span class="nc" id="L881">        return getString(TLS_ENABLED_CIPHER_SUITES, null);</span>
    }

    /**
     * Set the list of enabled TLS protocols. Leave null not to override default JDK list. This list will be passed to
     * {@link SSLEngine#setEnabledProtocols(String[]) }. Please refer to official JDK JavaDocs
     *
     * @param list
     *            comma separated list of enabled TLS cipher suites
     * @return current configuration
     */
    public T setTLSEnabledProtocols(
            String list) {
<span class="nc" id="L894">        setProperty(TLS_ENABLED_PROTOCOLS, list);</span>
<span class="nc" id="L895">        return getThis();</span>
    }

    /**
     * Get the list of enabled TLS protocols.
     *
     * @return the list of enabled TLS protocols.
     *
     * @see #setTLSEnabledProtocols(String)
     */
    public String getTLSEnabledProtocols() {
<span class="nc" id="L906">        return getString(TLS_ENABLED_PROTOCOLS, null);</span>
    }

    /**
     * Set the minimum number of racks per write quorum.
     */
    public void setMinNumRacksPerWriteQuorum(int minNumRacksPerWriteQuorum) {
<span class="nc" id="L913">        setProperty(MIN_NUM_RACKS_PER_WRITE_QUORUM, minNumRacksPerWriteQuorum);</span>
<span class="nc" id="L914">    }</span>

    /**
     * Get the minimum number of racks per write quorum.
     */
    public int getMinNumRacksPerWriteQuorum() {
<span class="nc" id="L920">        return getInteger(MIN_NUM_RACKS_PER_WRITE_QUORUM, 2);</span>
    }

    /**
     * Set the minimum number of zones per write quorum in
     * ZoneAwarePlacementPolicy.
     */
    public void setMinNumZonesPerWriteQuorum(int minNumZonesPerWriteQuorum) {
<span class="nc" id="L928">        setProperty(MIN_NUM_ZONES_PER_WRITE_QUORUM, minNumZonesPerWriteQuorum);</span>
<span class="nc" id="L929">    }</span>

    /**
     * Get the minimum number of zones per write quorum in
     * ZoneAwarePlacementPolicy.
     */
    public int getMinNumZonesPerWriteQuorum() {
<span class="nc" id="L936">        return getInteger(MIN_NUM_ZONES_PER_WRITE_QUORUM, 2);</span>
    }

    /**
     * Set the desired number of zones per write quorum in
     * ZoneAwarePlacementPolicy.
     */
    public void setDesiredNumZonesPerWriteQuorum(int desiredNumZonesPerWriteQuorum) {
<span class="nc" id="L944">        setProperty(DESIRED_NUM_ZONES_PER_WRITE_QUORUM, desiredNumZonesPerWriteQuorum);</span>
<span class="nc" id="L945">    }</span>

    /**
     * Get the desired number of zones per write quorum in
     * ZoneAwarePlacementPolicy.
     */
    public int getDesiredNumZonesPerWriteQuorum() {
<span class="nc" id="L952">        return getInteger(DESIRED_NUM_ZONES_PER_WRITE_QUORUM, 3);</span>
    }

    /**
     * Set the flag to enforce strict zoneaware placement.
     *
     * &lt;p&gt;in ZoneawareEnsemblePlacementPolicy if strict placement is enabled then
     * minZones/desiredZones in writeQuorum would be maintained otherwise it
     * will pick nodes randomly.
     */
    public void setEnforceStrictZoneawarePlacement(boolean enforceStrictZoneawarePlacement) {
<span class="nc" id="L963">        setProperty(ENFORCE_STRICT_ZONEAWARE_PLACEMENT, enforceStrictZoneawarePlacement);</span>
<span class="nc" id="L964">    }</span>

    /**
     * Get the flag to enforce strict zoneaware placement.
     *
     * &lt;p&gt;in ZoneawareEnsemblePlacementPolicy if strict placement is enabled then
     * minZones/desiredZones in writeQuorum would be maintained otherwise it
     * will pick nodes randomly.
     */
    public boolean getEnforceStrictZoneawarePlacement() {
<span class="nc" id="L974">        return getBoolean(ENFORCE_STRICT_ZONEAWARE_PLACEMENT, true);</span>
    }

    /**
     * Set the flag to enforce minimum number of racks per write quorum.
     */
    public void setEnforceMinNumRacksPerWriteQuorum(boolean enforceMinNumRacksPerWriteQuorum) {
<span class="nc" id="L981">        setProperty(ENFORCE_MIN_NUM_RACKS_PER_WRITE_QUORUM, enforceMinNumRacksPerWriteQuorum);</span>
<span class="nc" id="L982">    }</span>

    /**
     * Get the flag which enforces the minimum number of racks per write quorum.
     */
    public boolean getEnforceMinNumRacksPerWriteQuorum() {
<span class="nc" id="L988">        return getBoolean(ENFORCE_MIN_NUM_RACKS_PER_WRITE_QUORUM, false);</span>
    }

    /**
     * Set the flag to enforce minimum number of fault domains for write.
     */
    public void setEnforceMinNumFaultDomainsForWrite(boolean enforceMinNumFaultDomainsForWrite) {
<span class="nc" id="L995">        setProperty(ENFORCE_MIN_NUM_FAULT_DOMAINS_FOR_WRITE, enforceMinNumFaultDomainsForWrite);</span>
<span class="nc" id="L996">    }</span>

    /**
     * Get the flag to enforce minimum number of fault domains for write.
     */
    public boolean getEnforceMinNumFaultDomainsForWrite() {
<span class="nc" id="L1002">        return getBoolean(ENFORCE_MIN_NUM_FAULT_DOMAINS_FOR_WRITE, false);</span>
    }

    /**
     * Sets the flag to ignore usage of localnode in placement policy.
     */
    public void setIgnoreLocalNodeInPlacementPolicy(boolean ignoreLocalNodeInPlacementPolicy) {
<span class="nc" id="L1009">        setProperty(IGNORE_LOCAL_NODE_IN_PLACEMENT_POLICY, ignoreLocalNodeInPlacementPolicy);</span>
<span class="nc" id="L1010">    }</span>

    /**
     * Whether to ignore localnode in placementpolicy.
     */
    public boolean getIgnoreLocalNodeInPlacementPolicy() {
<span class="nc" id="L1016">        return getBoolean(IGNORE_LOCAL_NODE_IN_PLACEMENT_POLICY, false);</span>
    }

    /**
     * Enable the Auditor to use system time as underreplicated ledger mark
     * time.
     *
     * &lt;p&gt;If this is enabled, Auditor will write a ctime field into the
     * underreplicated ledger znode.
     *
     * @param enabled
     *            flag to enable/disable Auditor using system time as
     *            underreplicated ledger mark time.
     */
    public T setStoreSystemTimeAsLedgerUnderreplicatedMarkTime(boolean enabled) {
<span class="nc" id="L1031">        setProperty(STORE_SYSTEMTIME_AS_LEDGER_UNDERREPLICATED_MARK_TIME, enabled);</span>
<span class="nc" id="L1032">        return getThis();</span>
    }

    /**
     * Return the flag that indicates whether auditor is using system time as
     * underreplicated ledger mark time.
     *
     * @return the flag that indicates whether auditor is using system time as
     *         underreplicated ledger mark time.
     */
    public boolean getStoreSystemTimeAsLedgerUnderreplicatedMarkTime() {
<span class="nc" id="L1043">        return getBoolean(STORE_SYSTEMTIME_AS_LEDGER_UNDERREPLICATED_MARK_TIME, true);</span>
    }

    /**
     * Whether to preserve MDC for tasks in Executor.
     *
     * @return flag to enable/disable MDC preservation in Executor.
     */
    public boolean getPreserveMdcForTaskExecution() {
<span class="nc" id="L1052">        return getBoolean(PRESERVE_MDC_FOR_TASK_EXECUTION, false);</span>
    }

    /**
     * Whether to preserve MDC for tasks in Executor.
     *
     * @param enabled
     *          flag to enable/disable MDC preservation in Executor.
     * @return configuration.
     */
    public T setPreserveMdcForTaskExecution(boolean enabled) {
<span class="nc" id="L1063">        setProperty(PRESERVE_MDC_FOR_TASK_EXECUTION, enabled);</span>
<span class="nc" id="L1064">        return getThis();</span>
    }

    /**
     * @return the configured pooling policy for the allocator.
     */
    public PoolingPolicy getAllocatorPoolingPolicy() {
<span class="nc" id="L1071">        return PoolingPolicy.valueOf(this.getString(ALLOCATOR_POOLING_POLICY, PoolingPolicy.PooledDirect.toString()));</span>
    }

    /**
     * Define the memory pooling policy.
     *
     * &lt;p&gt;Default is {@link PoolingPolicy#PooledDirect}
     *
     * @param poolingPolicy
     *            the memory pooling policy
     * @return configuration object.
     */
    public T setAllocatorPoolingPolicy(PoolingPolicy poolingPolicy) {
<span class="nc" id="L1084">        this.setProperty(ALLOCATOR_POOLING_POLICY, poolingPolicy.toString());</span>
<span class="nc" id="L1085">        return getThis();</span>
    }

    /**
     * @return the configured pooling concurrency for the allocator.
     */
    public int getAllocatorPoolingConcurrency() {
<span class="nc" id="L1092">        return this.getInteger(ALLOCATOR_POOLING_CONCURRENCY, PooledByteBufAllocator.defaultNumDirectArena());</span>
    }

    /**
     * Controls the amount of concurrency for the memory pool.
     *
     * &lt;p&gt;Default is to have a number of allocator arenas equals to 2 * CPUS.
     *
     * &lt;p&gt;Decreasing this number will reduce the amount of memory overhead, at the
     * expense of increased allocation contention.
     *
     * @param concurrency
     *            the concurrency level to use for the allocator pool
     * @return configuration object.
     */
    public T setAllocatorPoolingConcurrency(int concurrency) {
<span class="nc" id="L1108">        this.setProperty(ALLOCATOR_POOLING_POLICY, concurrency);</span>
<span class="nc" id="L1109">        return getThis();</span>
    }

    /**
     * @return the configured ouf of memory policy for the allocator.
     */
    public OutOfMemoryPolicy getAllocatorOutOfMemoryPolicy() {
<span class="nc" id="L1116">        return OutOfMemoryPolicy</span>
<span class="nc" id="L1117">                .valueOf(this.getString(ALLOCATOR_OOM_POLICY, OutOfMemoryPolicy.FallbackToHeap.toString()));</span>
    }

    /**
     * Define the memory allocator out of memory policy.
     *
     * &lt;p&gt;Default is {@link OutOfMemoryPolicy#FallbackToHeap}
     *
     * @param oomPolicy
     *            the &quot;out-of-memory&quot; policy for the memory allocator
     * @return configuration object.
     */
    public T setAllocatorOutOfMemoryPolicy(OutOfMemoryPolicy oomPolicy) {
<span class="nc" id="L1130">        this.setProperty(ALLOCATOR_OOM_POLICY, oomPolicy.toString());</span>
<span class="nc" id="L1131">        return getThis();</span>
    }

    /**
     * Return the configured leak detection policy for the allocator.
     */
    public LeakDetectionPolicy getAllocatorLeakDetectionPolicy() {
        //see: https://lists.apache.org/thread/d3zw8bxhlg0wxfhocyjglq0nbxrww3sg
<span class="nc" id="L1139">        String nettyLevelStr = System.getProperty(&quot;io.netty.leakDetectionLevel&quot;, LeakDetectionPolicy.Disabled.name());</span>
<span class="nc" id="L1140">        nettyLevelStr = System.getProperty(&quot;io.netty.leakDetection.level&quot;, nettyLevelStr);</span>
<span class="nc" id="L1141">        String bkLevelStr = getString(ALLOCATOR_LEAK_DETECTION_POLICY, LeakDetectionPolicy.Disabled.name());</span>
<span class="nc" id="L1142">        LeakDetectionPolicy nettyLevel = LeakDetectionPolicy.parseLevel(nettyLevelStr);</span>
<span class="nc" id="L1143">        LeakDetectionPolicy bkLevel = LeakDetectionPolicy.parseLevel(bkLevelStr);</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        if (nettyLevel.ordinal() &gt;= bkLevel.ordinal()) {</span>
<span class="nc" id="L1145">            return nettyLevel;</span>
        } else {
<span class="nc" id="L1147">            return bkLevel;</span>
        }
    }

    /**
     * Enable the leak detection for the allocator.
     *
     * &lt;p&gt;Default is {@link LeakDetectionPolicy#Disabled}
     *
     * @param leakDetectionPolicy
     *            the leak detection policy for the memory allocator
     * @return configuration object.
     */
    public T setAllocatorLeakDetectionPolicy(LeakDetectionPolicy leakDetectionPolicy) {
<span class="nc" id="L1161">        this.setProperty(ALLOCATOR_LEAK_DETECTION_POLICY, leakDetectionPolicy.toString());</span>
<span class="nc" id="L1162">        return getThis();</span>
    }

    public T setExitOnOutOfMemory(boolean exitOnOutOfMemory) {
<span class="nc" id="L1166">        this.setProperty(ALLOCATOR_EXIT_ON_OUT_OF_MEMORY, exitOnOutOfMemory);</span>
<span class="nc" id="L1167">        return getThis();</span>
    }

    public boolean exitOnOutOfMemory() {
<span class="nc" id="L1171">        return getBoolean(ALLOCATOR_EXIT_ON_OUT_OF_MEMORY, false);</span>
    }

    /**
     * Return whether the busy-wait is enabled for BookKeeper and Netty IO threads.
     *
     * &lt;p&gt;Default is false
     *
     * @return the value of the option
     */
    public boolean isBusyWaitEnabled() {
<span class="nc" id="L1182">        return getBoolean(ENABLE_BUSY_WAIT, false);</span>
    }

    /**
     * Option to enable busy-wait settings.
     *
     * &lt;p&gt;Default is false.
     *
     * &lt;p&gt;WARNING: This option will enable spin-waiting on executors and IO threads
     * in order to reduce latency during context switches. The spinning will
     * consume 100% CPU even when bookie is not doing any work. It is
     * recommended to reduce the number of threads in the main workers pool
     * ({@link ClientConfiguration#setNumWorkerThreads(int)}) and Netty event
     * loop {@link ClientConfiguration#setNumIOThreads(int)} to only have few
     * CPU cores busy.
     * &lt;/p&gt;
     *
     * @param busyWaitEnabled
     *            if enabled, use spin-waiting strategy to reduce latency in
     *            context switches
     *
     * @see #isBusyWaitEnabled()
     */
    public T setBusyWaitEnabled(boolean busyWaitEnabled) {
<span class="nc" id="L1206">        setProperty(ENABLE_BUSY_WAIT, busyWaitEnabled);</span>
<span class="nc" id="L1207">        return getThis();</span>
    }

    /**
     * Return the flag indicating whether to limit stats logging.
     *
     * @return
     *      the boolean flag indicating whether to limit stats logging
     */
    public boolean getLimitStatsLogging() {
<span class="nc" id="L1217">        return getBoolean(LIMIT_STATS_LOGGING, true);</span>
    }

    /**
     * Sets flag to limit the stats logging.
     *
     * @param limitStatsLogging
     *          flag to limit the stats logging.
     * @return configuration.
     */
    public T setLimitStatsLogging(boolean limitStatsLogging) {
<span class="nc" id="L1228">        setProperty(LIMIT_STATS_LOGGING, limitStatsLogging);</span>
<span class="nc" id="L1229">        return getThis();</span>
    }

    /**
     * Get the bytes rate of re-replication.
     * Default value is -1 which it means entries will replicated without any throttling activity.
     *
     * @return bytes rate of re-replication.
     */
    public int getReplicationRateByBytes() {
<span class="nc" id="L1239">        return getInt(REPLICATION_RATE_BY_BYTES, -1);</span>
    }

    /**
     * Set the bytes rate of re-replication.
     *
     * @param rate bytes rate of re-replication.
     *
     * @return ClientConfiguration
     */
    public T setReplicationRateByBytes(int rate) {
<span class="nc" id="L1250">        this.setProperty(REPLICATION_RATE_BY_BYTES, rate);</span>
<span class="nc" id="L1251">        return getThis();</span>
    }

    /**
     * get the max tasks can be acquired per second of re-replication.
     * @return max tasks can be acquired per second of re-replication.
     */
    public double getZkReplicationTaskRateLimit() {
<span class="nc" id="L1259">        return getDouble(ZK_REPLICATION_TASK_RATE_LIMIT, 0);</span>
    }

    /**
     * set the max tasks can be acquired per second of re-replication, default is 0, which means no limit.
     * Value greater than 0 will enable the rate limiting. Decimal value is allowed.
     * For example, 0.5 means 1 task per 2 seconds, 1 means 1 task per second.
     * @param zkReplicationTaskRateLimit
     * @return ClientConfiguration
     */
    public T setZkReplicationTaskRateLimit(double zkReplicationTaskRateLimit) {
<span class="nc" id="L1270">        setProperty(ZK_REPLICATION_TASK_RATE_LIMIT, zkReplicationTaskRateLimit);</span>
<span class="nc" id="L1271">        return getThis();</span>
    }

    /**
     * Trickery to allow inheritance with fluent style.
     */
    protected abstract T getThis();

    /**
     * returns the string representation of json format of this config.
     *
     * @return
     * @throws ParseJsonException
     */
    public String asJson() throws ParseJsonException {
<span class="nc" id="L1286">        return JsonUtil.toJson(toMap());</span>
    }

    private Map&lt;String, Object&gt; toMap() {
<span class="nc" id="L1290">        Map&lt;String, Object&gt; configMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1291">        Iterator&lt;String&gt; iterator = this.getKeys();</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">        while (iterator.hasNext()) {</span>
<span class="nc" id="L1293">            String key = iterator.next();</span>
<span class="nc" id="L1294">            Object property = this.getProperty(key);</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">            if (property != null) {</span>
<span class="nc" id="L1296">                configMap.put(key, property.toString());</span>
            }
<span class="nc" id="L1298">        }</span>
<span class="nc" id="L1299">        return configMap;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>